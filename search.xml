<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>DOM节点关系属性</title>
      <link href="/2018/07/02/DOM%E8%8A%82%E7%82%B9%E5%85%B3%E7%B3%BB%E5%B1%9E%E6%80%A7/"/>
      <url>/2018/07/02/DOM%E8%8A%82%E7%82%B9%E5%85%B3%E7%B3%BB%E5%B1%9E%E6%80%A7/</url>
      <content type="html"><![CDATA[<h1 id="父级属性"><a href="#父级属性" class="headerlink" title="父级属性"></a>父级属性</h1><h2 id="parentNode"><a href="#parentNode" class="headerlink" title="parentNode"></a>parentNode</h2><p>每个节点都有一个parentNode属性，该属性指向文档树中的父节点。对于一个节点来说，它的父节点只可能是三种类型：element节点、document节点和documentfragment节点。如果不存在，则返回null.<a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;myDiv&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">console.log(myDiv.parentNode);//body</span><br><span class="line">console.log(document.body.parentNode);//html</span><br><span class="line">console.log(document.documentElement.parentNode);//document</span><br><span class="line">console.log(document.parentNode);//null</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><h2 id="parentElement"><a href="#parentElement" class="headerlink" title="parentElement"></a>parentElement</h2><p>与parentNode属性不同的是，parentElement返回的是父元素节点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;myDiv&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">console.log(myDiv.parentElement);//body</span><br><span class="line">console.log(document.body.parentElement);//html</span><br><span class="line">console.log(document.documentElement.parentElement);//null</span><br><span class="line">console.log(document.parentElement);//null</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><hr><h1 id="子级属性"><a href="#子级属性" class="headerlink" title="子级属性"></a>子级属性</h1><h2 id="childNodes"><a href="#childNodes" class="headerlink" title="childNodes"></a>childNodes</h2><p>childNodes是一个只读的类数组对象NodeList对象，它保存着该节点的<font color="blue">第一层子节点</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=&quot;myUl&quot;&gt;</span><br><span class="line">&lt;li&gt;</span><br><span class="line">&lt;div&gt;&lt;/div&gt;</span><br><span class="line">&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var myUl = document.getElementById(&apos;myUl&apos;);</span><br><span class="line">console.log(myUl.childNodes);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>结果<br><img src="/images/DOM节点关系属性/1.png"><br>text节点是因为html中li前后有空格。</p><h2 id="children"><a href="#children" class="headerlink" title="children"></a>children</h2><p>children是一个只读的类数组对象HTMLCollection对象，但它保存的是该节点的<font color="blue">第一层<font color="red">元素</font>子节点</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;myDiv&quot;&gt;123&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var myDiv = document.getElementById(&apos;myDiv&apos;);</span><br><span class="line">//childNodes包含所有类型的节点，所以输出[text]</span><br><span class="line">console.log(myDiv.childNodes);</span><br><span class="line">//children只包含元素节点，所以输出[]</span><br><span class="line">console.log(myDiv.children);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><h2 id="childElementCount"><a href="#childElementCount" class="headerlink" title="childElementCount"></a>childElementCount</h2><p>返回<font color="red">子元素</font>节点的个数，相当于children.length<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=&quot;myUl&quot;&gt;</span><br><span class="line">    &lt;li&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var myUl = document.getElementById(&apos;myUl&apos;);</span><br><span class="line">console.log(myUl.childNodes.length);//5，IE8-浏览器返回2，因为不包括空文本节点</span><br><span class="line">console.log(myUl.children.length);//2</span><br><span class="line">console.log(myUl.childElementCount);//2，IE8-浏览器返回undefined</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><h2 id="firstChild"><a href="#firstChild" class="headerlink" title="firstChild"></a>firstChild</h2><p>第一个子节点</p><h2 id="lastChild"><a href="#lastChild" class="headerlink" title="lastChild"></a>lastChild</h2><p>最后一个子节点</p><h2 id="firstElementChild"><a href="#firstElementChild" class="headerlink" title="firstElementChild"></a>firstElementChild</h2><p>第一个元素子节点</p><h2 id="lastElementChild"><a href="#lastElementChild" class="headerlink" title="lastElementChild"></a>lastElementChild</h2><p>最后一个元素子节点　<br>上面四个属性，IE8-浏览器和标准浏览器的表现并不一致。<font color="red">IE8-浏览器不考虑空白文本节点，且不支持firstElementChild和lastElementChild</font><br><em>ul标签和li标签之间有两个空白文本节点，所以按照标准来说，ul的子节点包括[空白文本节点、li元素节点、空白文本节点]。但在IE8-浏览器中，ul的子节点只包括[li元素节点]</em></p><hr><h1 id="同级属性"><a href="#同级属性" class="headerlink" title="同级属性"></a>同级属性</h1><h2 id="nextSibling"><a href="#nextSibling" class="headerlink" title="nextSibling"></a>nextSibling</h2><p>后一个节点</p><h2 id="previousSibling"><a href="#previousSibling" class="headerlink" title="previousSibling"></a>previousSibling</h2><p>前一个节点</p><h2 id="nextElementSibling"><a href="#nextElementSibling" class="headerlink" title="nextElementSibling"></a>nextElementSibling</h2><p>后一个元素节点</p><h2 id="previousElementSibling"><a href="#previousElementSibling" class="headerlink" title="previousElementSibling"></a>previousElementSibling</h2><p>前一个元素节点<br>与子级属性类似，上面四个属性，IE8-浏览器和标准浏览器的表现并不一致。IE8-浏览器不考虑空白文本节点，且不支持nextElementSibling和previousElementSibling<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;1&lt;/li&gt;</span><br><span class="line">    &lt;li id=&quot;myLi&quot;&gt;2&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;3&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var myLi = document.getElementById(&apos;myLi&apos;);</span><br><span class="line">console.log(myLi.nextSibling);//空白节点，IE8-浏览器返回&lt;li&gt;3&lt;/li&gt;</span><br><span class="line">console.log(myLi.nextElementSibling);//&lt;li&gt;3&lt;/li&gt;，IE8-浏览器返回undefined</span><br><span class="line">console.log(myLi.previousSibling);//空白节点，IE8-浏览器返回&lt;li&gt;1&lt;/li&gt;</span><br><span class="line">console.log(myLi.previousElementSibling);//&lt;li&gt;1&lt;/li&gt;，IE8-浏览器返回undefined</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><hr><p><strong>日常啰嗦</strong>：感觉这一部分的东西太多了，先总结个一部分。</p>]]></content>
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>关于DOM节点</title>
      <link href="/2018/07/02/%E5%85%B3%E4%BA%8EDOM%E8%8A%82%E7%82%B9/"/>
      <url>/2018/07/02/%E5%85%B3%E4%BA%8EDOM%E8%8A%82%E7%82%B9/</url>
      <content type="html"><![CDATA[<h1 id="DOM-节点"><a href="#DOM-节点" class="headerlink" title="DOM 节点"></a>DOM 节点</h1><p>根据 W3C 的 HTML DOM 标准，HTML 文档中的所有内容都是节点：<a id="more"></a></p><ul><li>整个文档是一个文档节点</li><li>每个 HTML 元素是元素节点</li><li>HTML 元素内的文本是文本节点</li><li>每个 HTML 属性是属性节点</li><li>注释是注释节点</li></ul><p>通过 HTML DOM，树中的所有节点均可通过 JavaScript 进行访问。所有 HTML 元素（节点）均可被修改，也可以创建或删除节点。</p><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">createDocumentFragment() //创建一个DOM片段</span><br><span class="line">createElement() //创建一个元素节点</span><br><span class="line">createTextNode() //创建一个文本节点</span><br></pre></td></tr></table></figure><p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var element = document.createElement(&quot;div&quot;);</span><br><span class="line">var textNode = document.createTextNode(&quot;Hello world!&quot;);</span><br><span class="line">element.appendChild(textNode);</span><br></pre></td></tr></table></figure></p><h2 id="添加、删除、替换、插入"><a href="#添加、删除、替换、插入" class="headerlink" title="添加、删除、替换、插入"></a>添加、删除、替换、插入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">appendChild() //插入新的子节点（元素）</span><br><span class="line">removeChild() //删除子节点（元素）</span><br><span class="line">replaceChild() //替换</span><br><span class="line">insertBefore() //插入</span><br></pre></td></tr></table></figure><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getElementsByTagName() //返回带有指定标签名的所有元素。</span><br><span class="line">getElementsByName() //返回相同类名的所有 HTML 元素</span><br><span class="line">getElementById() //方法返回带有指定 ID 的元素，唯一性</span><br></pre></td></tr></table></figure><p><font color="red">混合使用</font>（不像jquery有.和#的概念）<br>返回包含文档中所有 &lt;p&gt; 元素的列表，并且这些 &lt;p&gt; 元素应该是 id=”main” 的元素的后代（子、孙等等）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.getElementById(&quot;main&quot;).getElementsByTagName(&quot;p&quot;);</span><br></pre></td></tr></table></figure></p><hr><p><strong>日常啰嗦</strong>：感觉总结的不够完美，日后再来填坑。</p>]]></content>
      
      <categories>
          
          <category> javascript </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>a :hover 和a:hover 区别</title>
      <link href="/2018/07/02/a-hover-%E5%92%8Ca-hover-%E5%8C%BA%E5%88%AB/"/>
      <url>/2018/07/02/a-hover-%E5%92%8Ca-hover-%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<p>HTML代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;&quot;&gt;a标签内  &lt;span&gt;a标签的子标签内&lt;/span&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure></p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">article a :hover &#123;</span><br><span class="line">  color:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面表示 article 内所有a 标签的所有<font color="blue">子标签</font>在hover时是红色。<br><img src="/images/a-hover-和a-hover-区别/1.png" alt="a-hover-和a-hover-区别"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">article a:hover &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面表示，article内的所有a标签的在hover时是红色。<br><img src="/images/a-hover-和a-hover-区别/2.png" alt="a-hover-和a-hover-区别"></p><h3 id="关键在于："><a href="#关键在于：" class="headerlink" title="关键在于："></a>关键在于：</h3><p>有空格的是后代选择器</p><hr><p><strong>日常啰嗦</strong>：初见时有点想不明白，其实只要抓住最主要的核心，后代选择器就可以了。</p>]]></content>
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>sass语法</title>
      <link href="/2018/07/02/sass%E8%AF%AD%E6%B3%95/"/>
      <url>/2018/07/02/sass%E8%AF%AD%E6%B3%95/</url>
      <content type="html"><![CDATA[<h1 id="1-变量"><a href="#1-变量" class="headerlink" title="1. 变量"></a><font color="red">1. 变量</font></h1><p>sass通过$声明变量，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$headline-ff:Arial;</span><br><span class="line">$main-sec-ff:Tahoma;</span><br><span class="line">h1&#123;</span><br><span class="line">font-family: $headline-ff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><hr><h1 id="2-import"><a href="#2-import" class="headerlink" title="2. @import"></a><font color="red">2. @import</font></h1><p>利用sass的@import能力，创建变量文件，并引入宿主文件：<br>宿主文件screen.scss代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@import &quot;variables&quot; </span><br><span class="line">h1&#123;</span><br><span class="line">   font-family: $headline-ff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>@import时前置下划线 和 后缀.scss或者.sass可以省略，所以统一目录下 有了_variables文件就不能再有variables文件<br>变量文件_variables.scss代码：（利用compass watch 时，如果创建的scss文件名前加入了下划线_,则不会被编译对应的css文件）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$headline-ff:Arial;</span><br><span class="line">$main-sec-ff:Tahoma;</span><br></pre></td></tr></table></figure></p><p>经过编译后的screen.css代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">h1 &#123;</span><br><span class="line">  font-family: Arial;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><font color="red">原生css中@import与scss中@import的区别：</font><br>原生css@import的缺点：<br>1、需要放到代码最前端才生效<br>2、当浏览器读到这条@import指令时才会加载对应的@import的文件。性能差<br>scss中@import特点：<br>1、可以放到scss文件的任意位置，scss在编译后会将 宿主文件和 变量文件 合并到一个css文件<br>2、宿主文件中可以任意引用变量文件中的 变量和mixin函数。<br>3、可以一次@import多个文件，利用逗号分隔:<br>@import “_variables.scss”,”compass/reset”;</p><hr><h1 id="3-注释："><a href="#3-注释：" class="headerlink" title="3. 注释："></a><font color="red">3. 注释：</font></h1><p>1、支持// 和/<strong>/<br>2、在编译后的css文件中，以//注释的内容不会被输出，以/</strong>/注释的内容会被输出。<br>3、编译后的css文件中会有自动生成的注释信息，方便我们定位相应的.scss文件，方便样式调试。</p><hr><h1 id="4-嵌套语法："><a href="#4-嵌套语法：" class="headerlink" title="4. 嵌套语法："></a><font color="red">4. 嵌套语法：</font></h1><p>选择器嵌套：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$headline-ff:Arial;</span><br><span class="line">$main-sec-ff:Tahoma;</span><br><span class="line">div&#123;</span><br><span class="line">font-family: $main-sec-ff;</span><br><span class="line">h1&#123;</span><br><span class="line">font-family: $headline-ff;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译后的css文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">  font-family: Tahoma;</span><br><span class="line">&#125;</span><br><span class="line">div h1 &#123;</span><br><span class="line">  font-family: Arial;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>属性嵌套：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">font:&#123;  //不要丢掉冒号&quot;:&quot;</span><br><span class="line">family: Tahoma;</span><br><span class="line">size: 16px;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译后的css文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">  font-family: Tahoma;</span><br><span class="line">  font-size: 16px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>区别下面两种写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a&#123;</span><br><span class="line">:hover&#123;</span><br><span class="line">color: #c50000</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">a&#123;</span><br><span class="line">&amp;:hover&#123;   //”&amp;“为父类选择器。</span><br><span class="line">color: #c50000</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译后的css文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a :hover &#123;</span><br><span class="line">  color: #c50000;</span><br><span class="line">&#125;</span><br><span class="line">a:hover &#123;</span><br><span class="line">  color: #c50000;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>两者区别见<a href="https://xieshuangting.github.io/2018/07/02/a-hover-和a-hover-区别/" target="_blank" rel="noopener">https://xieshuangting.github.io/2018/07/02/a-hover-和a-hover-区别/</a></p><hr>]]></content>
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>less语法</title>
      <link href="/2018/07/01/less%E8%AF%AD%E6%B3%95/"/>
      <url>/2018/07/01/less%E8%AF%AD%E6%B3%95/</url>
      <content type="html"><![CDATA[<h1 id="1-变量"><a href="#1-变量" class="headerlink" title="1. 变量"></a><font color="red">1. 变量</font></h1><p>可以将属性的值赋值给一个变量，变量为完全的 “常量” ，所以只能定义一次<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@nice-blue: #5B83AD;</span><br><span class="line">@light-blue: @nice-blue + #111;</span><br><span class="line">#header &#123; color: @light-blue; &#125;</span><br><span class="line">结果 #header &#123; color: #6c94be; &#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>也可以用变量名定义为变量<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@fnord: &quot;I am fnord.&quot;;</span><br><span class="line">@var: &apos;fnord&apos;;</span><br><span class="line">content: &lt;font color=&quot;blue&quot;&gt;@@var&lt;/font&gt;;</span><br><span class="line">结果 content: &quot;I am fnord.&quot;;</span><br></pre></td></tr></table></figure></p><h1 id="2-混合"><a href="#2-混合" class="headerlink" title="2. 混合"></a><font color="red">2. 混合</font></h1><p>混合可以将一个定义好的class A轻松的引入到另一个class B中，从而简单实现class B继承class A中的所有属性。我们还可以带参数地调用，就像使用函数一样。<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.rounded-corners (@radius: 5px) &#123;</span><br><span class="line">border-radius: @radius;</span><br><span class="line">-webkit-border-radius: @radius;</span><br><span class="line">-moz-border-radius: @radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#header &#123;</span><br><span class="line">.rounded-corners;</span><br><span class="line">&#125;</span><br><span class="line">#footer &#123;</span><br><span class="line">.rounded-corners(10px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#header &#123;</span><br><span class="line">border-radius: 5px;</span><br><span class="line">-webkit-border-radius: 5px;</span><br><span class="line">-moz-border-radius: 5px;</span><br><span class="line">&#125;</span><br><span class="line">#footer &#123;</span><br><span class="line">border-radius: 10px;</span><br><span class="line">-webkit-border-radius: 10px;</span><br><span class="line">-moz-border-radius: 10px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>@arguments包含了所有传递进来的参数。不必单独处理每一个参数。<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.box-shadow (@x: 0, @y: 0, @blur: 1px, @color: #000) &#123;</span><br><span class="line">box-shadow: @arguments;</span><br><span class="line">-moz-box-shadow: @arguments;</span><br><span class="line">-webkit-box-shadow: @arguments;</span><br><span class="line">&#125;</span><br><span class="line">.box-shadow(2px, 5px);</span><br></pre></td></tr></table></figure></p><p>结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">box-shadow: 2px 5px 1px #000;</span><br><span class="line">-moz-box-shadow: 2px 5px 1px #000;</span><br><span class="line">-webkit-box-shadow: 2px 5px 1px #000;</span><br></pre></td></tr></table></figure></p><h1 id="3-模式匹配"><a href="#3-模式匹配" class="headerlink" title="3. 模式匹配"></a><font color="red">3. 模式匹配</font></h1><p>根据传入的参数来改变混合的默认呈现<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//让.mixin根据不同的@switch值而表现各异</span><br><span class="line">.mixin (dark, @color) &#123;</span><br><span class="line">color: darken(@color, 10%);</span><br><span class="line">&#125;</span><br><span class="line">.mixin (light, @color) &#123;</span><br><span class="line">color: lighten(@color, 10%);</span><br><span class="line">&#125;</span><br><span class="line">.mixin (@_, @color) &#123;</span><br><span class="line">display: block;</span><br><span class="line">&#125;</span><br><span class="line">//运行</span><br><span class="line">@switch: light;</span><br><span class="line">.class &#123;</span><br><span class="line">.mixin(@switch, #888);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.class &#123;</span><br><span class="line">color: #a2a2a2;</span><br><span class="line">display: block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>mixin就会得到传入颜色的浅色。如果@switch设为dark，就会得到深色。<br>具体实现如下：<br>第一个混合定义并未被匹配，因为它只接受dark做为首参<br>第二个混合定义被成功匹配，因为它只接受light<br>第三个混合定义被成功匹配，因为它接受任意值<br>只有被匹配的混合才会被使用。变量可以匹配任意的传入值，而变量以外的固定值就仅仅匹配与其相等的传入值。</p><h1 id="4-命名空间"><a href="#4-命名空间" class="headerlink" title="4. 命名空间"></a><font color="red">4. 命名空间</font></h1><p>为了更好组织CSS或者单纯是为了更好的封装，将一些变量或者混合模块打包起来<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#bundle &#123;</span><br><span class="line">  .button () &#123;</span><br><span class="line">    display: block;</span><br><span class="line">    border: 1px solid black;</span><br><span class="line">    background-color: grey;</span><br><span class="line">    &amp;:hover &#123; background-color: white &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  .tab &#123; ... &#125;</span><br><span class="line">  .citation &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#header a &#123;</span><br><span class="line">  color: orange;</span><br><span class="line">  &lt;font color=&quot;red&quot;&gt;#bundle &gt; .button;&lt;/font&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="5-作用域"><a href="#5-作用域" class="headerlink" title="5. 作用域"></a><font color="red">5. 作用域</font></h1><p>less中的作用域跟其他编程语言非常类似，首先会从本地查找变量或者混合模块，如果没找到的话会去父级作用域中查找，直到找到为止<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@var: red;</span><br><span class="line">#page &#123;</span><br><span class="line">  @var: white;</span><br><span class="line">  #header &#123;</span><br><span class="line">    color: @var; // white</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">#footer &#123;</span><br><span class="line">  color: @var; // red  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="6-注释"><a href="#6-注释" class="headerlink" title="6. 注释"></a><font color="red">6. 注释</font></h1><p>CSS形式的注释在less中是依然保留，less同样也支持双斜线的注释, 但是编译成 CSS 的时候<font color="blue">自动过滤掉</font></p><h1 id="7-引用-import"><a href="#7-引用-import" class="headerlink" title="7. 引用@import"></a><font color="red">7. 引用@import</font></h1><ul><li><p>可以在less文件中通过下面的形势引入 .less 文件, .less 后缀可带可不带<br>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@import &quot;lib.less&quot;;</span><br><span class="line">@import &quot;lib&quot;;</span><br></pre></td></tr></table></figure></li><li><p>如果想导入一个CSS文件而且不想less对它进行处理，只需要使用.css后缀就可以，这样less就会跳过它不去处理它</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@import &quot;lib.css&quot;;</span><br></pre></td></tr></table></figure></li></ul><h1 id="8-字符串插值"><a href="#8-字符串插值" class="headerlink" title="8. 字符串插值"></a><font color="red">8. 字符串插值</font></h1><p>即将@后面的变量使用{}括起来，然后整体使用””包裹即可。<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@base-url: &quot;http://assets.fnord.com&quot;;</span><br><span class="line">background-image: url(&quot;@&#123;base-url&#125;/images/bg.png&quot;);</span><br></pre></td></tr></table></figure></p><h1 id="9-避免编译"><a href="#9-避免编译" class="headerlink" title="9. 避免编译~"></a><font color="red">9. 避免编译~</font></h1><p>有时候我们需要输出一些不正确的CSS语法或者使用一些 less不认识的专有语法。<br>要输出这样的值我们可以在字符串前加上一个 ~，并将要避免编译的值用 “”包含起来。<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.class &#123;</span><br><span class="line">  filter: ~&quot;ms:alwaysHasItsOwnSyntax.For.Stuff()&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.class &#123;</span><br><span class="line">  filter: ms:alwaysHasItsOwnSyntax.For.Stuff();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="10-JavaScript-表达式"><a href="#10-JavaScript-表达式" class="headerlink" title="10. JavaScript 表达式"></a><font color="red">10. JavaScript 表达式</font></h1><ul><li><p>JavaScript 表达式也可以在.less 文件中使用，可以通过<font color="red">反引号</font>的方式使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@var: `&quot;hello&quot;.toUpperCase() + &apos;!&apos;`;    //@var: &quot;HELLO!&quot;;</span><br></pre></td></tr></table></figure></li><li><p>也可以访问JavaScript环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@height: `document.body.clientHeight`;</span><br></pre></td></tr></table></figure></li></ul><hr><p><strong>日常啰嗦</strong>：之前理解了那个mixin又忘记了，哭唧唧。现在重拾一下。。不知道为什么有时候的分割线显示不出来。应该是文章中间出现了<code>&lt;font&gt;&lt;/font&gt;</code>标签而没有换行引起的。</p>]]></content>
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>less的使用</title>
      <link href="/2018/07/01/less%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/07/01/less%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>less中文网：<a href="http://www.bootcss.com/p/lesscss/" target="_blank" rel="noopener">http://www.bootcss.com/p/lesscss/</a><a id="more"></a></p><h1 id="1-less的介绍"><a href="#1-less的介绍" class="headerlink" title="1. less的介绍"></a><font color="red">1. less的介绍</font></h1><p>Less 是一种 <font color="blue">动态 样式</font> 语言,一门 <font color="blue">CSS 预处理语言</font>，它扩展了 CSS 语言，增加了变量、Mixin、函数等特性，使 CSS 更易维护和扩展。LESS 既可以在 客户端 上运行 (支持IE 6+, Webkit, Firefox)，也可以借助Node.js或者Rhino在服务端运行。<br>基于javascript，极简。</p><hr><h1 id="2-在浏览器使用方法"><a href="#2-在浏览器使用方法" class="headerlink" title="2. 在浏览器使用方法"></a><font color="red">2. 在浏览器使用方法</font></h1><p>1.下载less.js文件到本地。<br>2.在页面中引入自己的.less文件。<br><img src="/images/less的使用/1.png" alt="less的使用"><br>3.引入下载的less.js文件。<br><img src="/images/less的使用/2.png" alt="less的使用"><br>注意2、3步骤顺序，自己的文件要先引入。</p><hr><h1 id="3-服务器端使用"><a href="#3-服务器端使用" class="headerlink" title="3. 服务器端使用"></a><font color="red">3. 服务器端使用</font></h1><p>1.全局安装less<br>$ npm install -g less<br>2.命令行使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ lessc  test.less &gt; style.css</span><br></pre></td></tr></table></figure></p><p>解析test.less文件为style.css文件<br>3.如何你想将编译后的 CSS 压缩，那么加一个 -x 参数就可以了.</p><hr><p><strong>日常啰嗦</strong>：首次了解到less是在极客学院里的第十一章：掌握CSS在工程中的变化-LESS&amp;SASS(高级进阶)。很强大，将js语法融入css里面。</p>]]></content>
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>sass的使用</title>
      <link href="/2018/07/01/sass%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/07/01/sass%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>sass中文官网：<a href="https://www.sasscss.com/" target="_blank" rel="noopener">https://www.sasscss.com/</a></p><h1 id="1-sass的介绍"><a href="#1-sass的介绍" class="headerlink" title="1. sass的介绍"></a><font color="red">1. sass的介绍</font></h1><p>sass 是 css 的预处理器（css preprocessor）<br>它能够帮我们更快更高效的编写更好维护的css。自带很多原生 css 没有的功能，如变量（现在 css 中已经实现）、条件语句等.<a id="more"></a><br>与less的区别：<br>sass基于nuby&nbsp;&nbsp;有很多扩展  大型项目略胜 开发底层样式(类似bootstrap）<br>less基于javascript 极简&nbsp;&nbsp;用于项目内部</p><hr><h1 id="2-文件后缀"><a href="#2-文件后缀" class="headerlink" title="2. 文件后缀"></a><font color="red">2. 文件后缀</font></h1><p><font color="blue">sass 有两种后缀名文件：</font></p><p><font color="blue">后缀名: .sass</font>不使用大括号和分号<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">body</span><br><span class="line">  background: #eee</span><br><span class="line">  font-size:12px</span><br><span class="line">p</span><br><span class="line">  background: #0982c1</span><br></pre></td></tr></table></figure></p><p><font color="blue">后缀名: .scss</font>和我们平时写的 css 文件格式差不多，使用大括号和分号。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">  background: #eee;</span><br><span class="line">  font-size:12px;</span><br><span class="line">&#125;</span><br><span class="line">p&#123;</span><br><span class="line">  background: #0982c1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>建议使用后缀名为 scss 的文件，以避免 sass 后缀名的严格格式要求报错。</p><hr><h1 id="3-编译"><a href="#3-编译" class="headerlink" title="3. 编译"></a><font color="red">3. 编译</font></h1><p>直接生成在命令行上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sass index.scss</span><br></pre></td></tr></table></figure></p><p>编译到 css 文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sass test.scss test.css</span><br></pre></td></tr></table></figure></p><p>.scss文件的注释没有编译到.css文件里</p><hr><p><strong>日常啰嗦</strong>：因为SASS是 Ruby 语言写的，但是两者的语法没有关系。所以要先安装ruby，之后在ruby的控制面板里输入gem install sass来安装sass。</p>]]></content>
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>元素居中</title>
      <link href="/2018/06/30/%E5%85%83%E7%B4%A0%E5%B1%85%E4%B8%AD/"/>
      <url>/2018/06/30/%E5%85%83%E7%B4%A0%E5%B1%85%E4%B8%AD/</url>
      <content type="html"><![CDATA[<p>演示地址：<a href="https://xieshuangting.github.io/calculate" target="_blank" rel="noopener">https://xieshuangting.github.io/calculate</a><a id="more"></a><br><img src="/images/背景色百分之百填充/1.png" alt="背景色百分之百填充"></p><hr><p><font color="red">1. 水平居中</font></p><p><font color="blue">行内元素</font>: 设置其父元素的text-align:center，</p><p><font color="blue">块级元素</font>:</p><ul><li>定宽：margin:0 auto;</li><li>不定宽：<ul><li>外部块级元素text-align + 内部块级元素inline-block<br><img src="/images/元素居中/1.png" alt="元素居中"></li><li></li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> css </category>
          
          <category> 计算器 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>作用域链</title>
      <link href="/2018/06/29/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/"/>
      <url>/2018/06/29/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>粘性定位position:sticky</title>
      <link href="/2018/06/29/%E7%B2%98%E6%80%A7%E5%9B%BA%E5%AE%9Aposition-sticky/"/>
      <url>/2018/06/29/%E7%B2%98%E6%80%A7%E5%9B%BA%E5%AE%9Aposition-sticky/</url>
      <content type="html"><![CDATA[<p><font color="red">粘性定位</font>是相对定位和固定定位的混合。元素在跨越特定阈值前为相对定位，之后为固定定位。<a id="more"></a></p><p>#one { position: sticky; top: 10px; }<br>在 viewport 视口滚动到元素 top 距离小于 10px 之前，元素为相对定位。之后，元素将固定在与顶部距离 10px 的位置，直到 viewport 视口回滚到阈值以下。<br>使用它，我们不再用监听scroll事件，即可实现导航栏滚动绝对定位的效果。</p><p><font color="red">生效条件</font><br>1.需要注意的是，使用该属性有几个必要条件，否则会失效：<br>2.父元素不能overflow:hidden或者overflow:auto属性。<br>3.必须指定top、bottom、left、right4个值之一，否则只会处于相对定位<br>4.父元素的高度不能低于sticky元素的高度<br>5.sticky元素仅在其父元素内生效</p><p><font color="red">兼容</font><br>position: -webkit-sticky;<br>position: sticky;</p><hr><p><strong>日常啰嗦</strong>：本文转载自这名字真不对<a href="https://www.jianshu.com/p/b72f504121f5" target="_blank" rel="noopener">https://www.jianshu.com/p/b72f504121f5</a><br>这个属性好像以前做什么东西时有看过，但是想不起来是什么了，这垃圾脑子。不过今天在前端面试题里看到这个属性，马上就百度了下。这个属性很强大呀，无奈就是浏览器的支持不好。</p>]]></content>
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>IE6不支持position:fixed问题</title>
      <link href="/2018/06/29/IE6%E4%B8%8D%E6%94%AF%E6%8C%81position-fixed%E9%97%AE%E9%A2%98/"/>
      <url>/2018/06/29/IE6%E4%B8%8D%E6%94%AF%E6%8C%81position-fixed%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<!-- <font color='red'>问题：</font>IE7已经支持position:fixed了，而IE6却不支持，解决这个问题的办法如下：现在有一个元素的id是element，它需要实现fixed效果，我们既想要它在正常的浏览器下使用，也想要它在IE 6下正常工作，那么可以使用CSS hack：复制代码#element {position: fixed;top: 450px; /* 其他浏览器下定位，在这里可设置坐标*/_position: absolute; /*IE6 用absolute模拟fixed*//*IE6 动态设置top位置*/_top: expression(eval(document.documentElement.scrollTop) +  450); }复制代码　　这样就可以实现这个元素距离顶部450像素固定，你还可以添加下面的代码实现去除页面抖动的效果：*html body{background-image:url(about:blank);background-attachment:fixed;}　　在前文中，通过_top设置CSS样式，那么怎么修改expression的样式呢：var domThis=$(this)[0];domThis.style.setExpression('top', 'eval((document.documentElement).scrollTop + ' +  50 + ')');　　通过这种方式，就可以达到修改的目的了。 --><!-- 这个兼容性问题通常是采用JS+绝对定位方式处理使元素固定在浏览器的顶部：#top{_position:absolute;_bottom:auto;_top:expression(eval(document.documentElement.scrollTop));}使元素固定在浏览器的底部：#top{_position:absolute;_bottom:auto;_top:expression(eval(document.documentElement.scrollTop+document.documentElement.clientHeight-this.offsetHeight-(parseInt(this.currentStyle.marginTop,10)||0)-(parseInt(this.currentStyle.marginBottom,10)||0)));}这两段代码只能实现在最底部跟最顶部，你可以使用 _margin-top:10px; 或者 _margin-bottom:10px; 修改其中的数值控制元素的位置。position:fixed; 闪动问题现在，问题还没有完全解决。在用了上面的办法后，你会发现：被固定定位的元素在滚动滚动条的时候会闪动。解决闪动问题的办法是在 CSS 文件中加入：*html{background-image:url(about:blank);background-attachment:fixed; -->]]></content>
      
      <categories>
          
          <category> 兼容性 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>背景色百分之百填充</title>
      <link href="/2018/06/29/%E8%83%8C%E6%99%AF%E8%89%B2%E7%99%BE%E5%88%86%E4%B9%8B%E7%99%BE%E5%A1%AB%E5%85%85/"/>
      <url>/2018/06/29/%E8%83%8C%E6%99%AF%E8%89%B2%E7%99%BE%E5%88%86%E4%B9%8B%E7%99%BE%E5%A1%AB%E5%85%85/</url>
      <content type="html"><![CDATA[<p>演示地址：<a href="https://xieshuangting.github.io/calculate" target="_blank" rel="noopener">https://xieshuangting.github.io/calculate</a><a id="more"></a><br><img src="/images/背景色百分之百填充/1.png" alt="背景色百分之百填充"></p><hr><p><font color="red">关键height：100%</font><br><img src="/images/背景色百分之百填充/2.png" alt="背景色百分之百填充"></p><p><font color="blue">%</font>: 基于包含它的块级对象的百分比高度。<br>100%这个属性值可以理解为一个<font color="blue">计算属性</font>！它是需要有一个<font color="blue">基准值</font>！而这个基准值就是其父级元素的高度值！<br>浏览器一般默认解释为内容的高度，而不是100%。div的100%是从其上一级div的宽高继承来的，有一点很关键，就是要设置div100%显示，必须设置<font color="blue">其上一级div</font>的宽度或高度，否则无效。<br><img src="/images/背景色百分之百填充/3.png" alt="背景色百分之百填充"></p><p><font color="red">注:</font>因为body默认会有8px的margin值！所以会抖动。解决抖动的代码如下：<br>body{<br>    margin: 0;<br>}</p><p><font color="blue"><strong>扩展</strong></font>：另一种实现方法：改变position属性</p><p>#box{<br>    position: absolute;<br>    //position: fixed; //或者利用这样的方法<br>    height: 100%;<br>    width: 100%;<br>    background: red;<br>}<br>这样的写法，省略了个body,html添加属性值。仅仅给#box添加就行！原理是将#box脱离文档流，height的值就可以响应屏幕的高度了！<br>还有就是width:100%记得写上，否则宽度无用</p><hr><p><strong>日常啰嗦</strong>：<font color="blue">部分内容转载自szy1000的专栏<a href="https://blog.csdn.net/u011456552/article/details/75628958" target="_blank" rel="noopener">https://blog.csdn.net/u011456552/article/details/75628958</a></font> &nbsp; 一直以来都知道要设置背景的话要把html和body的height设置为100%，但是不知道为什么，这篇文很好的为我解了惑。</p>]]></content>
      
      <categories>
          
          <category> css </category>
          
          <category> 计算器 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>position</title>
      <link href="/2018/06/29/position/"/>
      <url>/2018/06/29/position/</url>
      <content type="html"><![CDATA[<h1 id="position-属性规定元素的定位类型。"><a href="#position-属性规定元素的定位类型。" class="headerlink" title="position 属性规定元素的定位类型。"></a>position 属性规定元素的定位类型。</h1><p><font color="red">inherit</font>:规定应该从父元素继承 position 属性的值。<a id="more"></a></p><p><font color="red">absolute </font>:元素设置成absolute后会脱离文档流，并且不占有原本的空间，后面的元素会顶替上去，而且不论元素是行内元素还是块级元素，都会生成一个<font color="blue">块级框</font>，也就是例如行内元素span设置了absolute后就可以设置height和width属性了。</p><p><font color="red">fixed </font>:（IE6不支持）生成绝对定位的元素，通常相对于<font color="blue">浏览器窗口或 frame 进行定位。</font></p><p><font color="red">relative</font> :翻译成中文称相对定位，设置了这个属性后，元素会根据top，left，bottom，right进行偏移，关键点是它原本的空间仍然保留。</p><p><font color="red">static </font>:position属性的默认值，默认情况下，块级元素和行内元素按照各自的特性进行显示</p><p><font color="red">sticky</font> :生成粘性定位的元素，容器的位置根据正常文档流计算得出。(详情见<a href="https://xieshuangting.github.io/2018/06/29/粘性固定position-sticky/#more" target="_blank" rel="noopener">https://xieshuangting.github.io/2018/06/29/粘性固定position-sticky/#more</a>)</p><hr><p><strong>日常啰嗦</strong>:这篇文最大的收获就是absolute之后的元素变成了块级元素，可以设置width和height。还有知道了sticky这个属性。</p>]]></content>
      
      <categories>
          
          <category> css </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>grunt</title>
      <link href="/2018/06/29/grunt%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/06/29/grunt%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>grunt中文官网：<a href="http://www.gruntjs.net/" target="_blank" rel="noopener">http://www.gruntjs.net/</a></p><hr><p><font color="red">1. grunt介绍</font><br>一句话：自动化。对于需要反复重复的任务，例如压缩（minification）、编译、单元测试、linting等，自动化工具可以减轻你的劳动，简化你的工作。当你在 Gruntfile 文件正确配置好了任务，任务运行器就会自动帮你或你的小组完成大部分无聊的工作。<br>Grunt执行的每个任务都是各种插件配置的集合，这些配置都是彼此独立，按序执行的。</p><p>安装grunt工作<br>1.在当前目录下配置好package.json—-npm init<br>2.安装grunt—–npm install grunt –save-dev<br>3.创建Gruntfile.Js文件(在里面配置需求的task）</p>]]></content>
      
      <categories>
          
          <category> 自动化构建工具 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>gulp常用插件</title>
      <link href="/2018/06/29/gulp%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/"/>
      <url>/2018/06/29/gulp%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/</url>
      <content type="html"><![CDATA[<p><img src="/images/gulp常用插件/1.jpg" alt="gulp常用插件"><a id="more"></a><br>转化代码是为了兼容性</p><p><font color="blue">gulp-react</font>转换jsx代码</p><p><font color="blue">gulp-babel</font>转换es6代码</p><p><font color="blue">gulp-less</font>转换less代码</p><p><font color="blue">gulp-sass</font>转换sass代码</p><p>插件安装npm install –save-dev gulp-uglify</p><hr><p><font color="red">1. gulp-uglify（JS压缩）</font><br>gulp-uglify用来压缩js文件，使用的是uglify引擎。<br><img src="/images/gulp常用插件/2.png" alt="gulp常用插件"><br>小技巧，第二个参数’！js/*.min.js’是用来过滤掉后缀为min.js，！感叹号为排除模式。</p><hr><p><font color="red">2. gulp-minify-css（CSS压缩）</font><br><img src="/images/gulp常用插件/3.png" alt="gulp常用插件"></p><hr><p><font color="red">3. gulp-minify-html（html压缩）</font><br><img src="/images/gulp常用插件/4.png" alt="gulp常用插件"></p><hr><p><font color="red">4. gulp-concat（文件合并）</font><br>合并CSS与JS文件，减少http请求。<br><img src="/images/gulp常用插件/5.png" alt="gulp常用插件"></p><hr><p><font color="red">5. gulp-less（编译Less）</font><br><img src="/images/gulp常用插件/6.png" alt="gulp常用插件"></p><hr><p><font color="red">6. gulp-sass（编译Sass）</font><br><img src="/images/gulp常用插件/7.png" alt="gulp常用插件"></p><hr><p><strong>日常啰嗦</strong>：文章内容转载自Rin阳<a href="https://www.jianshu.com/p/98db023b5b89" target="_blank" rel="noopener">https://www.jianshu.com/p/98db023b5b89</a> 这些应该是工作中主要用到的插件。</p>]]></content>
      
      <categories>
          
          <category> 自动化构建工具 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>reset.css和normalize.css的区别</title>
      <link href="/2018/06/29/reset-css%E5%92%8Cnormalize-css%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2018/06/29/reset-css%E5%92%8Cnormalize-css%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<p><font color="red">reset.css</font><br>是将所有的浏览器的自带样式重置掉，这样更易于保持各浏览器渲染的一致性<br><img src="/images/reset和normalize的区别/2.png" alt="reset.css和normalize.css的区别"><a id="more"></a></p><p><font color="red">normalize.css</font><br>根据官网的定义： normalize.css是一个现代的，为HTML5准备的reset.css的替代品。它可以使元素的渲染在多个浏览器下都能保持一致并且符合规范。它所瞄准的，也都是些需要<font color="blue">规范化</font>的样式。<br><img src="/images/reset和normalize的区别/1.png" alt="reset.css和normalize.css的区别"></p>]]></content>
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>浏览器兼容性</title>
      <link href="/2018/06/29/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7/"/>
      <url>/2018/06/29/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7/</url>
      <content type="html"><![CDATA[<font color="red">1. 浏览器兼容性？？</font><br>由于市场上浏览器种类众多，而不同浏览器其内核亦不尽相同，所以各个浏览器对网页的解析就有一定出入，这也是导致浏览器兼容问题出现的主要原因，我们的网页需要在主流浏览器上正常运行，就需要做好浏览器兼容。<a id="more"></a><br><font color="blue">四大内核</font><br>使用<font color="blue">Trident</font>内核的浏览器：IE；<br>使用<font color="blue">Gecko</font>内核的浏览器：Netcape6及以上版本、FireFox；<br>使用<font color="blue">Presto</font>内核的浏览器：Opera7及以上版本；<br>使用<font color="blue">Webkit</font>内核的浏览器：Safari、Chrome。<br>而我现在所说的兼容性问题，主要是说IE与几个主流浏览器如firefox，google等。而对IE浏览器来说，IE7又是个跨度，因为之前的版本更新甚慢，bug甚多。从IE8开始，IE浏览器渐渐遵循标准，到IE9后由于大家都一致认为标准很重要，可以说在兼容性上比较好了，但是在中国来说，由于xp的占有率问题，使用IE7以下的用户仍然很多，所以我们不得不考虑低版本浏览器的兼容。<br>对浏览器兼容问题，一般分:<font color="red">HTML，Javascript兼容，CSS兼容</font>。 其中html相关问题比较容易处理，无非是高版本浏览器用了低版本浏览器无法识别的元素，导致其不能解析，所以平时注意一点就是。特别是HTML5增加了许多新标签，低版本浏览器有点影响时代进步啊。<br><br>—-<br><font color="red">2. css兼容性</font><br><font color="blue">问题一：不同浏览器的标签默认的外补丁(margin)和内补丁(padding)不同</font><br>问题症状：随便写几个标签，不加样式控制的情况下，各自的margin和padding差异较大。<br>解决方案：css里 *{margin:0;padding:0;}<br><br><font color="blue">问题二：块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大</font><br>问题症状:常见症状是ie6中后面的一块被顶到下一行<br>解决方案：在float的标签样式控制中加入 display:inline;将其转化为行内属性<br>备注：我们最常用的就是div+css布局了，而div就是一个典型的块属性标签，横向布局的时候我们通常都是用div float实现的，横向的间距设置如果用margin实现，这就是一个必然会碰到的兼容性问题。<br><br><font color="blue">问题三：设置较小高度标签（一般小于10px），在ie6，ie7，遨游中高度超出自己设置高度</font><br>问题症状：ie6、7和遨游里这个标签的高度不受控制，超出自己设置的高度<br>碰到频率：60%<br>解决方案：给超出高度的标签设置overflow:hidden;或者设置行高line-height 小于你设置的高度。<br>备注：这种情况一般出现在我们设置小圆角背景的标签里。出现这个问题的原因是ie8之前的浏览器都会给标签一个最小默认的行高的高度。即使你的标签是空的，这个标签的高度还是会达到默认的行高。<br><br><font color="blue">问题四：行内属性标签，设置display:block后采用float布局，又有横行的margin的情况，ie6间距bug（类似第二种）</font><br>问题症状：ie6里的间距比超过设置的间距<br>碰到几率：20%<br>解决方案：在display:block;后面加入display:inline;display:table;<br>备注：行内属性标签，为了设置宽高，我们需要设置display:block;(除了input标签比较特殊)。在用float布局并有横向的margin后，在ie6下，他就具有了块属性float后的横向margin的bug。不过因为它本身就是行内属性标签，所以我们再加上display:inline的话，它的高宽就不可设了。这时候我们还需要在display:inline后面加入display:talbe。<br><br><font color="blue">问题五：图片默认有间距</font><br>问题症状：几个img标签放在一起的时候，有些浏览器会有默认的间距，加上问题一中提到的通配符也不起作用。<br>碰到几率：20%<br>解决方案：使用float属性为img布局<br>备注：因为img标签是行内属性标签，所以只要不超出容器宽度，img标签都会排在一行里，但是部分浏览器的img标签之间会有个间距。去掉这个间距使用float是正道<br><br><font color="blue">问题六：标签最低高度设置min-height不兼容</font><br>问题症状：因为min-height本身就是一个不兼容的css属性，所以设置min-height时不能很好的被各个浏览器兼容<br>碰到几率：5%<br>解决方案：如果我们要设置一个标签的最小高度200px，需要进行的设置为：{min-height:200px; height:auto !important; height:200px; overflow:visible;}<br>备注：在B/S系统前端开时，有很多情况下我们有这种需求。当内容小于一个值（如300px）时。容器的高度为300px；当内容高度大于这个值时，容器高度被撑高，而不是出现滚动条。这时候我们就会面临这个兼容性问题。<br><br><font color="blue">问题七：透明度的兼容css设置</font><hr><p><strong>日常啰嗦</strong>：当初有人问我关于浏览器兼容性的时候我一脸懵，我确定我之前有接触过，但是就是说不出口。而且也很怀疑自己所知道的是不是符合答案的。所以现在我想把他做一个归纳汇总。</p>]]></content>
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>package.json文件介绍</title>
      <link href="/2018/06/28/package-json%E6%96%87%E4%BB%B6%E4%BB%8B%E7%BB%8D/"/>
      <url>/2018/06/28/package-json%E6%96%87%E4%BB%B6%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<p><font color="red">1. package.json介绍</font><br>package.json在Node项目中用于描述项目的一些基本信息，以及依赖的配置，一般每一个Node项目的根目录下都有一个package.json文件。<a id="more"></a></p><p><font color="blue">package.json文件的创建</font><br>在项目的根目录中我们可以通过$ npm init来初始化一个package.json文件，其内容是一个Json对象。<br>$ npm install 命令根据这个配置文件，自动下载所需的模块，也就是配置项目所需的运行和开发环境。</p><p><font color="blue">为什么要保存配置信息至package.json？</font><br>因为node插件包相对来说非常庞大，所以不加入版本管理，将配置信息写入package.json并将其加入版本管理，其他开发者对应下载即可（命令提示符执行npm install，则会根据package.json下载所有需要的包，npm install –production只下载dependencies节点的包）。</p><p><font color="blue">注：</font>json文件不能添加注释</p><hr><p><font color="red">2. scripts字段</font><br><img src="/images/package.json文件介绍/1.png" alt="package.json文件介绍"><br>scripts指定了运行脚本命令的npm命令行缩写，比如start指定了运行npm run start时，所要执行的命令。<br>以上的设置指定了npm run dev、npm run start、npm run build时，所要执行的命令。</p><hr><p><font color="red">2. dependencies字段，devDependencies字段</font><br><img src="/images/package.json文件介绍/2.png" alt="package.json文件介绍"><br>dependencies字段指定了项目运行所依赖的模块。<br>devDependencies指定项目开发所需要的模块。<br>它们都指向一个对象。该对象的各个成员，分别由模块名和对应的版本要求组成，表示依赖的模块及其版本范围。</p><p><font color="blue">安装模块</font><br>如果一个模块不在package.json文件之中，可以单独安装这个模块，并使用相应的参数，将其写入package.json文件之中。例单独安装express模块：<br>$ npm install express –save　　　　–save参数表示将该模块写入dependencies属性<br>$ npm install express –save-dev　　　　–save-dev表示将该模块写入devDependencies属性</p><hr><p><font color="red">3. browserslist字段</font><br><img src="/images/package.json文件介绍/3.png" alt="package.json文件介绍"><br>browserslist指定该模板供浏览器使用的版本，项目的浏览器兼容情况。Browserify这样的浏览器打包工具，通过它就知道该打包那个文件。</p><hr><p><font color="red">4. engines字段</font><br><img src="/images/package.json文件介绍/4.png" alt="package.json文件介绍"><br>engines字段指明了该模块运行的平台<br>比如 Node 的某个版本或者浏览器，指定适用的npm版本。</p><hr><p><strong>日常啰嗦</strong>：反思：一直以来学的东西太多了，然而每个学的又不深，所以时间一久导致全部都忘记了。感觉写在博客里还是有好处的，有一种成就感，虽然没有访客，但是有一种与时代接轨的感觉。很多感受交杂在一起促使我继续写文（虽然有时是复制粘贴的，但是也比单纯的网上浏览在脑海中留下的印象深很多，有一种把别人的东西变成自己成果的感觉 ？？窃取的快乐？？）。之前是单纯地记在电脑的笔记本上，但是他没有一个很好的目录浏览功能，写完之后也没有成就感，所以写了几篇之后就荒废了。然后就是写在纸质的本子上，记在本子上印象是挺深的，但是还是难以检索，难以分类。而且用手记太费时间了（不像写文可以复制粘贴，可以撤回之类的），毕竟自己太渣，别人写的东西都是自己所不懂的知识点，所以有很多东西要记。手写的工作量太大也导致记录这一工作荒废了。现在开始写博，希望可以坚持下去，或者发现这一弊处的话可以找到更好的方法。</p>]]></content>
      
      <categories>
          
          <category> node </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>gulp的使用</title>
      <link href="/2018/06/27/gulp%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/06/27/gulp%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>gulp中文官网：<a href="https://www.gulpjs.com.cn/" target="_blank" rel="noopener">https://www.gulpjs.com.cn/</a></p><hr><font color="red">1. gulp介绍</font><br>gulp是前端开发过程中对代码进行构建的工具，是自动化项目的构建利器；她不仅能对网站资源进行优化，而且在开发过程中很多重复的任务能够使用正确的工具自动完成。<a id="more"></a><br><br>gulp是<font color="blue">基于Nodejs</font>的自动任务运行器， 她能自动化地完成 javascript/coffee/sass/less/html/image/css 等文件的的测试、检查、合并、压缩、格式化、浏览器自动刷新、部署文件生成，并<font color="blue">监听</font>文件在改动后重复指定的这些步骤。在实现上，她借鉴了Unix操作系统的<font color="blue">管道</font>（pipe）思想，前一级的输出，直接变成后一级的输入，使得在操作上非常简单。<br><br>gulp 和 grunt 非常类似，但相比于 grunt 的频繁 IO 操作，gulp 的<font color="blue">流操作</font>，能更快地更便捷地完成构建工作。<br><br>——–<br><font color="red">2. gulp的使用步骤</font><br>首先当然是安装nodejs，通过nodejs的npm全局安装和项目安装gulp（$ npm install gulp -g），其次在项目里安装所需要的gulp插件（$ npm install gulp –save-dev,$ npm install gulp-less –save-dev），然后新建gulp的配置文件gulpfile.js并写好配置信息（定义gulp任务），最后通过命令提示符运行gulp任务即可。<br><font color="blue">安装nodejs -&gt; 全局安装gulp -&gt; 项目安装gulp以及gulp插件 -&gt; 配置gulpfile.js -&gt; 运行任务</font><p>细心的你可能会发现，我们全局安装了gulp，项目也安装了gulp，全局安装gulp是为了执行gulp任务，本地安装gulp则是为了调用gulp插件的功能。</p><hr><p><font color="red">3. 新建gulpfile.js文件</font></p><p><font color="blue">说明</font>：gulpfile.js是gulp项目的配置文件，是位于项目根目录的普通js文件（其实将gulpfile.js放入其他文件夹下亦可）。<br><img src="/images/gulp的使用/1.png" alt="gulp的使用"></p><hr><p><font color="red">4. 运行gulp</font><br>$ gulp 任务名称<br>例如编译less：$ gulp testLess（任务名称）<br>当执行$ gulp default或$ gulp 将会调用default任务里的所有任务[‘testLess’,’elseTask’]。</p><hr><p><strong>日常啰嗦</strong>：在极客学院的培训课上有一章节叫做‘任务10 掌握前端工业化框架(高级进阶)’，里面介绍了grunt，gulp，bower，yeoman，FIS,FIS3这些打包工具，还是当时学的时候有点懂，久了就忘记了，还是需要把有必要的工具总结下，以便得到巩固。</p>]]></content>
      
      <categories>
          
          <category> 自动化构建工具 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>webpack</title>
      <link href="/2018/06/27/webpack/"/>
      <url>/2018/06/27/webpack/</url>
      <content type="html"><![CDATA[<p>Webpack是一个前端资源加载/打包工具。它将根据<font color="red">模块的依赖关系</font>进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源。<br><a id="more"></a><br>它主要的用途是通过<font color="red">CommonJS</font>的语法把所有浏览器端需要发布的静态资源做相应的准备，比如<font color="red">资源的合并和打包</font>。<br>Webpack 可以将多种静态资源 js、css、less 转换成一个静态文件，减少了页面的请求。会给每个模块分配一个唯一的 id 并通过这个 id 索引和访问模块。 </p><p>WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其转换和打包为合适的格式供浏览器使用。 </p><p><font color="red">WebPack和Grunt以及Gulp相比有什么特性 </font><br>其实Webpack和另外两个并没有太多的可比性<br>Gulp/Grunt是一种能够优化前端的开发流程的工具<br>而WebPack是一种模块化的解决方案，不过Webpack的优点使得Webpack在很多场景下可以替代Gulp/Grunt类的工具。 </p><p>Grunt和Gulp的工作方式是：在一个配置文件中，指明对某些文件进行类似编译，组合，压缩等任务的具体步骤，工具之后可以自动替你完成这些任务。</p><hr><p><strong>日常啰嗦</strong>：学了很多打包工具的皮毛，然后又很理直气壮地全部忘光了，导致一个都不熟。整理一下，希望有个大致的印象对各个工具的功能。<br>这是在vue项目里面使用的打包工具，执行vue run build就会生成dist文件</p>]]></content>
      
      <categories>
          
          <category> 打包工具 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>vue-cli 搭建项目</title>
      <link href="/2018/06/27/vue-cli%20%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/"/>
      <url>/2018/06/27/vue-cli%20%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/</url>
      <content type="html"><![CDATA[<font color="#42b983">1. 创建一个基于 webpack 模板的新项目</font><br>$ vue init webpack 目录名<br><img src="/images/vue-cli 搭建项目/2.png" alt="vue-cli 搭建项目"><a id="more"></a><br>配置的模板，一般使用standards，高阶选手使用最后一个，什么都没有，需要自己配置。<br>eslint是一个代码语法规范检查的工具，不同意就不会把检查语法规范的功能加进webpack编译的流程里。<br>unit tests单元测试，一般不加，因为不会。<br><br>——–<br><font color="#42b983">2. 安装依赖(进入项目文件夹)</font><br>$ npm install<br><br>—-<br><font color="#42b983">3. 开始运行项目（开发模式）</font><br>$ npm run dev<br>默认运行端口8080<br><br>—–<br><font color="#42b983">4. 打包代码</font><br>$ npm run build<br>该命令可以打包你的代码的，不会报任何异常或错误，但是你会看到你的命令行打包完成有这样一句提示：<br><img src="/images/vue-cli 搭建项目/5.png" alt="vue-cli 搭建项目"><br>用浏览器打开了你刚build生成的dist目录下的index.html文件！<br>然而，你惊奇地发现网页一片空白，丝毫没有一点点痕迹。<br>打开了控制台，看到console下一片404的各种找不到资源。<br><img src="/images/vue-cli 搭建项目/6.png" alt="vue-cli 搭建项目"><br>为什么会这样呢？还得从第一幅图的build后的提示说起，提示的中文翻译是（提示：构建文件务必放在一个HTTP服务器。直接打开index.html文件将不工作）<br>所以你看到控制台里的一堆404！<br><font color="red">解决方案</font><br>仔细看一下路径，绝对路径，c盘下哪有static文件夹，那就要将打包的路径改为<font color="red">相对路径</font>。这个根据build命令一路跟踪，到项目目录下的config文件夹里的index.js文件中的build对象，将<font color="red">assetsPublicPath</font>中的“/”，改为“<font color="red">./</font>”即可，就在前面加个点就可以了，并在build\build.js将这两句的提示信息删掉或注释掉，再打包直接用浏览器直接运行就好了。<br><img src="/images/vue-cli 搭建项目/7.png" alt="vue-cli 搭建项目"><br><font color="red">*注：项目上线时，只需要将 dist 文件夹放到服务器就行了。</font><hr><p><strong>日常啰嗦</strong>：后面一部分vue run build转载自小小猫钓小小鱼<a href="https://www.cnblogs.com/h2zZhou/p/7614599.html。觉得他写的挺好的，把我的疑惑解决了一部分，开来写文还是有很大好处的，理清了我的思路。不过我还是有一个很大的疑惑，为什么我" target="_blank" rel="noopener">https://www.cnblogs.com/h2zZhou/p/7614599.html。觉得他写的挺好的，把我的疑惑解决了一部分，开来写文还是有很大好处的，理清了我的思路。不过我还是有一个很大的疑惑，为什么我</a><font color="red">在服务器设置访问路径为根目录（例如xx.xx.xx.xx/）vue项目就可以运行，设置访问路径为二级目录就访问不了（例如xx.xx.xx.xx/goodsmall），已经更改了assetsPublicPath路径</font>。希望我以后可以来填坑。</p>]]></content>
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>vue目录结构</title>
      <link href="/2018/06/27/vue%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/"/>
      <url>/2018/06/27/vue%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<ol><li>主目录结构<br><img src="/images/vue目录结构/1.png" alt="vue目录结构"><a id="more"></a></li></ol><p><font color="red">build:</font>    项目构建(webpack)相关代码<br><img src="/images/vue目录结构/3.png" alt="vue目录结构"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="blue">build.js:</font>生产环境构建脚本<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="blue">utils.js:</font>构建相关工具方法<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="blue">webpack.base.conf.js:</font>wabpack基础配置<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="blue">webpack.dev.conf.js:</font>wabpack开发环境配置<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="blue">webpack.prod.conf.js:</font>wabpack生产环境配置</p><p><font color="red">config:</font> 配置目录，包括端口号等.可以使用默认的。<br><img src="/images/vue目录结构/4.png" alt="vue目录结构"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="blue">dev.env.js:</font>开发环境变量<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="blue">index.js:</font>项目配置文件<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="blue">prod.env.js:</font>生产环境变量</p><p><font color="red">node_modules:</font> npm 加载的项目依赖模块</p><p><font color="red">src:</font> 这里是我们要开发的目录，基本上要做的事情都在这个目录里。里面包含了几个目录及文件：<br><img src="/images/vue目录结构/2.png" alt="vue目录结构"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="blue">assets:</font>资源目录，放置一些图片，如logo等。这里的资源会被wabpack构建<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="blue">components:</font> 公共组件目录。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="blue">routes:</font>前端路由。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="blue">App.vue:</font> 根组件，项目入口文件，我们也可以直接将组件写这里，而不使用 components 目录。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="blue">main.js:</font> 入口js文件。</p><p><font color="red">static:</font> 静态资源目录，如图片、字体等。不会被wabpack构建</p><p><font color="red">.xxxx文件:</font>    这些是一些配置文件，包括语法配置，git配置等。</p><p><font color="red">index.html:</font> 首页入口文件，你可以添加一些 meta 信息或统计代码啥的。</p><p><font color="red">package.json:</font> 项目配置文件</p><p><font color="red">README.md:</font>    项目的说明文档，markdown格式</p><hr><p><strong>日常啰嗦</strong>：这个也是在网上多家比较总结出来。恩从基础打起。进一步了解了webpack构建。</p>]]></content>
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>github删除本地.git</title>
      <link href="/2018/06/27/github%E5%88%A0%E9%99%A4%E6%9C%AC%E5%9C%B0-git/"/>
      <url>/2018/06/27/github%E5%88%A0%E9%99%A4%E6%9C%AC%E5%9C%B0-git/</url>
      <content type="html"><![CDATA[<font color="red">文件夹和文件一起删除</font><p>$ rd /s /q 文件夹名<br>如：$ rd /s /q .git 这样就将本地文件由git仓库变成普通文件</p><a id="more"></a><hr><p><font color="red"><strong>扩展</strong></font>dos命令删除文件夹和文件</p><ol><li>删除文件夹<br>$ rd 文件夹名。这种删除方法必须要该文件夹是空文件夹，不然删除不了。</li><li>删除文件<br>$ del 文件名。该命令只能删除文件，不能删除文件夹。</li></ol><p><font color="red"><strong>扩展</strong></font><br>del–delete删除文件。<br>rd–remove directionary删除目录。</p><p><font color="red"><strong>扩展</strong></font><br>/s 表示删除该目录下所有遍历的子目录和文件<br>/q 删除目录时不提示确认，直接删除</p><hr><p><strong>日常啰嗦</strong>：用一次百度一次也是够了，这次就一次性把相关的内容都百度出来了，希望可以记得更牢靠。</p>]]></content>
      
      <categories>
          
          <category> github </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>hexo删除文章</title>
      <link href="/2018/06/27/hexo%E5%88%A0%E9%99%A4%E6%96%87%E7%AB%A0/"/>
      <url>/2018/06/27/hexo%E5%88%A0%E9%99%A4%E6%96%87%E7%AB%A0/</url>
      <content type="html"><![CDATA[<p>先删除本地文件，然后通过生成（hexo g）和部署（hexo d）命令进而将远程仓库中的文件也一并删除。<br><a id="more"></a><br>具体来说，以最开始默认形成的helloworld.md这篇文章为例。<br>首先进入到source / _post 文件夹中，找到helloworld.md文件，在本地直接执行删除。然后依次执行hexo g，hexo d，再去主页查看你就会发现你的博客上面已经空空如也了，这就是如何删除文章的方法。</p><p><strong>日常啰嗦</strong>：是不是很简单，get√</p>]]></content>
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>hexo目录结构</title>
      <link href="/2018/06/27/hexo%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/"/>
      <url>/2018/06/27/hexo%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<ol><li>主目录结构<br><img src="/images/hexo目录结构/1.png" alt="hexo目录结构"><a id="more"></a></li></ol><p><font color="#ec6149">public：</font>生成的网站文件，发布的站点文件。</p><p><font color="#ec6149">scaffolds：</font>scaffolds是“脚手架、骨架”的意思，当你新建一篇文章(hexo new ‘title’)的时候，hexo是根据这个目录下的文件进行构建的。</p><p><font color="#ec6149">source：</font>这个目录很重要，新建的文章都是在保存在这个目录下的。</p><p><font color="#ec6149">themes：</font>网站主题目录，hexo有非常好的主题拓展，支持的主题也很丰富。该目录下，每一个子目录就是一个主题。</p><p><font color="#ec6149">_config.yml：</font>全局配置文件，网站的很多信息都在这里配置，诸如网站名称，副标题，描述，作者，语言，主题，部署等等参数。</p><p><font color="#ec6149">package.json：</font>hexo框架的参数和所依赖插件。</p><hr><ol start="2"><li>source目录结构<br><img src="/images/hexo目录结构/2.png" alt="hexo目录结构"></li></ol><p><font color="#ec6149">_posts：</font>需要新建的博文都放在 _posts目录下。 _posts目录下是一个个 markdown 文件。md文件会被编译成html文件，放到public文件夹下。<br><img src="/images/hexo目录结构/3.png" alt="hexo目录结构"></p><p><font color="#ec6149">tag：</font>标签文件夹。</p><p><font color="#ec6149">category：</font>分类文件夹。</p><p><strong>日常啰嗦</strong>：本文是在网上多家比较复制粘贴过来的。</p>]]></content>
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>hexo写文命令</title>
      <link href="/2018/06/27/hexo%E5%86%99%E6%96%87%E5%91%BD%E4%BB%A4/"/>
      <url>/2018/06/27/hexo%E5%86%99%E6%96%87%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<p>每次部署的步骤，可按以下三步来进行。<br>$ hexo clean<br>$ hexo generate<br>$ hexo deploy<br><a id="more"></a></p><hr><p><font color="red">1. new 新建文章的指令</font><br>$ hexo new [layout] &lt;title><br>如果title包含空格的话，请使用引号括起来。<br>layout为可选项，默认使用_config.yml中的default_layout。<br><img src="/images/hexo写文命令/1.png" alt="hexo写文命令"></p><hr><p><font color="red">2. generate 生成静态页面至public目录</font><br>$ hexo generate<br>可选参数：<br>-d ,–deploy 文件生成后立即部署网站<br>-w , –watch 监视文件变动<br>该指令可以简写为hexo g</p><hr><p><font color="red">3. deploy发布到网站，将.deploy_git目录部署到GitHub</font><br>$ hexo deploy<br>这里就是发布到_config.yml中deploy中设置的网址上。<br>参数<br>-g , –generate 部署前生成静态文件<br>该命令可以简写hexo d</p><hr><p><font color="red">4. publish发表草稿</font><br>$ hexo publish [layout] <filename></filename></p><hr><p><font color="red">5. server启动服务器</font><br>$ hexo server<br>默认情况下，访问网址为：<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a></p><p>选项    描述<br>-p, –port    重设端口<br>-s, –static    只使用静态文件<br>-l, –log    启动日记记录，使用覆盖记录格式</p><hr><p><font color="red">6. clean清除缓存文件 (db.json) 和已生成的静态文件 (public)</font><br>$ hexo clean<br>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p><hr><p><strong>日常啰嗦</strong>：我这猪脑子就应该吧这些东西都记一遍，这才能把他变成自己的，俗话说得好：好记性不如烂手指头。</p>]]></content>
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>hexo写文必备常识</title>
      <link href="/2018/06/27/hexo%E5%86%99%E6%96%87%E5%BF%85%E5%A4%87%E5%B8%B8%E8%AF%86/"/>
      <url>/2018/06/27/hexo%E5%86%99%E6%96%87%E5%BF%85%E5%A4%87%E5%B8%B8%E8%AF%86/</url>
      <content type="html"><![CDATA[<ol><li>修改文章的字体和颜色</li></ol><p><font color="red">我是红色哟</font><br><img src="/images/hexo写文必备常识/1.jpg" alt="hexo写文必备常识"></p><a id="more"></a><hr><ol start="2"><li>在首页上出现‘阅读全文’按钮</li></ol><p><img src="/images/hexo写文必备常识/2.png" alt="hexo写文必备常识"></p><hr><ol start="3"><li>在文章内引入图片</li></ol><p>在source目录下新建一个存放图片的文件夹images（自定义）<br>将图片存放在images里面，引用时图片路径为/images/XXX.jpg</p><p>我是将每一篇文章的图片都区分开，存放在不同的目录下，所以图片引用路径为<br><img src="/images/hexo写文必备常识/3.jpg" alt="hexo写文必备常识"></p><hr><ol start="4"><li>Front-matter的冒号后面应添加一个空白格</li></ol><p>Front-matter 是文件最上方以 — 分隔的区域，用于指定个别文件的变量<br><img src="/images/hexo写文必备常识/5.png" alt="hexo写文必备常识"></p><p>若是冒号后面没有添加空白格，则会显示如下错误：<br><img src="/images/hexo写文必备常识/4.png" alt="hexo写文必备常识"></p><hr><ol start="5"><li>在文章内添加空格</li></ol><p>a. 在中文输入法下使用全角：shift＋空格键切换至全角模式，之后再按空格键，那么空格键就会生效。<br><img src="/images/hexo写文必备常识/6.png" alt="hexo写文必备常识"></p><hr><p><strong>日常啰嗦</strong>：每次写文都有点底气不足，野心很大，奈何技术上跟不上，或者是上次学了用了的命令这次又忘光，上网百度又费时间。所以现在就准备把一些常用的写文必备命令写下来，我看你这样还忘不忘，就算忘了我也不怕，现在我有宝典在手哈哈。</p>]]></content>
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>hexo开博小坑</title>
      <link href="/2018/06/27/hexo%E5%BC%80%E5%8D%9A%E5%B0%8F%E5%9D%91/"/>
      <url>/2018/06/27/hexo%E5%BC%80%E5%8D%9A%E5%B0%8F%E5%9D%91/</url>
      <content type="html"><![CDATA[<ol><li>在本地安装完hexo，设置_config.yml之后，将hexo同步到github时，一直报错，报错信息如下：<br><img src="/images/hexo安装小坑/hexo安装小坑1.png" alt="hexo安装小坑"><a id="more"></a>百度了好久为什么会这样，后来发现是自己眼瞎，百度出来的文章明明写着<br><img src="/images/hexo安装小坑/hexo安装小坑3.jpg" alt="hexo安装小坑"><br>所以配置的_config.yml文件应该是<br><img src="/images/hexo安装小坑/hexo安装小坑2.png" alt="hexo安装小坑"></li></ol><p><font color="red"><strong>扩展</strong>：</font>至于为什么需要在冒号后加空白符呢？这是因为yaml文件的语法的规定<br>每个冒号后面一定要有一个空格（以冒号结尾不需要空格，表示文件路径的模版可以不需要空格），这里指的是键值对，例如：mykey: my_value</p><hr><p>2.创建仓库时需要注意的地方:仓库名字一定要是 你的账户名字.github.io<br>不知道为什么账号名字不能为大写（所以为了开博，我废弃了之前的XIEshuangTING账号）（以后再来填坑）</p><hr><p><strong>日常啰嗦</strong>：为了顺应潮流，想开博的心思已经不能再耽搁了。本来想在阿里云服务器上搭建博客的，奈何自己不太懂服务器的知识（怪自己上课没认真听讲，不过我觉得学校讲的知识应该也是不足以支撑实践的，不要拆穿我，这是给自己的安慰=.=），捣鼓了几天，还是没捣鼓出来，我这暴脾气一下子就上来了，我一定要征服你。所以又捣鼓了几天，果然理想和现实是有差距的，这差距真特么地烦人，所以我就华丽丽地放弃了哈哈。那这样不行我们就下降标准吧，所以就有了这个hexo+github的博客。</p>]]></content>
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>vue2.0+node.js+MongoDB全栈打造商城</title>
      <link href="/2018/06/24/vue2-0-node-js-MongoDB%E5%85%A8%E6%A0%88%E6%89%93%E9%80%A0%E5%95%86%E5%9F%8E/"/>
      <url>/2018/06/24/vue2-0-node-js-MongoDB%E5%85%A8%E6%A0%88%E6%89%93%E9%80%A0%E5%95%86%E5%9F%8E/</url>
      <content type="html"><![CDATA[<p>github地址：</p>]]></content>
      
      <categories>
          
          <category> vue2.0+node.js+MongoDB全栈打造商城 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>记github的使用</title>
      <link href="/2018/06/12/%E8%AE%B0github%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/06/12/%E8%AE%B0github%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h1 id="git-的配置信息"><a href="#git-的配置信息" class="headerlink" title="git 的配置信息"></a>git 的配置信息</h1><p>获取并设置存储库或全局选项 git config </p><p>config 配置三个级别：<br>system级别 global（用户级别） 和local（当前仓库）<br>local&gt;global&gt;system </p><a id="more"></a><p>想了解 Git 的各式工具该怎么用，可以阅读它们的使用帮助，方法有三：<br>git XXX –help / git help XXX / man git-XXX<br>例如：git config –help</p><p><strong>git配置的增删改查</strong><br>增：git config –global user.name XXX<br>git config –global <strong>–add</strong> user.name XXX<br>改：git config –global user.mane XXX2<br>删：git config –global <strong>–unset</strong> user.name<br>查：git config <strong>–get</strong> user.name<br>git config user.name</p><p>检查已有的配置信息git config –global –list </p><p><strong>为git子命令配置别名</strong>：git config –global alias.co cheskout</p><h1 id="git-的基本工作流程"><a href="#git-的基本工作流程" class="headerlink" title="git 的基本工作流程"></a>git 的基本工作流程</h1><p>git使用40个16进制字符的HASH来唯一标识对象</p><p><strong>对象分为4种</strong><br>blob:用来存储文件内容， 或者说表示一个文件。例如：文本文件，二进制文件，链接文件<br>tree:目录<br>commit:历史提交<br>tag:标签，commit的别名。指向固定的历史提交<br>关系：tag-&gt;commit-&gt;tree(可包含其他的tree对象)-&gt;blob<br>git只关心文件的内容，若两份文件的内容相同，则会指向同一个blob对象，文件名或者其他信息会存储在tree对象里</p><p><strong>创建仓库</strong><br><strong>git仓库分两种：</strong><br>一种为裸仓库，不带工作区，通常用于服务器中和其他用户方便协作（没有.git的目录）<br>$ git init –bare XXX<br>一种是本地仓库，会自动创建.git目录<br>$ git init 仓库名字<br>已经有的环境把他纳入git的管理 进入这个文件夹，在这里执行git init命令<br>获得git仓库 需要一个远程仓库的地址<br>$ git clone &lt;版本库的网址&gt;<br>该命令会在本地主机生成一个目录，与远程主机的版本库同名。如果要指定不同的目录名，可以将目录名作为git clone命令的第二个参数。<br>$ git clone &lt;版本库的网址&gt; &lt;本地目录名&gt;</p><p><strong>git仓库有3个工作区域 </strong><br>工作区–日常编辑代码的地方，维护着树形结构<br>暂存区–需要提交的工作状态，维护着虚拟的树型结构，代表了下一次提交内容的整体<br>历史仓库–commit指向的树形结构</p><p><strong>添加操作</strong><br>$ git add <em>path</em> 将修改添加到暂存区,也就是将要提交的文件的信息添加到索引库中。<em>path</em>可以是文件也可以是目录。<br>$ git add . 或者 $ git add -A 将所有修改添加到暂存区<br>$ git states 查看工作区和暂存区的区别</p><p><strong>删除操作</strong><br>$ git rm a 同时把工作区和暂存区里面的a引用删掉<br>$ git rm –cached a 只删除暂存区里的文件</p><p>未被Git跟踪的状态为<em>unstage</em>状态（存放在暂存区的文件）<br>已经被Git跟踪的状态为<em>stage</em>状态，因此包括<em>staging</em>状态状态和<em>staged</em>状态<br><em>untrack files</em>是指尚未被git所管理的文件；<br><em>changed but not updated</em>是指文件被git管理，并且发生了改变，但改动还没被git管理；<br>这两种状态，都可以看成是改动还没被git管理的状态，我们这里称非stage状态。<br><em>changes to be commited</em>是指进入stage状态的文件，stage是commit和未管理之间的一个状态，也有别名叫index状态，也就是git已经管理了这些改动，但是还没完成提交。<br>.gitignore中的文件，不会出现在以上三个状态中。</p><p><strong>撤销操作</strong><br>$ git checkout file 命令用于切换分支或恢复工作树文件<br>$ git reset HEAD file  回退文件，将文件从暂存区回退到工作区<br>$ git reset HEAD^ ：回退版本，一个^表示一个版本，可以多个，另外也可以使用$ git reset HEAD～n这种形式</p><p><strong>移动操作</strong><br>$ git mv oldname newnae 工作区中重命名文件，移动文件<br>git实际上并没有重命名移动的说法，是一系列操作的组合<br>在工作区中，把你需要的文件重命名和移动，在暂存区里把原有的文件删除了，在把新的文件添加进暂存区</p><p><strong>.gitignore文件</strong><br>*.[oa] 匹配以o或者a结尾的文件<br>*~ 匹配有~的文件<br>*.pyc 匹配所有以pyc为扩展名的文件<br>!test.pyc test.pyc文件不被忽略<br>\!test.pyc 若原来文件名是以！开头的需要转义符号<br>foo/ 匹配foo文件夹（foo文件不被匹配）<br>**/res **/意味着匹配0个或者多个目录，顶层文件的res会被匹配到，其他目录下的子目录的res也会被匹配到</p><p>在工作区的顶层目录下或者你需要的位置下创建.gitignore文件<br>工作区里面一些不希望被添加到暂存区和历史上的文件不被添加进去</p><p><strong>添加到历史仓库</strong><br>git commit -m “xxx”</p>]]></content>
      
      <categories>
          
          <category> github </category>
          
      </categories>
      
      
    </entry>
    
  
  
</search>
