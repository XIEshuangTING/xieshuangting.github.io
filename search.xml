<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>http协议原理+实践 笔记</title>
      <link href="/2019/05/27/http%E5%8D%8F%E8%AE%AE%E5%8E%9F%E7%90%86+%E5%AE%9E%E8%B7%B5%20%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/05/27/http%E5%8D%8F%E8%AE%AE%E5%8E%9F%E7%90%86+%E5%AE%9E%E8%B7%B5%20%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>本文是在观看了慕课网的《http协议原理+实践》之后笔记。<br>by 2019.02.20<a id="more"></a><br>发现有个更全更详细的笔记：<a href="https://so.csdn.net/so/search/s.do?q=http&amp;t=blog&amp;u=zhanghuali0210" target="_blank" rel="noopener">https://so.csdn.net/so/search/s.do?q=http&amp;t=blog&amp;u=zhanghuali0210</a></p><h3 id="一．课程导学"><a href="#一．课程导学" class="headerlink" title="一．课程导学"></a>一．课程导学</h3><p><img src="/images/http协议原理+实践 笔记/52.png"></p><h3 id="二．HTTP协议基础及发展历史"><a href="#二．HTTP协议基础及发展历史" class="headerlink" title="二．HTTP协议基础及发展历史"></a>二．HTTP协议基础及发展历史</h3><h4 id="2-1-5层网络模型介绍"><a href="#2-1-5层网络模型介绍" class="headerlink" title="2.1 5层网络模型介绍"></a>2.1 5层网络模型介绍</h4><p><img src="/images/http协议原理+实践 笔记/1.png" width="80%"><br><img src="/images/http协议原理+实践 笔记/2.png" width="50%"><br><img src="/images/http协议原理+实践 笔记/3.png" width="50%"><br><img src="/images/http协议原理+实践 笔记/4.png" width="40%"></p><h4 id="2-2-HTTP协议的发展历史"><a href="#2-2-HTTP协议的发展历史" class="headerlink" title="2.2 HTTP协议的发展历史"></a>2.2 HTTP协议的发展历史</h4><p><img src="/images/http协议原理+实践 笔记/50.png"><br><img src="/images/http协议原理+实践 笔记/5.png" width="50%"><br><img src="/images/http协议原理+实践 笔记/6.png" width="50%"><br><img src="/images/http协议原理+实践 笔记/7.png" width="50%"><br>参考：<a href="https://www.cnblogs.com/chengdabelief/p/6686603.html" target="_blank" rel="noopener">https://www.cnblogs.com/chengdabelief/p/6686603.html</a><br><img src="/images/http协议原理+实践 笔记/51.png"><br><img src="/images/http协议原理+实践 笔记/8.png" width="50%"></p><h4 id="2-3-HTTP的三次握手"><a href="#2-3-HTTP的三次握手" class="headerlink" title="2.3 HTTP的三次握手"></a>2.3 HTTP的三次握手</h4><p><img src="/images/http协议原理+实践 笔记/9.png" width="80%"><br>第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。<br>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（seq=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；<br>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。<br>完成三次握手，客户端与服务器开始传送数据。<br>三次握手是为了防止服务端开启一些无用的连接，可以及时的察觉到因为网络的原因导致端口关闭<br><img src="/images/http协议原理+实践 笔记/10.png"></p><h4 id="2-4-URI-URL和URN"><a href="#2-4-URI-URL和URN" class="headerlink" title="2.4 URI-URL和URN"></a>2.4 URI-URL和URN</h4><p><img src="/images/http协议原理+实践 笔记/11.png" width="50%"><br><img src="/images/http协议原理+实践 笔记/12.png" width="60%"><br><img src="/images/http协议原理+实践 笔记/13.png" width="40%"></p><h4 id="2-5-HTTP报文格式"><a href="#2-5-HTTP报文格式" class="headerlink" title="2.5 HTTP报文格式"></a>2.5 HTTP报文格式</h4><p><img src="/images/http协议原理+实践 笔记/14.png" width="40%"><br><img src="/images/http协议原理+实践 笔记/15.png" width="40%"></p><h4 id="2-6-创建一个最简单的web服务"><a href="#2-6-创建一个最简单的web服务" class="headerlink" title="2.6 创建一个最简单的web服务"></a>2.6 创建一个最简单的web服务</h4><p><img src="/images/http协议原理+实践 笔记/16.png"></p><h3 id="三．HTTP各种特性总览"><a href="#三．HTTP各种特性总览" class="headerlink" title="三．HTTP各种特性总览"></a>三．HTTP各种特性总览</h3><h4 id="3-1-认识HTTP客户端"><a href="#3-1-认识HTTP客户端" class="headerlink" title="3.1 认识HTTP客户端"></a>3.1 认识HTTP客户端</h4><p><img src="/images/http协议原理+实践 笔记/17.png"><br><img src="/images/http协议原理+实践 笔记/18.png"></p><h4 id="3-2-CORS跨域请求的限制与解决"><a href="#3-2-CORS跨域请求的限制与解决" class="headerlink" title="3.2 CORS跨域请求的限制与解决"></a>3.2 CORS跨域请求的限制与解决</h4><p>跨域资源共享Cross-origin resource sharing<br><img src="/images/http协议原理+实践 笔记/19.png"><br><img src="/images/http协议原理+实践 笔记/20.png"><br><img src="/images/http协议原理+实践 笔记/21.png"></p><h4 id="3-3-CORS跨域限制以及预请求验证"><a href="#3-3-CORS跨域限制以及预请求验证" class="headerlink" title="3.3 CORS跨域限制以及预请求验证"></a>3.3 CORS跨域限制以及预请求验证</h4><p><img src="/images/http协议原理+实践 笔记/23.png" width="50%"><br>在跨域的时候允许的请求只有get，head，post，因为只有这三种方法不用预请求<br>若要在这3种方法之外的方法请求，则要加上<code>&#39;Access-Control-Allow-Methods&#39;:&#39;PUT&#39;</code><br>默认允许的<code>Content-Type：text/plain、multipart/form-data、applicaton/x-www-form-urlencoded</code></p><p><code>&#39;Access-Control-Allow-Headers&#39;:&#39;X-Test-Cors&#39;</code>:<br>跨域资源共享标准规范要求，对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是 GET 以外的 HTTP 请求，或者搭配某些 MIME 类型的 POST 请求），浏览器必须首先使用 OPTIONS 方法发起一个预检请求（preflight request），从而获知服务端是否允许该跨域请求。服务器确认允许之后，才发起实际的 HTTP 请求。在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证（包括 Cookies 和 HTTP 认证相关数据）。<br>预请求的Request Method是OPTIONS。通过OPTIONS请求获得服务端的允许，然后再实际的发送post请求。<br><img src="/images/http协议原理+实践 笔记/24.png"></p><h4 id="3-4-缓存头Cache-Control的含义和使用"><a href="#3-4-缓存头Cache-Control的含义和使用" class="headerlink" title="3.4 缓存头Cache-Control的含义和使用"></a>3.4 缓存头Cache-Control的含义和使用</h4><p><img src="/images/http协议原理+实践 笔记/25.png" width="50%"><br><code>Public</code>：指示响应可以被任何缓存所缓存。例如：html返回的经过的所有路径都会缓存该html<br><code>Private</code>：指示响应信息的全部或部分用于单个用户，而不能用一个共享缓存来缓存。这可以让源服务器指示，响应的特定部分只用于一个用户，而对其他用户的请求则是一个不可靠的响应。一个 private（非共享）缓存可以缓存这样的响应。例如：只有发起请求的浏览器才可以进行缓存<br><code>no-cache</code>：如果 no-cache 指令没有规定 field-name，那么一个缓存不能使用响应以满足接下来的、没有与源服务器重新验证的请求。这可以让源服务器防止缓存，甚至是已被配置的缓存，返回给客户端陈旧的响应。要经过服务器端的验证才可以使用缓存<br><code>no-store</code>:如果是在一个请求中发送，那么缓存不能存储这个请求或任何响应的任何部分给它。如果在一个响应中发送，那么缓存不能存储它引起的响应或请求的任何部分.不管什么时候都不可以经行缓存</p><p>缓存的到期时间<br>在代理服务器中s-maxage会代替max-age，浏览器还是按照max-age的过期时间<br><img src="/images/http协议原理+实践 笔记/26.png" width="50%"><br>must-revalidate：要是过期了只有从原服务器重新发送请求获取数据<br>proxy-revalidate：缓存服务器必须在过期的时候去原服务器重新请求一遍，不能使用本地的缓存</p><p>no-transform：告诉服务器不能随意改动缓存<br><img src="/images/http协议原理+实践 笔记/27.png" width="50%"><br>多个值可以使用逗号分隔。若有相同属性设置则后面的覆盖前面的<br>有时候客户端的缓存还没到过期时间，但是服务器的文件改变了，这时候浏览器并不会重新下载缓存文件。</p><font color="red">解决办法：hash编码文件名</font><h4 id="3-5-缓存验证Last-Modified和Etag的使用"><a href="#3-5-缓存验证Last-Modified和Etag的使用" class="headerlink" title="3.5 缓存验证Last-Modified和Etag的使用"></a>3.5 缓存验证Last-Modified和Etag的使用</h4><p><img src="/images/http协议原理+实践 笔记/28.png"><br><img src="/images/http协议原理+实践 笔记/29.png" width="40%"><br><img src="/images/http协议原理+实践 笔记/30.png" width="50%"><br><img src="/images/http协议原理+实践 笔记/31.png" width="50%"><br><img src="/images/http协议原理+实践 笔记/32.png"><br>第一次请求<br><img src="/images/http协议原理+实践 笔记/33.png"><br>第二次访问<br><img src="/images/http协议原理+实践 笔记/34.png"></p><h4 id="3-6-cookie和session"><a href="#3-6-cookie和session" class="headerlink" title="3.6 cookie和session"></a>3.6 cookie和session</h4><p><img src="/images/http协议原理+实践 笔记/35.png" width="40%"><br><img src="/images/http协议原理+实践 笔记/36.png" width="50%"></p><h4 id="3-7-HTTP长连接"><a href="#3-7-HTTP长连接" class="headerlink" title="3.7 HTTP长连接"></a>3.7 HTTP长连接</h4><p><img src="/images/http协议原理+实践 笔记/37.png"><br>Connnection ID: TCP连接的id，可以区分使用的是否是同个链接<br>谷歌可以同时创建7个tcp连接，所以一次性可以请求7个链接，剩余的请求将等待之前的连接传输完才可以请求</p><h4 id="3-8-数据协商"><a href="#3-8-数据协商" class="headerlink" title="3.8 数据协商"></a>3.8 数据协商</h4><p><img src="/images/http协议原理+实践 笔记/38.png" width="40%"><br><img src="/images/http协议原理+实践 笔记/39.png" width="40%"><br><img src="/images/http协议原理+实践 笔记/40.png"><br>服务端的content对应客户端的accept<br><img src="/images/http协议原理+实践 笔记/41.png" width="50%"><br><img src="/images/http协议原理+实践 笔记/42.png"><br>gzip：压缩会减少网络传输的开销</p><h4 id="3-9-Redirect"><a href="#3-9-Redirect" class="headerlink" title="3.9 Redirect"></a>3.9 Redirect</h4><p><img src="/images/http协议原理+实践 笔记/43.png"><br>301转向(或叫301重定向，301跳转)是当用户或搜索引擎向网站服务器发出浏览请求时，服务器返回的HTTP数据流中头信息(header)中的状态码的一种，表示本网页永久性转移到另一个地址。<br>302重定向又称之为302代表暂时性转移(Temporarily Moved )，英文名称：302 redirect。</p><h4 id="3-10-CSP-content-security-policy-内容安全策略"><a href="#3-10-CSP-content-security-policy-内容安全策略" class="headerlink" title="3.10 CSP=content-security-policy(内容安全策略)"></a>3.10 CSP=content-security-policy(内容安全策略)</h4><p><img src="/images/http协议原理+实践 笔记/44.png" width="40%"><br><img src="/images/http协议原理+实践 笔记/45.png" width="40%"><br><img src="/images/http协议原理+实践 笔记/46.png" width="50%"><br><img src="/images/http协议原理+实践 笔记/47.png"><br><img src="/images/http协议原理+实践 笔记/48.png"><br><img src="/images/http协议原理+实践 笔记/49.png"></p><p>参考：<a href="https://www.cnblogs.com/heluan/p/8620312.html" target="_blank" rel="noopener">https://www.cnblogs.com/heluan/p/8620312.html</a><br><strong>HTTP的基本优化</strong><br>影响一个 HTTP 网络请求的因素主要有两个：<font color="red">带宽和延迟</font>。<br><strong>带宽：</strong><br>如果说我们还停留在拨号上网的阶段，带宽可能会成为一个比较严重影响请求的问题，但是现在网络基础建设已经使得带宽得到极大的提升，我们不再会担心由带宽而影响网速，那么就只剩下延迟了。<br><strong>延迟：</strong><br><code>浏览器阻塞（HOL blocking）</code>：浏览器会因为一些原因阻塞请求。浏览器对于同一个域名，同时只能有 7 个连接（这个根据浏览器内核不同可能会有所差异），超过浏览器最大连接数限制，后续请求就会被阻塞。<br><code>DNS 查询（DNS Lookup）</code>：浏览器需要知道目标服务器的 IP 才能建立连接。将域名解析为 IP 的这个系统就是 DNS。这个通常可以利用DNS缓存结果来达到减少这个时间的目的。<br><code>建立连接（Initial connection）</code>：HTTP 是基于 TCP 协议的，浏览器最快也要在第三次握手时才能捎带 HTTP 请求报文，达到真正的建立连接，但是这些连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大。</p>]]></content>
      
      <categories>
          
          <category> http </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>CSS垂直居中技巧</title>
      <link href="/2019/05/27/CSS%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E6%8A%80%E5%B7%A7/"/>
      <url>/2019/05/27/CSS%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E6%8A%80%E5%B7%A7/</url>
      <content type="html"><![CDATA[<p>这篇文章我好像是在2018.08.24号收藏的。留到现在才认真看  哭唧唧<br>参考：<a href="http://csscoke.com/2018/08/21/css-vertical-align/" target="_blank" rel="noopener">http://csscoke.com/2018/08/21/css-vertical-align/</a><br><a id="more"></a></p><h2 id="适用情景：单行文字垂直居中技巧"><a href="#适用情景：单行文字垂直居中技巧" class="headerlink" title="适用情景：单行文字垂直居中技巧"></a>适用情景：单行文字垂直居中技巧</h2><h3 id="1-Line-height"><a href="#1-Line-height" class="headerlink" title="1.Line-height"></a>1.Line-height</h3><p><code>line-height:100%</code></p><h2 id="适用情景：多对象的垂直居中技巧"><a href="#适用情景：多对象的垂直居中技巧" class="headerlink" title="适用情景：多对象的垂直居中技巧"></a>适用情景：多对象的垂直居中技巧</h2><h3 id="2-Line-height-inline-block"><a href="#2-Line-height-inline-block" class="headerlink" title="2.Line-height + inline-block"></a>2.Line-height + inline-block</h3><p>既然可以使用第一种方式对行元素达成垂直居中的话，当然没有理由不能做到多行啊~但是你需要将多个元素或多行元素当成一个行元素来看待，所以我们必须要将这些数据多包一层，并将其设定为inline-block，并在该inline-block对象的外层对象使用inline-block来代替height的设置，如此便可以达到垂直居中的目的了.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.ex2&#123;</span><br><span class="line">width: 500px;</span><br><span class="line">border: 1px solid #f00;</span><br><span class="line">line-height: 200px;</span><br><span class="line">text-align: center;</span><br><span class="line">&#125;</span><br><span class="line">.ex2 .content&#123;</span><br><span class="line">display: inline-block;</span><br><span class="line">height: auto;</span><br><span class="line">line-height:1;</span><br><span class="line">width: 400px;</span><br><span class="line">background: #ccc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-before-inline-block"><a href="#3-before-inline-block" class="headerlink" title="3.:before + inline-block"></a>3.:before + inline-block</h3><p>:before 伪类元素搭配 inline-block 属性的写法应该是很传统的垂直居中的技巧了，此方式的好处在于子元素居中可以不需要特别设定高度，我们将利用:before伪类元素设定为100%高的inline-block，再搭配上将需要居中的子元素同样设置成inline-block性质后，就能使用vertical-align:middle来达到垂直居中的目的了，此方式在以往其实是个非常棒的垂直居中解决方案，唯独需要特别处理掉inline-block元素之间的4-5px空间这个小缺陷，但也很实用了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">.ex3&#123;</span><br><span class="line">width: 500px;</span><br><span class="line">height: 250px;</span><br><span class="line">border: 1px solid #f00;</span><br><span class="line">margin: auto;</span><br><span class="line">text-align: center;</span><br><span class="line">&#125;</span><br><span class="line">.ex3::before&#123;</span><br><span class="line">content:&apos;&apos;;</span><br><span class="line">display: inline-block;</span><br><span class="line">height: 100%;</span><br><span class="line">width: 0;</span><br><span class="line">vertical-align: middle;</span><br><span class="line">&#125;</span><br><span class="line">.ex3 .content&#123;</span><br><span class="line">width: 400px;</span><br><span class="line">background: #ccc;</span><br><span class="line">display: inline-block;</span><br><span class="line">vertical-align: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="4-absolute-margin-负值"><a href="#4-absolute-margin-负值" class="headerlink" title="4.absolute + margin 负值"></a>4.absolute + margin 负值</h3><p>绝对定位在这个例子中会设置top:50%来抓取空间高度的50%，接着在将居中元素的margin-top设定为负一半的高度，这样就能让元素居中了。</p><p><font color="red">缺点：需要知道垂直居中元素的宽和高</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.ex4&#123;</span><br><span class="line">width: 500px;</span><br><span class="line">height: 250px;</span><br><span class="line">border: 1px solid #f00;</span><br><span class="line">margin: auto;</span><br><span class="line">position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.ex4 .content&#123;</span><br><span class="line">width: 400px;</span><br><span class="line">background: #ccc;</span><br><span class="line">height: 70px;</span><br><span class="line">position: absolute;</span><br><span class="line">top:50%;</span><br><span class="line">left: 50%;</span><br><span class="line">margin-left: -200px;</span><br><span class="line">margin-top: -35px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="5-absolute-margin-auto"><a href="#5-absolute-margin-auto" class="headerlink" title="5.absolute + margin auto"></a>5.absolute + margin auto</h3><p>当元素设置为绝对定位后，假设它是抓不到整体可运用的空间范围，所以margin:auto会失效，但当你设置了top:0;bottom:0;时，绝对定位元素就抓到了可运用的空间了，这时你的margin:auto就生效了（神奇吧），如果你的绝对定位元素需要水平居中于父层，那你同样可以设定left:0;right:0;来让绝对定位元素取得空间可运用范围，再让marign-left与margin-right设定为auto即可居中。</p><p><font color="red">缺点:是你的定位元素必须有固定的宽高（百分比也算）才能正常居中。</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.ex5&#123;</span><br><span class="line">width: 500px;</span><br><span class="line">height: 250px;</span><br><span class="line">border: 1px solid #f00;</span><br><span class="line">margin: auto;</span><br><span class="line">position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.ex5 .content&#123;</span><br><span class="line">width: 400px;</span><br><span class="line">background: #ccc;</span><br><span class="line">height: 70px;</span><br><span class="line">position: absolute;</span><br><span class="line">top: 0;</span><br><span class="line">right: 0;</span><br><span class="line">bottom: 0;</span><br><span class="line">left: 0;</span><br><span class="line">margin: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="6-absolute-translate"><a href="#6-absolute-translate" class="headerlink" title="6.absolute + translate"></a>6.absolute + translate</h3><p>在一个绝对定位居中的方式，此方式应该算是最方便的了，因为此居中的定位元素不需要固定的宽高，我们利用绝对定位时的top 与right设置元素的上方跟左方各为50%，再利用translate(-50%,-50%)位移居中元素自身宽与高的50%就能达成居中的目的了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.ex6&#123;</span><br><span class="line">width: 500px;</span><br><span class="line">height: 250px;</span><br><span class="line">border: 1px solid #f00;</span><br><span class="line">margin: auto;</span><br><span class="line">position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.ex6 .content&#123;</span><br><span class="line">width: 400px;</span><br><span class="line">background: #ccc;</span><br><span class="line">position: absolute;</span><br><span class="line">top:50%;</span><br><span class="line">left: 50%;</span><br><span class="line">transform: translate(-50%, -50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="7-Flex-align-items"><a href="#7-Flex-align-items" class="headerlink" title="7.Flex + align-items"></a>7.Flex + align-items</h3><p>不由的说Flex真的是一个神物，我们只要设定父层display:flex以及设定次轴(cross axis)属性align-items:center 就好了（说那么多结果重点就一行字是哪招啦），这个方式的优点是此层不需要设定高度即可自动居中，且原始代码干净无比，真的是用一次就让你升天啦。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.ex7&#123;</span><br><span class="line">width: 500px;</span><br><span class="line">height: 250px;</span><br><span class="line">border: 1px solid #f00;</span><br><span class="line">margin: auto;</span><br><span class="line">display: flex;</span><br><span class="line">justify-content: center;</span><br><span class="line">align-items: center; </span><br><span class="line">&#125;</span><br><span class="line">.ex7 .content&#123;</span><br><span class="line">width: 400px;</span><br><span class="line">background: #ccc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>justify-content</code> 用于设置或检索弹性盒子元素在主轴（横轴）方向上的对齐方式。<br><code>align-items</code> 属性定义flex子项在flex容器的当前行的侧轴（纵轴）方向上的对齐方式。</p><h3 id="8-Flex-align-self"><a href="#8-Flex-align-self" class="headerlink" title="8.Flex + align-self"></a>8.Flex + align-self</h3><p>align-self 应该大家都不陌生，基本上就是对flex次轴cross axis 的个别对齐方式只要对单一子层元素设定align-self:center就能达成垂直居中的目的了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.ex8&#123;</span><br><span class="line">width: 500px;</span><br><span class="line">height: 250px;</span><br><span class="line">border: 1px solid #f00;</span><br><span class="line">margin: auto;</span><br><span class="line">display: flex;</span><br><span class="line">justify-content: center;</span><br><span class="line">&#125;</span><br><span class="line">.ex8 .content&#123;</span><br><span class="line">width: 400px;</span><br><span class="line">background: #ccc;</span><br><span class="line">align-self: center</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>align-self</code> 属性定义flex子项单独在侧轴（纵轴）方向上的对齐方式。</p><h3 id="9-Flex-margin"><a href="#9-Flex-margin" class="headerlink" title="9.Flex + margin"></a>9.Flex + margin</h3><p>由于Flex元素对空间解读的特殊性，我们只要在父层元素设定display:flex，接着在需要垂直居中的元素上设定margin:auto，即可自动居中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.ex9&#123;</span><br><span class="line">width: 500px;</span><br><span class="line">height: 250px;</span><br><span class="line">border: 1px solid #f00;</span><br><span class="line">margin: auto;</span><br><span class="line">display: flex;</span><br><span class="line">&#125;</span><br><span class="line">.ex9 .content&#123;</span><br><span class="line">width: 400px;</span><br><span class="line">background: #ccc;</span><br><span class="line">margin: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="10-Display：table-cell"><a href="#10-Display：table-cell" class="headerlink" title="10.Display：table-cell"></a>10.Display：table-cell</h3><p>这一招的原理在于使用 CSS display属性将div设置成表格的单元格，这样就能利用支持存储单元格对齐的vertical-align属性来将信息垂直居中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.ex10&#123;</span><br><span class="line">width: 500px;</span><br><span class="line">height: 250px;</span><br><span class="line">border: 1px solid #f00;</span><br><span class="line">margin: auto;</span><br><span class="line">text-align: center;</span><br><span class="line">display: table-cell;</span><br><span class="line">vertical-align: middle;</span><br><span class="line">&#125;</span><br><span class="line">.ex10 .content&#123;</span><br><span class="line">width: 400px;</span><br><span class="line">background: #ccc;</span><br><span class="line">margin: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 阅读笔记 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>2018.07工作日小结</title>
      <link href="/2019/05/25/2018-07%E5%B7%A5%E4%BD%9C%E6%97%A5%E5%B0%8F%E7%BB%93/"/>
      <url>/2019/05/25/2018-07%E5%B7%A5%E4%BD%9C%E6%97%A5%E5%B0%8F%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>2019.05.25整理2018.07的工作笔记<br><a id="more"></a></p><h3 id="1-ajax的jsonp"><a href="#1-ajax的jsonp" class="headerlink" title="1.ajax的jsonp"></a>1.ajax的jsonp</h3><p>by 2018-07-26 22:11:36<br>若ajax上的dataType写为”jsonp”，则后台返回的数据要是jsonp格式的才行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">json格式：</span><br><span class="line">&#123;</span><br><span class="line">    &quot;message&quot;:&quot;获取成功&quot;,</span><br><span class="line">    &quot;state&quot;:&quot;1&quot;,</span><br><span class="line">    &quot;result&quot;:&#123;&quot;name&quot;:&quot;工作组1&quot;,&quot;id&quot;:1,&quot;description&quot;:&quot;11&quot;&#125;</span><br><span class="line">&#125;</span><br><span class="line">jsonp格式：</span><br><span class="line">callback(&#123;</span><br><span class="line">    &quot;message&quot;:&quot;获取成功&quot;,</span><br><span class="line">    &quot;state&quot;:&quot;1&quot;,</span><br><span class="line">    &quot;result&quot;:&#123;&quot;name&quot;:&quot;工作组1&quot;,&quot;id&quot;:1,&quot;description&quot;:&quot;11&quot;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="2-谷歌浏览器跨域"><a href="#2-谷歌浏览器跨域" class="headerlink" title="2.谷歌浏览器跨域"></a>2.谷歌浏览器跨域</h3><p>by 2018-07-26 22:11:36<br>在桌面的谷歌快捷方式上右键，选择属性，在目标后加<code>--disable-web-security</code></p><h3 id="3-jQuery-的attr（）与css（）的区别"><a href="#3-jQuery-的attr（）与css（）的区别" class="headerlink" title="3.jQuery 的attr（）与css（）的区别"></a>3.jQuery 的attr（）与css（）的区别</h3><p>by 2018-07-25 22:25:31<br><code>attr()</code>是用来获得或设置标签属性的（attribute的缩写）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;#myId&quot;).attr(&quot;data-name&quot;, &quot;baidu&quot;);// 设置属性名data-name，值baidu  即&lt;div id=&quot;myId&quot; data-name=&quot;baidu&quot;&gt;&lt;/div&gt; </span><br><span class="line">var attr = $(&quot;#myId&quot;).attr(&quot;data-name&quot;); // 获取属性名data-name的值</span><br></pre></td></tr></table></figure></p><p>使用js来实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var myId = document.getElementById(&quot;myId&quot;);</span><br><span class="line">myId.setAttribute(&quot;data-name&quot;, &quot;baidu&quot;); // 设置属性</span><br><span class="line">myId.getAttribute(&quot;data-name&quot;); // 获取属性名data-name的值</span><br></pre></td></tr></table></figure></p><p><code>css()</code>是设置元素的style样式的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;#myId&quot;).css(&quot;background-color&quot;, &quot;red&quot;); // 设置背景颜色为红色</span><br><span class="line">var bg = $(&quot;#myId&quot;).css(&quot;background-color&quot;); // 获取背景颜色的值</span><br></pre></td></tr></table></figure></p><p>使用js来实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var myId = document.getElementById(&quot;myId&quot;);</span><br><span class="line">myId.style.backgroundColor = &quot;red&quot;; // 设置</span><br><span class="line">var bg = myId.style.backgroundColor; // 获取</span><br></pre></td></tr></table></figure></p><h3 id="4-javascript中JSON对象与JSON字符串相互转换"><a href="#4-javascript中JSON对象与JSON字符串相互转换" class="headerlink" title="4.javascript中JSON对象与JSON字符串相互转换"></a>4.javascript中JSON对象与JSON字符串相互转换</h3><p>by 2018-07-25 22:25:31<br>jQuery插件支持的转换方式：<br><code>$.parseJSON( jsonstr ); //jQuery.parseJSON(jsonstr)</code>,可以将<font color="red">json字符串转换成json对象</font></p><p>浏览器支持的转换方式(Firefox，chrome，opera，safari，ie9，ie8)等浏览器：<br><code>JSON.parse(jsonstr);</code>可以将<font color="red">json字符串转换成json对象</font><br><code>JSON.stringify(jsonobj);</code> 可以将<font color="red">json对象转换成json对符串</font></p><p><font color="red"><strong>注：</strong></font>ie8(兼容模式),ie7和ie6没有JSON对象，推荐采用JSON官方的方式，引入json.js。(可见2018.09中的15)</p><p>Javascript支持的转换方式：<br><code>eval(&#39;(&#39; + jsonstr + &#39;)&#39;);</code> 可以将json字符串转换成json对象,注意需要在json字符外包裹一对小括号<br>注：ie8(兼容模式),ie7和ie6也可以使用eval()将字符串转为JSON对象，但不推荐这些方式，这种方式不安全eval会执行json串中的表达式</p><h3 id="5-jquery-after-append-appendTo三个函数的区别"><a href="#5-jquery-after-append-appendTo三个函数的区别" class="headerlink" title="5.jquery after append appendTo三个函数的区别"></a>5.jquery after append appendTo三个函数的区别</h3><p>by 2018-07-25 22:25:31<br><code>after()</code> 方法在被选<font color="red">元素后</font>插入指定的内容。<br>语法：<code>$(selector).after(content)</code><br>实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">    $(&quot;span&quot;).after(&quot;&lt;a href=&quot;#&quot;&gt;ddddd&lt;/a&gt;&quot;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;span&gt;aaaaaaaaaaaaaaa&lt;/span&gt;</span><br><span class="line">&lt;button&gt;after函数&lt;/button&gt;</span><br></pre></td></tr></table></figure><p>结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;span&gt;aaaaaaaaaaaaaaa&lt;/span&gt;</span><br><span class="line">&lt;a href=&quot;#&quot;&gt;ddddd&lt;/a&gt;\\span标签后面多了一个a标签</span><br></pre></td></tr></table></figure></p><p><code>append()</code> 方法在被选<font color="red">元素的结尾（仍然在内部）</font>插入指定内容。<br>语法：<code>$(selector).append(content)</code><br>实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">    $(&quot;span&quot;).append(&quot;&lt;a href=&quot;#&quot;&gt;ddddd&lt;/a&gt;&quot;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;span&gt;aaaaaaaaaaaaaaa&lt;/span&gt;</span><br><span class="line">&lt;button&gt;after函数&lt;/button&gt;</span><br></pre></td></tr></table></figure><p>结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span&gt;aaaaaaaaaaaaaaa&lt;a href=&quot;#&quot;&gt;ddddd&lt;/a&gt;&lt;/span&gt;//span标签里面多了一个a标签</span><br></pre></td></tr></table></figure></p><p><code>appendTo()</code> 方法在被选元素的结尾<font color="red">（仍然在内部）</font>插入指定内容。<br>和append()只是语法不同<br>语法：<code>$(content).appendTo(selector)</code><br>实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">$(&quot;&lt;a href=&quot;#&quot;&gt;ddddd&lt;/a&gt;&quot;).appendTo(&quot;span&quot;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;span&gt;aaaaaaaaaaaaaaa&lt;/span&gt;</span><br><span class="line">&lt;button&gt;after函数&lt;/button&gt;</span><br></pre></td></tr></table></figure><p>结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span&gt;aaaaaaaaaaaaaaa&lt;a href=&quot;#&quot;&gt;ddddd&lt;/a&gt;&lt;/span&gt;//span标签里面多了一个a标签</span><br></pre></td></tr></table></figure></p><p><font color="red">备注：</font>before函数与after函数相反，表示是元素的前面加入指定元素</p><h3 id="6-js常见报错之Unexpected-token-in-JSON-at-position"><a href="#6-js常见报错之Unexpected-token-in-JSON-at-position" class="headerlink" title="6.js常见报错之Unexpected token in JSON at position"></a>6.js常见报错之Unexpected token in JSON at position</h3><p>by 2018-07-25 22:25:31<br>出现这个报错提示，根本原因只有一个–json解析异常，所以请大家直接去关注自己json的返回数据注意检查其返回内容和内容的格式是否正确。</p><h3 id="7-哪些操作会引起内存泄露"><a href="#7-哪些操作会引起内存泄露" class="headerlink" title="7.哪些操作会引起内存泄露"></a>7.哪些操作会引起内存泄露</h3><p><a href="https://blog.csdn.net/kk211814/article/details/88323872" target="_blank" rel="noopener">https://blog.csdn.net/kk211814/article/details/88323872</a><br>by 2018-07-25 22:25:52</p><ol><li>setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。</li><li>闭包</li><li>控制台日志</li><li>循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）</li></ol><h3 id="8-拼接字符串的问题-lt"><a href="#8-拼接字符串的问题-lt" class="headerlink" title="8.拼接字符串的问题&lt;"></a>8.拼接字符串的问题&lt;</h3><p>by 2018-07-26 21:30:09<br>问题：访问表单时样式和js文件没有加载出来<br>是因为url拼接错误<br>str.substr(start,length)截取字符串</p><h3 id="9-远程访问"><a href="#9-远程访问" class="headerlink" title="9.远程访问"></a>9.远程访问</h3><p>by 2018-07-26 21:30:09<br>在文件夹的链接地址里输入//+ip地址，之后输入账号和密码即可</p><h3 id="10-导航栏设置为同步访问才能访问二级菜单"><a href="#10-导航栏设置为同步访问才能访问二级菜单" class="headerlink" title="10.导航栏设置为同步访问才能访问二级菜单"></a>10.导航栏设置为同步访问才能访问二级菜单</h3><p>by 2018-07-26 21:30:09<br>若数据的加载依赖于前面请求返回的结果的话。就要把前面的请求设置为同步</p><h3 id="11-二次链接发送ajax—函数返回的数据"><a href="#11-二次链接发送ajax—函数返回的数据" class="headerlink" title="11. 二次链接发送ajax—函数返回的数据"></a>11. 二次链接发送ajax—函数返回的数据</h3><p>by 2018-07-26 21:30:09<br>遇到的场景：得到一个链接之后，访问请求回来的是一个真实的链接。<br>所以需要将第一次请求回来的结果拼接之后再次发送请求，得到响应数据的才是真实的结果。</p><h3 id="12-相对连接-w"><a href="#12-相对连接-w" class="headerlink" title="12.相对连接.w"></a>12.相对连接.w</h3><p>by 2018-07-26 21:30:09<br>前期写代码的时候使用相对连接，之后好部署到服务器上。</p><h3 id="13-金额加逗号"><a href="#13-金额加逗号" class="headerlink" title="13.金额加逗号"></a>13.金额加逗号</h3><p>by 2018-07-26 21:30:09<br>str.replace(/(\d{1,3})(?=(\d{3})+(?:$|.))/g,’$1,’);<br>注：先将数字转化成字符串<br><code>(?=pattern)</code>:正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，”Windows(?=95|98|NT|2000)”能匹配”Windows2000”中的”Windows”，但不能匹配”Windows3.1”中的”Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。<br><code>+</code>:匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。<br><code>(?:pattern)</code>:匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 “或” 字符 (|) 来组合一个模式的各个部分是很有用。例如， ‘industr(?:y|ies) 就是一个比 ‘industry|industries’ 更简略的表达式<br><code>x|y</code>:匹配 x 或 y。例如，’z|food’ 能匹配 “z” 或 “food”。’(z|f)ood’ 则匹配 “zood” 或 “food”。</p><h3 id="14-小数截取两位"><a href="#14-小数截取两位" class="headerlink" title="14.小数截取两位"></a>14.小数截取两位</h3><p>by 2018-07-26 21:30:09<br>Math.floor(num*100)/100</p><h3 id="15-今天同事遇到了模态框的不能渲染数据的问题，但是我回来试了下是可以的，不知道为什么。"><a href="#15-今天同事遇到了模态框的不能渲染数据的问题，但是我回来试了下是可以的，不知道为什么。" class="headerlink" title="15.今天同事遇到了模态框的不能渲染数据的问题，但是我回来试了下是可以的，不知道为什么。"></a>15.今天同事遇到了模态框的不能渲染数据的问题，但是我回来试了下是可以的，不知道为什么。</h3><p>by 2018-07-31 20:38:48</p><h3 id="16-function-的解析"><a href="#16-function-的解析" class="headerlink" title="16.$(function(){})的解析"></a>16.$(function(){})的解析</h3><p>by 2018-07-31 20:38:48<br>$(function(){})是$(document).ready()的缩写<br>当 DOM（文档对象模型）已经加载，并且页面（包括图像）已经完全呈现时，会发生 ready 事件。<br>由于该事件在文档就绪后发生，因此把所有其他的 jQuery 事件和函数置于该事件中是非常好的做法。</p><p>页面加载完成有两种事件:<br>$(document).ready(function(){}) : 表示文档结构已经加载完成（不包含图片等非文字媒体文件）<br>window.onload: 表示页面包含图片等文件在内的所有元素都加载完成后执行。<br><em>可以理解为：ready 在onload 前加载！！</em><br>一般样式控制的，比如图片大小控制放在onload 里面加载;<br>而jS事件触发的方法，可以在ready 里面加载。</p><h3 id="17-vue的生命周期"><a href="#17-vue的生命周期" class="headerlink" title="17.vue的生命周期"></a>17.vue的生命周期</h3><p>by 2018-07-31 20:38:48<br><img src="/images/7.30小结/1.png"><br>参考：<a href="https://segmentfault.com/a/1190000008010666" target="_blank" rel="noopener">https://segmentfault.com/a/1190000008010666</a><br><code>beforecreated</code>：el 和 data 并未初始化<br><code>created</code>:完成了 data 数据的初始化，el没有<br><code>beforeMount</code>：完成了 el 和 data 初始化<br><code>mounted</code> ：完成挂载</p><h3 id="18-echarts的china-js"><a href="#18-echarts的china-js" class="headerlink" title="18.echarts的china.js"></a>18.echarts的china.js</h3><p>by 2018-07-31 21:00:08<br>参考：<a href="https://xieshuangting.github.io/ZJCproject/" target="_blank" rel="noopener">https://xieshuangting.github.io/ZJCproject/</a></p><h3 id="19-获取option的选中项目"><a href="#19-获取option的选中项目" class="headerlink" title="19.获取option的选中项目"></a>19.获取option的选中项目</h3><p>by 2018-07-31 21:00:08<br><code>$(&quot;#select&quot;).change(function(){//code...});</code>//为Select添加事件，当选择其中一项时触发<br><code>$(&quot;#select&quot;).find(&quot;option:selected&quot;).text();</code> //获取Select选择的text<br><code>$(&quot;#select&quot;).val();</code> //获取Select选择的Value<br><code>$(&quot;#select&quot;).get(0).selectedIndex;</code> //获取Select选择的索引值<br><code>$(&quot;#select option:last&quot;).attr(&quot;index&quot;);</code> //获取Select最大的索引值<br><code>$(&quot;.selector&quot;).val(&quot;pxx&quot;);</code>//设置value为pxx的项选中</p><h3 id="20-在main-js页面封装跳转函数-toPage（）"><a href="#20-在main-js页面封装跳转函数-toPage（）" class="headerlink" title="20.在main.js页面封装跳转函数 toPage（）"></a>20.在main.js页面封装跳转函数 toPage（）</h3><p>by 2018-07-31 21:00:08<br>Vue.prototype.toPage = function (path, query) {<br>  router.push({path: path, query: query})<br>}</p><hr><p><strong>日常小叨：</strong>07.24：在工作中遇到a标签href突然之间不太清楚怎么设置了，和css()方法混在一起。<br>利用AJAX在获取后台的JSON数据时，取不到属性值。原因是不知道什么原因返回的JSON是字符串的格式，就是整个JSON对象外包裹了一层双引号。所以要将得到的响应数据JSON化。</p>]]></content>
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>2018.08工作日小结</title>
      <link href="/2019/05/25/2018-08%E5%B7%A5%E4%BD%9C%E6%97%A5%E5%B0%8F%E7%BB%93/"/>
      <url>/2019/05/25/2018-08%E5%B7%A5%E4%BD%9C%E6%97%A5%E5%B0%8F%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>2019.05.25整理的2018.08的工作笔记<br><a id="more"></a></p><h3 id="1-jquery的动画animate"><a href="#1-jquery的动画animate" class="headerlink" title="1.jquery的动画animate()"></a>1.jquery的动画animate()</h3><p>by 2018-08-05 11:32:47<br>遇到的问题：当想要导航栏隐藏时，使用了<code>$(&quot;#page-wrapper&quot;).animate({marginLeft:&quot;0&quot;});</code><br>之前的理解笔记：animate()方法执行css属性集(即{XX:xx})的自定义动画<br>只有数字值可以创建动画，比如{margin:”300px”}<br>字符串无法创建动画，例如background-color:red;属性。</p><p><code>$(selector).animate({params},speed,callback);</code><br>必需的 <code>params</code> 参数定义形成动画的 CSS 属性。<br>可选的 <code>speed</code> 参数规定效果的时长。它可以取以下值：”slow”、”fast” 或毫秒。<br>可选的 <code>callback</code> 参数是动画完成后所执行的函数名称。</p><p><strong>注：</strong>默认情况下，所有 HTML 元素都有一个静态位置，且无法移动。<br>如需对位置进行操作，要记得首先把元素的 CSS position 属性设置为 relative、fixed 或 absolute！<font color="bule">(可以这样理解，只有将position属性设置为以上的才有top，left等属性可以操作)</font></p><h4 id="可操作多个属性"><a href="#可操作多个属性" class="headerlink" title="可操作多个属性"></a>可操作多个属性</h4><p>请注意，生成动画的过程中可同时使用多个属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">  $(&quot;div&quot;).animate(&#123;</span><br><span class="line">    left:&apos;250px&apos;,</span><br><span class="line">    opacity:&apos;0.5&apos;,</span><br><span class="line">    height:&apos;150px&apos;,</span><br><span class="line">    width:&apos;150px&apos;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>可以用 animate() 方法来操作所有 CSS 属性。不过，当使用 animate() 时，必须使用 Camel 标记法书写所有的属性名，比如，必须使用 paddingLeft 而不是 padding-left，使用 marginRight 而不是 margin-right，等等。<br>同时，色彩动画并不包含在核心 jQuery 库中。</p><h4 id="使用相对值"><a href="#使用相对值" class="headerlink" title="使用相对值"></a>使用相对值</h4><p>也可以定义相对值（该值相对于元素的当前值）。需要在值的前面加上 <font color="red">+= 或 -=</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">  $(&quot;div&quot;).animate(&#123;</span><br><span class="line">    left:&apos;250px&apos;,</span><br><span class="line">    height:&apos;+=150px&apos;,</span><br><span class="line">    width:&apos;+=150px&apos;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h4 id="使用预定义的值"><a href="#使用预定义的值" class="headerlink" title="使用预定义的值"></a>使用预定义的值</h4><p>您甚至可以把属性的动画值设置为 “show”、”hide” 或 “toggle”：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">  $(&quot;div&quot;).animate(&#123;</span><br><span class="line">    height:&apos;toggle&apos;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>将height设置为hide的话，就只会执行一次操作：隐藏。再次点击不会显示。</p><h4 id="使用队列功能"><a href="#使用队列功能" class="headerlink" title="使用队列功能"></a>使用队列功能</h4><p>默认地，jQuery 提供针对动画的队列功能。<br>这意味着如果您在彼此之后编写多个 animate() 调用，jQuery 会创建包含这些方法调用的”内部”队列。然后逐一运行这些 animate 调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">  var div=$(&quot;div&quot;);</span><br><span class="line">  div.animate(&#123;height:&apos;300px&apos;,opacity:&apos;0.4&apos;&#125;,&quot;slow&quot;);</span><br><span class="line">  div.animate(&#123;width:&apos;300px&apos;,opacity:&apos;0.8&apos;&#125;,&quot;slow&quot;);</span><br><span class="line">  div.animate(&#123;height:&apos;100px&apos;,opacity:&apos;0.4&apos;&#125;,&quot;slow&quot;);</span><br><span class="line">  div.animate(&#123;width:&apos;100px&apos;,opacity:&apos;0.8&apos;&#125;,&quot;slow&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="2-window-resize"><a href="#2-window-resize" class="headerlink" title="2.$(window).resize"></a>2.$(window).resize</h3><p>by 2018-08-05 11:32:47<br>遇到的问题：想要调整好iframe的高度，使之适应浏览器的高度又不出现滚动条。<br>调整资金池后台首页的样式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(window).resize(function() &#123;</span><br><span class="line">$(selector).height($(window).height() - $(selector).offset().top);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>resize() 方法触发 resize 事件，或规定当发生 resize 事件时运行的函数。<br>$(selector).offset().top:  获得selector的上面部分的高度。<br>$(window).height():  获得当前窗口的高度。<br>将iframe的高度设置为当前可视高度的剩余空白部分<br>注：最重要的是要将iframe的display设置为block或者设置<code>vertical-align:bottom;</code></p><h3 id="3-获取元素高度"><a href="#3-获取元素高度" class="headerlink" title="3.获取元素高度"></a>3.获取元素高度</h3><p>by 2018-08-05 11:32:47<br>遇到的问题：想要获得加载出来的li的高度<br><code>height()</code> - 设置或返回元素的高度<br><code>innerHeight()</code> - 返回元素的高度（包含 padding）<br><code>outerHeight()</code> - 返回元素的高度（包含 padding 和 border）</p><h3 id="4-获取浏览器的高度"><a href="#4-获取浏览器的高度" class="headerlink" title="4.获取浏览器的高度"></a>4.获取浏览器的高度</h3><p>by 2018-08-05 11:32:47<br><code>$(window).height();</code> 浏览器当前窗口可视区域高度<br><code>$(document).height();</code>  浏览器当前窗口文档的高度<br><code>$(document.body).height();</code> 浏览器当前窗口文档body的高度<br><code>$(document.body).outerHeight(true);</code> 浏览器当前窗口文档body的总高度 包括border padding margin</p><h3 id="5-vuex的使用总结"><a href="#5-vuex的使用总结" class="headerlink" title="5.vuex的使用总结"></a>5.vuex的使用总结</h3><p>by 2018-08-09 22:29:47<br>1.引用<br><code>npm install vuex --save</code><br>2.在main.js文件下填上以下代码<br><img src="/images/8-9小结/1.jpg"><br><img src="/images/8-9小结/2.jpg"><br>3.获得属性值<br><img src="/images/8-9小结/3.jpg"><br><strong>注：在方法和v-html中使用要加上this</strong><br>4.改变属性值<br><img src="/images/8-9小结/4.jpg"></p><p>更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数。</p><p><font color="red">bug：刷新页面store数据不会保留</font></p><p><font color="red">路由刷新:</font>是无刷新跳转，表面看起来就像是一个app应用，表现效果就像你写的 tab 选项卡，所有的数据都还存在内存里，页面是无重载的。</p><p><font color="red">F5刷新:</font>做了什么事呢，重新载入页面，销毁之前所有的数据。<br>所以，这个bug出现的问题就很好理解了，F5页面刷新，页面销毁之前的资源，重新请求，因此写在生命周期里的vuex数据是重新初始化<br>解决思路1：<br>在store改变的时候同时也改变sessionStorage的值。初始化store的时候先检测下sessionStorage里面有没有值。有值则从sessionStorage里取，没值的话则给默认值<br><img src="/images/8-9小结/5.png"><br>注：sessionStore不存在返回null<br><img src="/images/8-9小结/6.png"><br>解决思路2：<br>watch方法来监听store变量，但是在页面重载的时候watch方法也是重新进行计算加载的。<br>解决思路3：<br>可以选择计算属性这个方法来尝试解决这个问题，并且官方文档给出的解释当中也提到了缓存，也就是如果有缓存的情况下computed会优先使用缓存<br><img src="/images/8-9小结/7.png"><br><img src="/images/8-9小结/8.png"><br>Computed属性的优点我试着来总结一下：</p><ol><li>纯响应式，computed里面所用到的data一旦改变，整个computed的方法就回重新计算这个属性值</li><li>计算结果会被缓存起来，方便下次使用，如果下次调用的时候，其中的数据没有发生变化，则不会重新计算。</li></ol><p><strong>扩展：</strong><a href="https://vuex.vuejs.org/zh/" target="_blank" rel="noopener">https://vuex.vuejs.org/zh/</a></p><h3 id="6-路由的路径不改变，只改变参数不刷新页面"><a href="#6-路由的路径不改变，只改变参数不刷新页面" class="headerlink" title="6.路由的路径不改变，只改变参数不刷新页面"></a>6.路由的路径不改变，只改变参数不刷新页面</h3><p>by 2018-08-09 22:29:47<br>解决：使用watch来监听<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">//如果route发生变化，就会触发该函数</span><br><span class="line">$route: function (val, oldVal) &#123;</span><br><span class="line">console.log(this.$route.query.id)</span><br><span class="line">//发起请求</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><font color="red">引用：<a href="https://www.cnblogs.com/crazycode2/p/8727410.html" target="_blank" rel="noopener">https://www.cnblogs.com/crazycode2/p/8727410.html</a></font><br><strong>vue 监听路由变化</strong><br><strong>方法一：通过 watch</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 监听,当路由发生变化的时候执行</span><br><span class="line">watch:&#123;</span><br><span class="line">  $route(to,from)&#123;</span><br><span class="line">    console.log(to.path);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><p>或<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">  $route: &#123;</span><br><span class="line">    handler: function(val, oldVal)&#123;</span><br><span class="line">      console.log(val);</span><br><span class="line">    &#125;,</span><br><span class="line">    // 深度观察监听</span><br><span class="line">    deep: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><p>或<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">  &apos;$route&apos;:&apos;getPath&apos;</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  getPath()&#123;</span><br><span class="line">    console.log(this.$route.path);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>方法二：key是用来阻止“复用”的。</strong><br>Vue 为你提供了一种方式来声明“这两个元素是完全独立的——不要复用它们”。只需添加一个具有唯一值的 key 属性即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-view :key=&quot;key&quot;&gt;&lt;/router-view&gt;</span><br><span class="line"></span><br><span class="line">computed: &#123;</span><br><span class="line">  key() &#123;</span><br><span class="line">    return this.$route.name !== undefined? this.$route.name +new Date(): this.$route +new Date()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用computed属性和Date()可以保证每一次的key都是不同的，这样就可以如愿刷新数据了。</p><p><strong>方法三：通过 vue-router 的钩子函数 beforeRouteEnter  beforeRouteUpdate  beforeRouteLeave</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &apos;app&apos;,</span><br><span class="line">    beforeRouteEnter (to, from, next) &#123;</span><br><span class="line">      // 在渲染该组件的对应路由被 confirm 前调用</span><br><span class="line">      // 不！能！获取组件实例 `this` 因为当钩子执行前，组件实例还没被创建</span><br><span class="line">    &#125;,</span><br><span class="line">    beforeRouteUpdate (to, from, next) &#123;</span><br><span class="line">      // 在当前路由改变，但是该组件被复用时调用</span><br><span class="line">      // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，</span><br><span class="line">      // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span><br><span class="line">      // 可以访问组件实例 `this`</span><br><span class="line">    &#125;,</span><br><span class="line">    beforeRouteLeave (to, from, next) &#123;</span><br><span class="line">      // 导航离开该组件的对应路由时调用</span><br><span class="line">      // 可以访问组件实例 `this`</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><h3 id="7-sessionStorage存储方法"><a href="#7-sessionStorage存储方法" class="headerlink" title="7.sessionStorage存储方法"></a>7.sessionStorage存储方法</h3><p>by 2018-08-09 22:29:47<br>坑：在开发模式下IE浏览器和其他浏览器是可以运行的，但是打包之后在IE浏览器就不能解析。所以最后使用了vuex来存储新闻类别的状态。<br>保存数据到sessionStorage：<br>sessionStorage.setItem(key,value)  对应取值 sessionStorage.getItem(key)<br>sessionStorage.key = value<br>sessionStorage[key] = value</p><p>从sessionStorage删除所有保存的数据：<br>sessionStorage.clear();</p><p>从sessionStorage删除保存的数据：<br>sessionStorage.removeItem(k)</p><p><strong>扩展：localStorage和sessionStorage的区别：</strong><br><strong>引用：<a href="https://blog.csdn.net/kerryqpw/article/details/71439104" target="_blank" rel="noopener">https://blog.csdn.net/kerryqpw/article/details/71439104</a></strong><br>(1)localStorage和sessionStorage一样都是用来存储客户端临时信息的对象。<br>(2)他们均只能存储<font color="red">字符串类型</font>的对象（虽然规范中可以存储其他原生类型的对象，但是目前为止没有浏览器对其进行实现）。<br>(3)、localStorage生命周期是永久，这意味着除非用户显示在浏览器提供的UI上清除localStorage信息，否则这些信息将永远存在。<br>sessionStorage生命周期为当前窗口或标签页，一旦窗口或标签页被永久关闭了，那么所有通过sessionStorage存储的数据也就被清空了<br>(4)、不同浏览器无法共享localStorage或sessionStorage中的信息。<font color="blue">相同浏览器的不同页面间可以共享相同的localStorage（页面属于相同域名和端口），但是不同页面或标签页间无法共享sessionStorage的信息。</font>这里需要注意的是，<font color="red">页面及标签页仅指顶级窗口，如果一个标签页包含多个iframe标签且他们属于同源页面，那么他们之间是可以共享sessionStorage的。</font><br>例：<br><code>http://www.test.com</code><br><code>https://www.test.com</code> （不同源，因为协议不同）<br><code>http://my.test.com</code>（不同源，因为主机名不同）<br><code>http://www.test.com:8080</code>（不同源，因为端口不同）</p><h3 id="8-vue组件化"><a href="#8-vue组件化" class="headerlink" title="8.vue组件化"></a>8.vue组件化</h3><p>by date: 2018-08-10 23:02:00<br>1.可以不对组件命名。<br>2.<strong>父-子</strong><br>父组件向子组件传数据是通过<code>v-on:contentList=&quot;content&quot;</code>(括号内的是父组件传递的具体数据名)<br>子组件接受父组件传递的数据是使用<code>props:{contentList:{type:Array}}</code><br>3.<strong>子-父</strong><br>子组件向父组件传数据是使用<code>this.$emit(&#39;cart-add&#39;, event.target)</code>(第一个参数:在父组件中监听的事件名。第二个参数:传递的数据)<br>在父组件中引入子组件时，定义一个on的方法监听子组件的状态<code>v-on:cart-add=&quot;cartAdd&quot;</code>(括号内为父组件中实际执行的函数名)。再在method里面使用该传递的数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cartAdd: function (value) &#123;</span><br><span class="line">// value就是子组件传过来的值</span><br><span class="line">this.name = value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>疑问？</strong>在父组件中怎么更新传入子组件的数据,改变了子组件的数据，父组件自动改变</p><h3 id="9-对于使用click和onclick的区别"><a href="#9-对于使用click和onclick的区别" class="headerlink" title="9.对于使用click和onclick的区别"></a>9.对于使用click和onclick的区别</h3><p>by date: 2018-08-10 23:02:00</p><p><font color="red">关键字click</font><br>on() 方法在被选元素及子元素上添加一个或多个事件处理程序。<br>自 jQuery 版本 1.7 起，on() 方法是 bind()、live() 和 delegate() 方法的新的替代品。<br>使用 on() 方法添加的事件处理程序适用于当前及<font color="red">未来的元素（比如由脚本创建的新元素）</font>。<br>bind() 方法向被选元素添加一个或多个事件处理程序，以及当事件发生时运行的函数。<br>addEventListener() 方法用于向指定元素添加事件句柄。</p><p><font color="red">关键字onclick</font><br>注意： Internet Explorer 8 及更早IE版本不支持 addEventListener() 方法，，Opera 7.0 及 Opera 更早版本也不支持。 但是，对于这些不支持该函数的浏览器，你可以使用 attachEvent() 方法来添加事件句柄 (查看 “更多实例” 了解跨浏览器的解决方案)。<br>在dom元素上操作 也是onclick<br>object.onclick=function(){SomeJavaScriptCode};</p><h3 id="10-元素不存在时返回的是什么"><a href="#10-元素不存在时返回的是什么" class="headerlink" title="10.元素不存在时返回的是什么"></a>10.元素不存在时返回的是什么</h3><p>by date: 2018-08-21 21:39:40<br><img src="/images/8-21小结/1.png"><br><img src="/images/8-21小结/3.png"><br><img src="/images/8-21小结/2.png"></p><h3 id="11-absolute只坚持一点，就是以父级左上角为原点进行定位，父级的padding对其根本没有影响。"><a href="#11-absolute只坚持一点，就是以父级左上角为原点进行定位，父级的padding对其根本没有影响。" class="headerlink" title="11.absolute只坚持一点，就是以父级左上角为原点进行定位，父级的padding对其根本没有影响。"></a>11.absolute只坚持一点，就是以父级左上角为原点进行定位，父级的padding对其根本没有影响。</h3><p>by date: 2018-08-21 21:39:40<br><img src="/images/8-21小结/4.png" width="50%"><br><img src="/images/8-21小结/5.png"><br><img src="/images/8-21小结/6.png"></p><h3 id="12-v-model获取select的选中值"><a href="#12-v-model获取select的选中值" class="headerlink" title="12.v-model获取select的选中值"></a>12.v-model获取select的选中值</h3><p>by date: 2018-08-21 21:39:40<br><img src="/images/8-21小结/7.png"><br><img src="/images/8-21小结/8.png"><br>选中的值样式没有任何变化</p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="/images/8-21小结/9.png"></h2><p><strong>日常小叨：</strong><br>08.09:<br>时隔很久才完整地写（粘贴）了一篇文。很有成就感呢，今天工作也收获了很多。加油哈哈哈<br>08.10:<br>1.对于一些样式，表现形式相同的html片段一定要用组件封装。不然后续要修改的地方更多。<br>2.后台小哥问的问题也很一针见血的指出了我的不足。虽然当时回答出来了。但是，也是在演示了n个错误示范中才想起来的（捂脸）。我可是个搞前端的呀。</p>]]></content>
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>关于spy-debugger</title>
      <link href="/2019/05/25/%E5%85%B3%E4%BA%8Espy-debugger/"/>
      <url>/2019/05/25/%E5%85%B3%E4%BA%8Espy-debugger/</url>
      <content type="html"><![CDATA[<p>今天早上在微信公众号中看到《9102 了，你还不会移动端真机调试？》这篇文章。顿时就像在沙漠中看到了一片森林一样的感觉。因为之前做过手机端的网页和微信公众号的东西，因为手机上没有控制台，样式什么的调整不了，打印出来的东西不能看到，只能借助alert()来调试。这篇文章真的是给我送来了一泓清水。<br>by 2019.03.29<br><a id="more"></a><br>若只是单纯的看效果有两种方法<br>1.使用本机ip+端口号来访问网页<br>2.使用草料网<a href="https://cli.im/" target="_blank" rel="noopener">https://cli.im/</a>, 需要保持在同个局域网下，使用相同的wifi（这种方法在第一种方法下显得有点鸡肋）</p><p>接下来正式介绍spy-debugger</p><h3 id="一．安装："><a href="#一．安装：" class="headerlink" title="一．安装："></a>一．安装：</h3><p><code>npm install –g spy-debugger</code></p><h3 id="二．启动："><a href="#二．启动：" class="headerlink" title="二．启动："></a>二．启动：</h3><p><code>spy-debugger</code></p><h3 id="三．设置手机的HTTP代理："><a href="#三．设置手机的HTTP代理：" class="headerlink" title="三．设置手机的HTTP代理："></a>三．设置手机的HTTP代理：</h3><p>Android设置步骤：设置 - WLAN - 长按选中网络（电脑所连的wifi） - 修改网络 - 高级 - 代理设置 - 手动。<br>代理的地址为PC的IP地址，代理的端口为spy-debugger的启动端口，默认端口是 9888。<br>如果要指定端口： <code>spy-debugger–p8888</code>。<br>手机安装证书(node-mitmproxy CA根证书)：<br><img src="/images/关于spy-debugger/1.png"></p><h3 id="四．使用"><a href="#四．使用" class="headerlink" title="四．使用"></a>四．使用</h3><p>在电脑端将要调试的项目跑起来。然后使用手机浏览器打开ip+端口号。在<a href="http://127.0.0.1:50686/" target="_blank" rel="noopener">http://127.0.0.1:50686/</a>  就可以看到手机浏览器打开的页面，进而进行调试。</p>]]></content>
      
      <categories>
          
          <category> 前端工具 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>2018.09工作日小结</title>
      <link href="/2019/05/24/2018-09%E5%B7%A5%E4%BD%9C%E6%97%A5%E5%B0%8F%E7%BB%93/"/>
      <url>/2019/05/24/2018-09%E5%B7%A5%E4%BD%9C%E6%97%A5%E5%B0%8F%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>今天整理之前发布过9月份日小结。<br><a id="more"></a></p><h3 id="1-table属性"><a href="#1-table属性" class="headerlink" title="1.table属性"></a>1.table属性</h3><p>by 2018-09-04 22:22:09<br>1.table默认是没有边框的<br><img src="/images/9-4小结/1.png"><br>2.<code>&lt;table border=&quot;4&quot;&gt;</code>:规定表格边框的宽度。<br><img src="/images/9-4小结/2.png"><br>3.<code>cellpadding=&quot;10&quot;</code>:属性规定单元边沿与其内容之间的空白。<br><img src="/images/9-4小结/3.png"><br>4.<code>cellspacing=&quot;10&quot;</code>:属性规定单元格之间的空间。<br><img src="/images/9-4小结/4.png"><br><em>注</em>：34属性不一定需要border属性，只是有了border可以更好地展示出效果。<br>5.<code>width=400</code>:属性规定单元格之间的空间。</p><h3 id="2-iframe高度自适应"><a href="#2-iframe高度自适应" class="headerlink" title="2.iframe高度自适应"></a>2.iframe高度自适应</h3><p>by 2018-09-04 22:22:09<br>如果有人也是使用iframe嵌套进去的方法，页面中的内容高度不再自适应了，此时计算div的高度的方法又是没错的，那么有可能就是没有把页面方法放到同一个域中去执行，所以的解决的方法就是可以放在服务器下去执行。<br>如果你是使用浏览器直接打开，那么使用的可能是file协议，所以才会导致浏览器报错。</p><h3 id="3-flex自适应"><a href="#3-flex自适应" class="headerlink" title="3.flex自适应"></a>3.flex自适应</h3><p>by 2018-09-04 22:22:09<br><code>flex-wrap</code>设置项目是否在一条线上，默认为<code>nowrap</code><br>为了让弹性盒元素在必要的时候拆行，可以设置为<code>flex-wrap:wrap;</code><br><img src="/images/9-4小结/5.png"><br><a href="https://blog.csdn.net/qq_34648000/article/details/79115294" target="_blank" rel="noopener">https://blog.csdn.net/qq_34648000/article/details/79115294</a></p><h3 id="4-省略号要在有边界的容器里使用"><a href="#4-省略号要在有边界的容器里使用" class="headerlink" title="4.省略号要在有边界的容器里使用"></a>4.省略号要在有边界的容器里使用</h3><p>by 2018-09-04 22:22:09<br>因为容器得要有边界才能有省略号。行内元素没有边界容器只会被一直撑大。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">white-space: nowrap;</span><br><span class="line">text-overflow: ellipsis;</span><br><span class="line">overflow: hidden;</span><br><span class="line">width: 400px;</span><br></pre></td></tr></table></figure></p><p>这4个属性缺一不可</p><h3 id="5-overflow"><a href="#5-overflow" class="headerlink" title="5.overflow"></a>5.overflow</h3><p>by 2018-09-05 21:34:29<br>overflow：属性规定当内容溢出元素框时发生的事情。<br><img src="/images/9-5小结/1.png"><br><b>遇到的问题</b>：当侧边菜单栏点击一级菜单的时候出现二级菜单，但是菜单项过多的时候不能出现滚动条。<br>当时没能解决。所以使用了另外的方法：<b>当点击一个菜单的时候关闭所有的二级菜单。</b><br><code>$(&quot;.list&quot;).hide(100);</code></p><h3 id="6-绘制三角形"><a href="#6-绘制三角形" class="headerlink" title="6.绘制三角形"></a>6.绘制三角形</h3><p>by 2018-09-05 21:34:29<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">width: 0px;</span><br><span class="line">height: 0px;</span><br><span class="line">border-left: 10px red solid;</span><br><span class="line">border-bottom: 10px transparent solid;</span><br><span class="line">border-top: 10px transparent solid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>改变三角形本身的角度：改变border-width各个宽度的大小<br>改变三角形位置的角度：<code>transform: rotate(70deg);</code></p><h3 id="7-echarts默认设置最小的饼图面积"><a href="#7-echarts默认设置最小的饼图面积" class="headerlink" title="7.echarts默认设置最小的饼图面积"></a>7.echarts默认设置最小的饼图面积</h3><p>by 2018-09-05 21:34:29<br>minAngle:10(设置默认的最小角度)<br><img src="/images/9-5小结/2.png"></p><h3 id="8-select和option的宽度"><a href="#8-select和option的宽度" class="headerlink" title="8.select和option的宽度"></a>8.select和option的宽度</h3><p>by 2018-09-06 22:23:21<br>问题描述：select固定宽度。option内容大于设置的宽度。option则会超出select<br>不设置select为固定宽度时，select选择框的长度会自适应内容的宽度。<br>当固定select的宽度时，option的宽度大于select的宽度时。option的宽度会长于select的宽度。不知道怎么将option的超出部分截断并使之与select一样长。</p><p>所以换成用div配合ul实现。<br><b>扩展</b>：控制option的高度。<br>参考：<a href="https://blog.csdn.net/weixin_41262388/article/details/78954276" target="_blank" rel="noopener">https://blog.csdn.net/weixin_41262388/article/details/78954276</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;select onmousedown=&quot;if(this.options.length&gt;3)&#123;this.size=4&#125;&quot; onblur=&quot;this.size=0&quot; onchange=&quot;this.size=0&quot;&gt;</span><br><span class="line">&lt;option selected&gt;选择区服&lt;/option&gt;</span><br><span class="line">&lt;option&gt;测试一区&lt;/option&gt;</span><br><span class="line">&lt;option&gt;测试二区&lt;/option&gt;</span><br><span class="line">&lt;option&gt;测试三区&lt;/option&gt;</span><br><span class="line">&lt;option&gt;测试四区&lt;/option&gt;</span><br><span class="line">&lt;option&gt;测试五区&lt;/option&gt;</span><br><span class="line">&lt;option&gt;测试六区&lt;/option&gt;</span><br><span class="line">&lt;option&gt;测试七区&lt;/option&gt;</span><br><span class="line">&lt;option&gt;测试八区&lt;/option&gt;  </span><br><span class="line">&lt;option&gt;测试九区&lt;/option&gt;</span><br><span class="line">&lt;option&gt;测试十区&lt;/option&gt; </span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure></p><p>主要的还是这几个事件进行处理。<br><code>onmousedown</code> 鼠标按下事件，当鼠标按下的时候，进行select选择框的option判断，如果超过三个就把size设置为4，这样就会出现滚动条。<br><code>onblur</code> 在失去焦点的时候会触发，这样当你离开这个select的选择框的时候，点击一下其他地方就会使得这个size归零。然后就会变成最初的状态。也就是我们常见的下拉框初始状态。<br><code>onchange</code> 在选择的option在更改的时候就会触发，使得size归零，同时显示你所选择的option。这样就基本实现了下拉框的高度的问题处理，<br><code>绝对定位</code> 因为你在触发更改这个size的时候，select下拉框的高度也会改变的，很有可能会影响到你所做的布局。所以要有一个绝对定位。<br><b>注：</b>正常的select不用使用绝对定位</p><h3 id="9-echarts的大小自适应"><a href="#9-echarts的大小自适应" class="headerlink" title="9.echarts的大小自适应"></a>9.echarts的大小自适应</h3><p>by 2018-09-06 22:23:21<br>当个页面多个图表需要自适应大小时<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&quot;resize&quot;, function() &#123;</span><br><span class="line">    myCharts1.resize();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>若是只有一个则可以这样子写<code>window.onresize = myCharts1.resize;</code><br>原因：<code>window.onresize</code>这样的写法一个元素一次只能绑定一个事件处理函数，新的事件处理函数会覆盖旧的事件处理函数</p><h3 id="10-当echarts图表没出来时显示加载图标"><a href="#10-当echarts图表没出来时显示加载图标" class="headerlink" title="10.当echarts图表没出来时显示加载图标"></a>10.当echarts图表没出来时显示加载图标</h3><p>by 2018-09-06 22:23:21<br>在发起请求之前先显示Loading<br>请求返回成功之后隐藏Loading<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">myChart.showLoading();</span><br><span class="line">$.get(&apos;data.json&apos;).done(function (data) &#123;</span><br><span class="line">    myChart.hideLoading();</span><br><span class="line">    myChart.setOption(...);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">myChart.showLoading(&#123;</span><br><span class="line">　　text : &apos;稍等一下&apos;,</span><br><span class="line">　　effect : &apos;dafault&apos;,</span><br><span class="line">maskColor:&apos;rgba(0,0,0,.1)&apos;,</span><br><span class="line">textColor:&apos;#003300&apos;,</span><br><span class="line">color:&apos;#330000&apos;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>effect:loading效果目前只有default</p><h3 id="11-除了点击该容器。点击其他的地方都隐藏"><a href="#11-除了点击该容器。点击其他的地方都隐藏" class="headerlink" title="11.除了点击该容器。点击其他的地方都隐藏"></a>11.除了点击该容器。点击其他的地方都隐藏</h3><p>by 2018-09-09 11:31:51<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$(document).on(&apos;click&apos;, function(e) &#123;</span><br><span class="line">    if($(&quot;.notice-wrapper&quot;).css(&quot;display&quot;) == &quot;block&quot;)&#123;</span><br><span class="line">        var e = e || window.event; //浏览器兼容性 </span><br><span class="line">        var elem = e.target || e.srcElement;</span><br><span class="line">        while (elem) &#123; //循环判断至跟节点，防止点击的是div子元素 </span><br><span class="line">            if (elem.id &amp;&amp; elem.id == &apos;notice_wrapper&apos;) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            elem = elem.parentNode;</span><br><span class="line">        &#125;</span><br><span class="line">        $(&quot;#notice_wrapper&quot;).hide(); //点击的不是div或其子元素 </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>重要的是需要在展开该元素时阻止事件冒泡<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function showNotice(event)&#123;</span><br><span class="line">    if(event &amp;&amp; event.stopPropagation)&#123;</span><br><span class="line">        event.stopPropagation(); </span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        window.event.cancelBubble = true; </span><br><span class="line">    &#125;//兼容</span><br><span class="line">    $(&quot;.notice-wrapper&quot;).show();</span><br><span class="line">    $(&quot;.new-notice&quot;).hide(100);</span><br><span class="line">    showInfoList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="12-父页面控制iframe的触发事件？"><a href="#12-父页面控制iframe的触发事件？" class="headerlink" title="12.父页面控制iframe的触发事件？"></a>12.父页面控制iframe的触发事件？</h3><p>by 2018-09-09 11:31:51<br>没找到办法，最后只能在每一个iframe页面里加上下面这段代码来控制点击空白的时候隐藏11的容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(document).on(&apos;click&apos;, function(e) &#123;</span><br><span class="line">    var $noticeWrapper = $(&quot;#notice_wrapper&quot;,parent.document);</span><br><span class="line">    if($noticeWrapper.css(&quot;display&quot;) == &quot;block&quot;)&#123;</span><br><span class="line">        $noticeWrapper.hide(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="13-滚动隐藏滚动条"><a href="#13-滚动隐藏滚动条" class="headerlink" title="13.滚动隐藏滚动条"></a>13.滚动隐藏滚动条</h3><p>by 2018-09-09 11:31:51<br>在容器外面再嵌套一层 overflow:hidden 内部内容再限制尺寸和外部嵌套层一样，就变相隐藏了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;outer-container&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;inner-container&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;content&quot;&gt;</span><br><span class="line">            ···</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.outer-container,.content &#123;</span><br><span class="line">    width: 200px; height: 200px;</span><br><span class="line">&#125;</span><br><span class="line">.outer-container &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">&#125;</span><br><span class="line">.inner-container &#123;</span><br><span class="line">    position: absolute; left: 0;</span><br><span class="line">    overflow-x: hidden;</span><br><span class="line">    overflow-y: scroll;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总共要有3层包装，第一层：设置宽高，超出内容隐藏，相对定位<br>第二层：设置滚动，绝对定位<br>第三层：设置宽高</p><h3 id="14-给三角形增加边框"><a href="#14-给三角形增加边框" class="headerlink" title="14.给三角形增加边框"></a>14.给三角形增加边框</h3><p>by 2018-09-09 11:31:51<br>设想一：在之前使用的css写的三角形的基础上加上边框？<br>结论：不行，因为之前的三角形就是用border属性来实现的<br>设想二：下载个三角形的png图片，然后给图片加上边框<br>结论：不行，图片都是正方形的。虽然空白地方没有颜色，但是还是存在的。得到的边框会是一个正方形</p><p>百度出来的结果：<a href="https://www.jb51.net/css/76714.html" target="_blank" rel="noopener">https://www.jb51.net/css/76714.html</a><br>使用字符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;demo1&quot;&gt;</span><br><span class="line">&lt;em&gt;&amp;#9670;&lt;/em&gt;</span><br><span class="line">&lt;span&gt;&amp;#9670;&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*&#123;margin:0;padding:0;&#125;</span><br><span class="line">.demo1&#123;width:300px;border:1px solid red;height:100px;&#125;</span><br><span class="line">.demo1 em,.demo1 span&#123;display:block;width:30px;height:16px;font-size:30px;overflow:hidden;_position:relative;margin-left:10px;&#125;</span><br><span class="line">.demo1 em&#123;margin-top:-16px;color:red;font-style:normal;&#125;</span><br><span class="line">.demo1 span&#123;margin-top:-14px;color:white;&#125;</span><br></pre></td></tr></table></figure><h3 id="15-JSON-parse-text-reviver"><a href="#15-JSON-parse-text-reviver" class="headerlink" title="15.JSON.parse(text[, reviver])"></a>15.JSON.parse(text[, reviver])</h3><p>by 2018-09-13 22:11:47<br>text:必需， 一个有效的 JSON 字符串。<br>reviver: 可选，一个转换结果的函数， 将为对象的每个成员调用此函数。<br>返回给定 JSON 字符串转换后的对象。</p><p>若报以下错误：<br><img src="/images/9-13小结/1.jpg"></p><p><font color="red">只支持ie8及其以上的版本，ie7不支持</font><br>解决方法:<br>1.css hack语法:    gt:大于   lt:小于  gte:大于或等于  lte:小于或等于<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--[if lte IE 7]&gt;</span><br><span class="line">     &lt;script src=&quot;json2.js&quot;&gt;&lt;/script&gt;    </span><br><span class="line">&lt;![endif]--&gt;//当浏览器小于IE7以下的版本才引入 json2.js</span><br></pre></td></tr></table></figure></p><p>json2地址：<a href="https://github.com/douglascrockford/JSON-js/blob/master/json2.js" target="_blank" rel="noopener">https://github.com/douglascrockford/JSON-js/blob/master/json2.js</a></p><ol start="2"><li>eval方式解析，恐怕这是最早的解析方式了。如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function strToJson(str)&#123;</span><br><span class="line">var json = eval(&apos;(&apos; + str + &apos;)&apos;);</span><br><span class="line">return json;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>此函数虽让强大,但不推荐使用.因为容易受到XSS攻击,就是向你的网页注入一段恶意代码，你的网页会执行这段代码，这就叫XSS攻击</p><h3 id="16-ie的路径中文参数需要转码"><a href="#16-ie的路径中文参数需要转码" class="headerlink" title="16.ie的路径中文参数需要转码"></a>16.ie的路径中文参数需要转码</h3><p>by 2018-09-13 22:11:47<br>只有参数需要转码，路径中的中文文件名是不需要转码的<br>比如<code>http://localhost:4000/2018/09/13/9-13小结</code><br>在ie下的路径也是<code>http://localhost:4000/2018/09/13/9-13小结</code></p><p><code>http://39.105.43.202:8088/#/big/company?id=0c1eac83a44942ebbbec5ec6ca356b55&amp;name=公司简介</code><br><code>http://39.105.43.202:8088/#/big/company?id=0c1eac83a44942ebbbec5ec6ca356b55&amp;name=%E5%85%AC%E5%8F%B8%E7%AE%80%E4%BB%8B</code><br>转码使用的函数encodeURI<br>例如：<code>var name = encodeURI(name)</code></p><h3 id="17-获得路径中的参数"><a href="#17-获得路径中的参数" class="headerlink" title="17.获得路径中的参数"></a>17.获得路径中的参数</h3><p>by 2018-09-13 22:11:47<br>1).只针对英文数字。若参数是中文的话会出现乱码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function getUrlParam(name) &#123;</span><br><span class="line">var reg = new RegExp(&quot;(^|&amp;)&quot; + name + &quot;=([^&amp;]*)(&amp;|$)&quot;); //构造一个含有目标参数的正则表达式对象 </span><br><span class="line">//得到结果：`/(^|&amp;)name=([^&amp;]*)(&amp;|$)/`</span><br><span class="line">var r = window.location.search.substr(1).match(reg);  //匹配目标参数</span><br><span class="line">if (r != null) return unescape(r[2]); </span><br><span class="line">return null; //返回参数值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>解析：<code>|</code>    指明两项之间的一个选择。<br><code>window.location.search</code> 从问号 (?) 开始的 URL（查询部分）<br><code>substr(1)</code> 去掉问号 (?)<br><code>.match(reg)</code> 返回以下结果<br><img src="/images/9-13小结/2.png"><br>注释：ECMAScript v3 已从标准中删除了 unescape() 函数，并反对使用它，因此应该用 decodeURI() 和 decodeURIComponent() 取而代之。</p><p>2).可以获取到中文的。不出现乱码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function getUrlParam(name) &#123;</span><br><span class="line">    // 获取参数</span><br><span class="line">    var url = window.location.search;</span><br><span class="line">    // 正则筛选地址栏</span><br><span class="line">    var reg = new RegExp(&quot;(^|&amp;)&quot; + name + &quot;=([^&amp;]*)(&amp;|$)&quot;);</span><br><span class="line">    // 匹配目标参数</span><br><span class="line">    var result = url.substr(1).match(reg);</span><br><span class="line">    //返回参数值</span><br><span class="line">    return result ? decodeURIComponent(result[2]) : null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="18-background-size属性只支持ie9及其以上的版本。"><a href="#18-background-size属性只支持ie9及其以上的版本。" class="headerlink" title="18.background-size属性只支持ie9及其以上的版本。"></a>18.background-size属性只支持ie9及其以上的版本。</h3><p>by 2018-09-13 22:11:47<br>参考：<a href="https://segmentfault.com/a/1190000002433305" target="_blank" rel="noopener">https://segmentfault.com/a/1190000002433305</a></p><h3 id="19-httpXMl-open-发送参数是直接拼接在url后面的（不管是post还是get）。"><a href="#19-httpXMl-open-发送参数是直接拼接在url后面的（不管是post还是get）。" class="headerlink" title="19.httpXMl.open()发送参数是直接拼接在url后面的（不管是post还是get）。"></a>19.httpXMl.open()发送参数是直接拼接在url后面的（不管是post还是get）。</h3><p>by 2018-09-13 22:11:47<br><code>xmlhttp.open(&quot;POST&quot;, baseUrl+&quot;api/content/getContentInfo?tColId=21e0a0a7429c4ec88c079e2c3ea1a45c&quot;, true);</code></p><h3 id="20-2-0以上版本的jQuery已经不再支持IE8及以下版本的IE浏览器"><a href="#20-2-0以上版本的jQuery已经不再支持IE8及以下版本的IE浏览器" class="headerlink" title="20.2.0以上版本的jQuery已经不再支持IE8及以下版本的IE浏览器"></a>20.2.0以上版本的jQuery已经不再支持IE8及以下版本的IE浏览器</h3><p>by 2018-09-13 22:11:47</p><h3 id="21-对数字进行切割"><a href="#21-对数字进行切割" class="headerlink" title="21.对数字进行切割"></a>21.对数字进行切割</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function setNum(j) &#123;</span><br><span class="line">    var j = parseInt(j);</span><br><span class="line">    var arr = new Array();</span><br><span class="line">    var i = 0;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        arr[i] = j % 10;</span><br><span class="line">        j = parseInt(j / 10);</span><br><span class="line">        if (j == 0) break;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    var rarr = new Array();</span><br><span class="line">    var len = arr.length - 1;</span><br><span class="line">    for (var y = 0; len &gt;= 0; len--, y++) &#123;</span><br><span class="line">        rarr[y] = arr[len];</span><br><span class="line">    &#125;</span><br><span class="line">    return rarr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路：先将数字逐个分开。然后再倒序排列数字</p><p><font color="red">日常小叨</font>:  09.06：今天和组长一起下班，他说我过了中秋应该就可以提前转正，开心。但是今天又忘记打卡了（笑哭）。</p>]]></content>
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>2018.12工作日总结</title>
      <link href="/2019/05/22/2018-12%E5%B7%A5%E4%BD%9C%E6%97%A5%E6%80%BB%E7%BB%93/"/>
      <url>/2019/05/22/2018-12%E5%B7%A5%E4%BD%9C%E6%97%A5%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>以下内容都是在工作中遇到然后发现自己不是很理解或者是觉得很有意思的点。<br><a id="more"></a></p><h3 id="1-vue的this并不是jQuery中的this"><a href="#1-vue的this并不是jQuery中的this" class="headerlink" title="1.vue的this并不是jQuery中的this"></a>1.vue的this并不是jQuery中的this</h3><p>by 2018-11-20<br>在Vue所有的生命周期钩子方法（如created，mounted， updated以及destroyed）里使用this，<font color="red">this指向调用它的Vue实例</font>。<br>在vue中想要找到某个元素需要使用<code>event.currentTarget$(event.currentTarget).parent(&#39;.bottom-describe&#39;).siblings(el).hide(500);</code><br><b>扩展</b>：<a href="https://majing.io/posts/10000005341170" target="_blank" rel="noopener">https://majing.io/posts/10000005341170</a><br>解析：1.created函数为vue实例的钩子方法，它里面使用的this指的是vue实例。<br>2.对于普通函数（包括匿名函数），this指的是直接的调用者，在非严格模式下，如果没有直接调用者，this指的是window。showMessage1()里setTimeout使用了匿名函数，this指向window。<br>3.箭头函数是没有自己的this，在它内部使用的this是由它定义的宿主对象决定。showMessage2()里定义的箭头函数宿主对象为vue实例，所以它里面使用的this指向vue实例。<br>4.对setTimeout()里的匿名函数使用bind()绑定到vue实例的this。这样在匿名函数内的this也为vue实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">showMessage1:function()&#123;</span><br><span class="line">    setTimeout(function() &#123;</span><br><span class="line">       document.getElementById(&quot;id1&quot;).innerText = &apos;我是showMessage1=普通函数&apos;+this.message;</span><br><span class="line">    &#125;.bind(this), 10)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>或者把vue实例的this赋值给另一个变量再使用</p><h3 id="2-定位"><a href="#2-定位" class="headerlink" title="2.定位"></a>2.定位</h3><p>by 2018-12-07<br>地理位置（Geolocation）是 HTML5 的重要特性之一，提供了确定用户位置的功能，借助这个特性能够开发基于位置信息的应用，获取浏览器经纬度。若要获取具体的省市区信息的话，需要百度接口来转化。</p><h3 id="3-jQuery实现流程进度显示"><a href="#3-jQuery实现流程进度显示" class="headerlink" title="3.jQuery实现流程进度显示"></a>3.jQuery实现流程进度显示</h3><p>by 2018-12-10<br>jquery.easing.js是个好东西，各种动画效果扩展，加强和丰富了jquery自带的各种动画函数<br>box点击就会像移动出弹簧效果，$(obj).animate(目前状态，时间，效果，回调函数)<br>jquery.easing.js扩展了效果函数。</p><h3 id="4-iframe的父元素中有元素的位置在iframe框架里面，显示不出来"><a href="#4-iframe的父元素中有元素的位置在iframe框架里面，显示不出来" class="headerlink" title="4.iframe的父元素中有元素的位置在iframe框架里面，显示不出来"></a>4.iframe的父元素中有元素的位置在iframe框架里面，显示不出来</h3><p>by 2018-12-13<br><img src="/images/2018.12工作日总结/3.png"></p><h3 id="5-滑动"><a href="#5-滑动" class="headerlink" title="5.滑动"></a>5.滑动</h3><p>by 2018-12-13</p><p><font color="red">上下滑动</font>：slideDown/slideUp<br>slideUp和slideDown可以控制向上滑动或者向下滑动。根据<code>.css(&#39;display&#39;) == &#39;none&#39;;</code>来判断当前是否隐藏<br>默认从上到下滑动显示。想要从下向上显示可以让该元素的<code>bottom:0;</code></p><p><font color="red">左右滑动</font>：<code>animate({width:XX})</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var width = $(&apos;.info-wrapper&apos;).width();</span><br><span class="line">if(width == 0)&#123;</span><br><span class="line">    $(&apos;.info-wrapper&apos;).animate(&#123;width:&quot;268&quot;&#125;,300);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    $(&apos;.info-wrapper&apos;).animate(&#123;width:&quot;0&quot;&#125;,300);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="6-key值不唯一报错"><a href="#6-key值不唯一报错" class="headerlink" title="6.key值不唯一报错"></a>6.key值不唯一报错</h3><p>by 2018-12-17<br><img src="/images/2018.12工作日总结/1.png"><br><img src="/images/2018.12工作日总结/2.png"></p><h3 id="7-vue中给data对象-包括数组-新增属性，并不会主动触发视图更新"><a href="#7-vue中给data对象-包括数组-新增属性，并不会主动触发视图更新" class="headerlink" title="7.vue中给data对象(包括数组)新增属性，并不会主动触发视图更新"></a>7.vue中给data对象(包括数组)新增属性，并不会主动触发视图更新</h3><p>by 2018-12-18<br>数组更新了数据，view层未渲染，但通过console这个数组可以发现数据确实更新了。<br>原因是：受 ES5 的限制，Vue.js 不能检测到对象属性的添加或删除。因为 Vue.js 在初始化实例时将属性转为 getter/setter，所以属性必须在 data 对象上才能让 Vue.js 转换它，才能让它是响应的。(新增加的属性不在data)<br><img src="/images/2018.12工作日总结/4.png"><br>使用$set()方法，既可以新增属性,又可以触发视图更新。<br>使用方法：<code>this.$set(this.data,&#39;key&#39;,&#39;value&#39;)；</code><br>实际使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (this.isClickList[index]) &#123;</span><br><span class="line">this.$set(this.isClickList, index, false);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">this.$set(this.isClickList, index, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><font color="red">扩展：</font>尽管 Vue.js 提供了 API 动态地添加响应属性，还是推荐在 data 对象上声明所有的响应属性。<br>这么做有两个原因：<br>1.data 对象就像组件状态的模式（schema）。在它上面声明所有的属性让组件代码更易于理解。<br>2.<b>添加一个顶级响应属性会强制所有的 watcher 重新计算</b>，因为它之前不存在，没有 watcher 追踪它。这么做性能通常是可以接受的，但是可以在初始化时避免。</p><h3 id="8-苹果手机使用浏览器在点击了select之后，页面会出现扩大现象，要用户主动缩小才能回到原始的页面大小。"><a href="#8-苹果手机使用浏览器在点击了select之后，页面会出现扩大现象，要用户主动缩小才能回到原始的页面大小。" class="headerlink" title="8.苹果手机使用浏览器在点击了select之后，页面会出现扩大现象，要用户主动缩小才能回到原始的页面大小。"></a>8.苹果手机使用浏览器在点击了select之后，页面会出现扩大现象，要用户主动缩小才能回到原始的页面大小。</h3><p>by 2018-12-18<br>在meta中添加<code>user-scalable=no</code>，禁止页面缩放</p><h3 id="9-ios设备表单按钮自带样式问题"><a href="#9-ios设备表单按钮自带样式问题" class="headerlink" title="9.ios设备表单按钮自带样式问题"></a>9.ios设备表单按钮自带样式问题</h3><p>by 2018-12-18</p><p><font color="red">问题描述</font>：苹果手机会对form表单元素有一个默认的样式问题，比如input元素顶部会有一个阴影，select有一个渐变的背景，input[type=’submit’]的会有改变按钮的背景颜色和增加一个圆角。<br>使用<code>input,textarea,select{ -webkit-appearance: none; }</code>来去除样式问题。<br><b>注：</b><br>appearance 属性允许您使元素看上去像标准的用户界面元素。<br>所有主流浏览器都不支持 appearance 属性。<br>Firefox 支持替代的 <code>-moz-appearance</code> 属性。<br>Safari 和 Chrome 支持替代的 <code>-webkit-appearance</code> 属性。</p><h3 id="10-验证电话"><a href="#10-验证电话" class="headerlink" title="10.验证电话"></a>10.验证电话</h3><p>by 2018-12-18<br>手机：<code>/^1[0-9]{10}$/.test(phone)</code><br>固话：<code>/^0\d{2,3}-?\d{7,8}$/.test(phone)</code><br><b>解析：</b><br><code>^</code> 匹配输入字符串的开始位置<br><code>[a-z]</code> 字符范围。匹配指定范围内的任意字符<br><code>{n}</code> 匹配确定的 n 次。<br><code>$</code>    匹配输入字符串的结束位置</p><p><code>\d</code> 匹配一个数字字符。等价于 [0-9]。<br><code>{n,m}</code> 最少匹配 n 次且最多匹配 m 次。<br><code>?</code> 匹配前面的子表达式零次或一次。</p><p>同时验证一个输入框内是手机和固定电话。逻辑：先验证是否为手机号码，若不是则验证是否为固话。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if(!(/^1[0-9]&#123;10&#125;$/.test(phone)))&#123;</span><br><span class="line">    if((/^0\d&#123;2,3&#125;-?\d&#123;7,8&#125;$/.test(phone)))&#123;</span><br><span class="line">        $(&quot;#phone-require&quot;).text(&apos;&apos;);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        $(&quot;#phone-require&quot;).text(&apos;请输入正确的电话&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    $(&quot;#phone-require&quot;).text(&apos;&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="11-省市区级联。使用distpicker插件，在初始化之后会生成一个实例，想要手动对distpicker进行赋值，需要先摧毁之前的实例。之后再重新生成一个新的实例"><a href="#11-省市区级联。使用distpicker插件，在初始化之后会生成一个实例，想要手动对distpicker进行赋值，需要先摧毁之前的实例。之后再重新生成一个新的实例" class="headerlink" title="11.省市区级联。使用distpicker插件，在初始化之后会生成一个实例，想要手动对distpicker进行赋值，需要先摧毁之前的实例。之后再重新生成一个新的实例"></a>11.省市区级联。使用distpicker插件，在初始化之后会生成一个实例，想要手动对distpicker进行赋值，需要先摧毁之前的实例。之后再重新生成一个新的实例</h3><p>by 2018-12-18<br>参考：<a href="http://www.jq22.com/jquery-info8054?_t=t" target="_blank" rel="noopener">http://www.jq22.com/jquery-info8054?_t=t</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var provinceCode = 340000;</span><br><span class="line">var cityCode = 340700;</span><br><span class="line">$(&quot;#distpicker&quot;).distpicker(&apos;destroy&apos;);</span><br><span class="line">$(&quot;#distpicker&quot;).distpicker(&#123;</span><br><span class="line">  province: ChineseDistricts[&apos;86&apos;][provinceCode],</span><br><span class="line">  city: ChineseDistricts[provinceCode][cityCode],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>注：没有赋值的区会自动取第一个</p><h3 id="12-iframe滚动条相关内容"><a href="#12-iframe滚动条相关内容" class="headerlink" title="12.iframe滚动条相关内容"></a>12.iframe滚动条相关内容</h3><p>by 2018-12-19<br>如果iframe的scrolling属性设置为no,则不出现滚动条(不可滚动)。在控制台中调整<code>scrolling=auto/yes</code>也不再出现滚动条<br>但是滚动条出现和不出现还受子页面中的HTML和body元素的overflow属性影响，若iframe中的<code>scrolling=auto</code>，但是子HTML或者子body的<code>overflow：hidden</code>，页面还是不会滚动。反之亦然<br>若iframe中的<code>scrolling=no</code>，但是子body的<code>overflow：scroll</code>，页面还是会滚动。</p><h3 id="13-vertical-align的默认值为baseline-img也是"><a href="#13-vertical-align的默认值为baseline-img也是" class="headerlink" title="13.vertical-align的默认值为baseline(img也是)"></a>13.vertical-align的默认值为baseline(img也是)</h3><p>by 2018-12-21<br>各个元素中最下面的baseline为基准，就是说谁的baseline在最下面，就以谁的baseline为基准进行对齐。所以说<b>图片和下面的元素之间有一道缝</b>或者<b>图片改变了文字的行高</b>。<br>解决方法:可以将img的<code>float：left</code>。或者设置<code>display:block</code></p><h3 id="14-将图片固定在右侧"><a href="#14-将图片固定在右侧" class="headerlink" title="14.将图片固定在右侧"></a>14.将图片固定在右侧</h3><p>by 2018-12-21<br><code>background: url(../images/nav_dian2.png) right center no-repeat;</code></p><h3 id="15-url参数为数组时怎么发送"><a href="#15-url参数为数组时怎么发送" class="headerlink" title="15.url参数为数组时怎么发送"></a>15.url参数为数组时怎么发送</h3><p>by 2018-12-21<br><code>?links[]=http://www.baidu.com&amp;links[]=http://www.google.cn</code><br><code>[&quot;http://www.baidu.com&quot;,&quot;http://www.google.cn&quot;]</code></p><h3 id="16-英文的单词宽度无法预测"><a href="#16-英文的单词宽度无法预测" class="headerlink" title="16.英文的单词宽度无法预测"></a>16.英文的单词宽度无法预测</h3><p>by 2018-12-22<br>只能对英文字母的空白符和每个字母的间距作调整</p><h3 id="17-之前的accept属性设置的上面注释的那个。PC端可以上传图片。手机端苹果可以，安卓不可以。然后设成了下面这个属性。然后就奇迹般的可以了，这坑爹的。。还以为是兼容性的问题"><a href="#17-之前的accept属性设置的上面注释的那个。PC端可以上传图片。手机端苹果可以，安卓不可以。然后设成了下面这个属性。然后就奇迹般的可以了，这坑爹的。。还以为是兼容性的问题" class="headerlink" title="17.之前的accept属性设置的上面注释的那个。PC端可以上传图片。手机端苹果可以，安卓不可以。然后设成了下面这个属性。然后就奇迹般的可以了，这坑爹的。。还以为是兼容性的问题"></a>17.之前的accept属性设置的上面注释的那个。PC端可以上传图片。手机端苹果可以，安卓不可以。然后设成了下面这个属性。然后就奇迹般的可以了，这坑爹的。。还以为是兼容性的问题</h3><p>by 2018-12-25<br><code>accept=&quot;image/*&quot;</code><br><img src="/images/2018.12工作日总结/5.png"><br>accept 属性只能与 <code>&lt;input type=&quot;file&quot;&gt;</code> 配合使用。它规定能够通过文件上传进行提交的文件类型。</p><h3 id="18-jq的this"><a href="#18-jq的this" class="headerlink" title="18.jq的this"></a>18.jq的this</h3><p>by 2018-12-27<br>获取一个元素的className<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">this.className == &apos;self-menu-up&apos;</span><br><span class="line">console.log(document.getElementById(&apos;myDiv&apos;));</span><br><span class="line">console.log(this);</span><br><span class="line">console.log($(this));</span><br></pre></td></tr></table></figure></p><p><img src="/images/2018.12工作日总结/6.png"></p><h3 id="19-在input框中有时想将输入的字和placeholder设为不同的颜色或其它效果，这时就可以用以下代码来对placeholder进行样式设置了。"><a href="#19-在input框中有时想将输入的字和placeholder设为不同的颜色或其它效果，这时就可以用以下代码来对placeholder进行样式设置了。" class="headerlink" title="19.在input框中有时想将输入的字和placeholder设为不同的颜色或其它效果，这时就可以用以下代码来对placeholder进行样式设置了。"></a>19.在input框中有时想将输入的字和placeholder设为不同的颜色或其它效果，这时就可以用以下代码来对placeholder进行样式设置了。</h3><p>by 2018-12-28<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">::-webkit-input-placeholder&#123;&#125;    /* 使用webkit内核的浏览器 */</span><br><span class="line">:-moz-placeholder&#123;&#125;                  /* Firefox版本4-18 */</span><br><span class="line">::-moz-placeholder&#123;&#125;                  /* Firefox版本19+ */</span><br><span class="line">:-ms-input-placeholder&#123;&#125;           /* IE浏览器 */</span><br></pre></td></tr></table></figure></p><p>注1：冒号前写对应的input或textarea元素等。<br>注2：placeholder属性是css3中新增加的属性，IE9和Opera12以下版本的CSS选择器均不支持占位文本。</p><h3 id="20-hasClass-方法检查被选元素是否包含指定的-class。返回true或者false"><a href="#20-hasClass-方法检查被选元素是否包含指定的-class。返回true或者false" class="headerlink" title="20.hasClass() 方法检查被选元素是否包含指定的 class。返回true或者false"></a>20.hasClass() 方法检查被选元素是否包含指定的 class。返回true或者false</h3><p>by 2018-12-29<br><code>$(&quot;p:first&quot;).hasClass(&quot;intro&quot;)</code></p><h3 id="21-FastClick-attach-document-body-是什么意思"><a href="#21-FastClick-attach-document-body-是什么意思" class="headerlink" title="21.FastClick.attach(document.body);是什么意思"></a>21.<code>FastClick.attach(document.body);</code>是什么意思</h3><p>by 2018-12-29<br>移动端页面对于点击事件会有300毫秒的延迟，也就是js捕获click事件的回调函数处理，需要300ms后才生效，导致多数用户感觉移动设备上基于HTML的web应用界面响应速度慢，甚至有时候会影响一些业务逻辑的处理。为什么这么设计呢？ 因为它想看看你是不是要进行双击（double tap）操作。<br><b>使用：必须在页面所有Element之前加载脚本文件先实例化fastclick</b><br>`$(function() {FastClick.attach(document.body);});</p><p>FastClick 是 FT Labs 专门为解决移动端浏览器 300 毫秒点击延迟问题所开发的一个轻量级的库。简而言之，FastClick 在检测到touchend事件的时候，会通过 DOM 自定义事件立即触发一个模拟click事件，并把浏览器在 300 毫秒之后真正触发的click事件阻止掉。</p><h3 id="22-如何设置单页面中vue的背景"><a href="#22-如何设置单页面中vue的背景" class="headerlink" title="22.如何设置单页面中vue的背景"></a>22.如何设置单页面中vue的背景</h3><p>by 2019-1-4<br>给页面的容器设置<code>position: fixed;height: 100%;width: 100%;</code></p><h3 id="23-window-onscroll-function-在created中使用"><a href="#23-window-onscroll-function-在created中使用" class="headerlink" title="23.window.onscroll = function() {}在created中使用"></a>23.window.onscroll = function() {}在created中使用</h3><p>by 2019-1-8<br>问题：在myOrder我的订单页点击查看详情，如果在详情页触发滚动。返回我的订单页面的时候会加载两次列表。<br>原因：<code>window.onscroll = function() {}</code>会再一次触发加载列表内容。<br>window.onscroll函数是绑定在window对象下面的。没有在 <font color="red">beforeDestroy </font>的时候解除事件绑定。所以在进入详情页的时候onscroll还存在window中，滚动就会触发该函数。<br><img src="/images/2018.12工作日总结/7.png"></p><h3 id="24-有些手机端输入框会被输入法遮住。输入框收回之后页面会出现空白。"><a href="#24-有些手机端输入框会被输入法遮住。输入框收回之后页面会出现空白。" class="headerlink" title="24.有些手机端输入框会被输入法遮住。输入框收回之后页面会出现空白。"></a>24.有些手机端输入框会被输入法遮住。输入框收回之后页面会出现空白。</h3><p>by 2019-1-8<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var bfscrolltop;</span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">  bfscrolltop = document.body.scrollTop;//网页被卷去的高</span><br><span class="line">&#125;, 50);</span><br><span class="line"></span><br><span class="line">window.addEventListener(&quot;click&quot;, function() &#123;</span><br><span class="line">  var interval;</span><br><span class="line">  if (document.activeElement.tagName == &quot;INPUT&quot;) &#123;</span><br><span class="line">    interval = setTimeout(function() &#123;</span><br><span class="line">      document.body.scrollTop = document.body.scrollHeight;//网页正文全文高</span><br><span class="line">    &#125;, 100);</span><br><span class="line">    document.activeElement.addEventListener(&apos;blur&apos;,function()&#123;</span><br><span class="line">      clearInterval(interval);</span><br><span class="line">      document.body.scrollTop = bfscrolltop;</span><br><span class="line">    &#125;)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="25-activeElement-tagName的用法"><a href="#25-activeElement-tagName的用法" class="headerlink" title="25.activeElement,tagName的用法"></a>25.activeElement,tagName的用法</h3><p>by 2019-1-8<br>activeElement 属性返回文档中当前获得焦点的元素。<br>tagName属性返回元素的标签名。注：在 HTML 中，tagName 属性的返回值始终是大写的。</p><h3 id="26-有时候点击orderDetail订单详情页面的预约详情页面进入needDetail预约详情页面会出现空白页。"><a href="#26-有时候点击orderDetail订单详情页面的预约详情页面进入needDetail预约详情页面会出现空白页。" class="headerlink" title="26.有时候点击orderDetail订单详情页面的预约详情页面进入needDetail预约详情页面会出现空白页。"></a>26.有时候点击orderDetail订单详情页面的预约详情页面进入needDetail预约详情页面会出现空白页。</h3><p>by 2019-1-9<br>原因：没有对一些字段进行初始化就判断其<code>.length</code>属性是否<code>!== 0</code>,然后出现报错导致页面没有加载出来。还记得前辈说过一句话，有时候报错会阻塞页面的加载。<br>处理方法：对其进行初始化。其实应该在判断<code>.length !== 0</code>之前判断是否有该属性。</p><h3 id="27-Axios的请求是异步的。没有同步"><a href="#27-Axios的请求是异步的。没有同步" class="headerlink" title="27.Axios的请求是异步的。没有同步"></a>27.Axios的请求是异步的。没有同步</h3><p>by 2019-1-16<br>出现的场景：初始化的时候需要逐步加载级联的东西。<br>解决：写了两遍相同的代码，在then（）里面触发了下次请求<br>目前想到这种方法，待完善。。。</p><h3 id="28-设置不可点击的手型"><a href="#28-设置不可点击的手型" class="headerlink" title="28.设置不可点击的手型"></a>28.设置不可点击的手型</h3><p>by 2019-1-21<br><code>cursor: not-allowed;</code></p><h3 id="29-echarts柱状图的图例太长了导致图例不能滚动"><a href="#29-echarts柱状图的图例太长了导致图例不能滚动" class="headerlink" title="29.echarts柱状图的图例太长了导致图例不能滚动"></a>29.echarts柱状图的图例太长了导致图例不能滚动</h3><p>by 2019-1-21<br>解决办法：限制图例的字数长度<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">legend: &#123;</span><br><span class="line">  type: &quot;scroll&quot;,</span><br><span class="line">  data: [</span><br><span class="line">    &quot;低压柜/低压进线柜P01/低压总开关&quot;,</span><br><span class="line">    &quot;低压柜/低压进线柜P03/宿舍堂用电&quot;,</span><br><span class="line">    &quot;低压柜/低压进线柜P03/车间办公室用电&quot;</span><br><span class="line">  ],</span><br><span class="line">  textStyle: &#123; color: &quot;white&quot; &#125;,</span><br><span class="line">  formatter: function (name) &#123;</span><br><span class="line">    if (!name) return &apos;&apos;;</span><br><span class="line">    if (name.length &gt; 25) &#123;</span><br><span class="line">      return name =  name.slice(0,25) + &apos;...&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  tooltip: &#123;</span><br><span class="line">    show: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="30-让另一个东西随着一个东西的滚动而滚动"><a href="#30-让另一个东西随着一个东西的滚动而滚动" class="headerlink" title="30.让另一个东西随着一个东西的滚动而滚动"></a>30.让另一个东西随着一个东西的滚动而滚动</h3><p>by 2019-1-21<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var right_div2 = document.getElementById(&quot;right_div2&quot;);</span><br><span class="line">right_div2.onscroll = function() &#123;</span><br><span class="line">var right_div2_top = this.scrollTop;</span><br><span class="line">var right_div2_left = this.scrollLeft;</span><br><span class="line">document.getElementById(&quot;left_div2&quot;).scrollTop = right_div2_top;</span><br><span class="line">document.getElementById(&quot;right_div1&quot;).scrollLeft = right_div2_left;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="31-vue的树形结构的绑定"><a href="#31-vue的树形结构的绑定" class="headerlink" title="31.vue的树形结构的绑定"></a>31.vue的树形结构的绑定</h3><p>by 2019-1-22<br>参考：<a href="https://blog.csdn.net/badmoonc/article/details/80380557" target="_blank" rel="noopener">https://blog.csdn.net/badmoonc/article/details/80380557</a><br>name属性的使用（你可以把它当作从import导入了一个组件并注册，我们在temlpate可以使用<code>&lt;tree-menus&gt;&lt;/tree-menus&gt;</code>使用子组件自身进行递归了）</p><h3 id="32-vue的祖孙关系点击"><a href="#32-vue的祖孙关系点击" class="headerlink" title="32.vue的祖孙关系点击"></a>32.vue的祖孙关系点击</h3><p>by 2019-1-22<br>父组件只能通过子组件的<code>this.$emit(&#39;clickchild&#39;,&#39;true&#39;);</code>来监测事件<br>不能监测孙组件的事件<br>目前只找到这种说法。待完善。。</p><p><b>扩展：</b>但是有要注意的点：<br>子组件接受的父组件的值分为——引用类型和普通类型两种，<br>普通类型：字符串（String）、数字（Number）、布尔值（Boolean）、空（Null）<br>引用类型：数组（Array）、对象（Object）<br>其中，普通类型是可以在子组件中更改，不会影响其他兄弟子组件内同样调用的来自父组件的值，<br>但是，引用类型的值，当在子组件中修改后，父组件的也会修改，那么后果就是，其他同样引用了改值的子组件内部的值也会跟着被修改。除非你有特殊的要求这么去做，否则最好不要这么做。<br>因其数据是公用的，改了所有引用的子组件就都改了。</p><h3 id="33-iframe的高度"><a href="#33-iframe的高度" class="headerlink" title="33.iframe的高度"></a>33.iframe的高度</h3><p>by 2019-1-23<br>老是差4个像素。最后发现div和iframe是有不同的。div的时候算的正常，页面无滚动条，iframe就有。<br>问题原因：使用了HTML5的头部，在使用如下两个头部声明时会使iframe不能填满div，<br>解决方法：<code>display:block;</code>或者<code>vertical-align:bottom;</code><br>其中<code>vertical-align:bottom;</code>表示把元素的顶端与行中最低的元素的顶端对齐。即是以元素底线作为与父元素垂直对齐的基线。<br><code>display:block;</code>表示将元素转换为块级元素。iframe本身是一个内联框架，他本身是从div中分出了一部分空间，作为自己的空间，而将其转换为块级对象时，他就会自己从新的一行开始显示内容，而不依赖于div。</p><h3 id="34-vue-不支持iE8及更低版本"><a href="#34-vue-不支持iE8及更低版本" class="headerlink" title="34.vue 不支持iE8及更低版本"></a>34.vue 不支持iE8及更低版本</h3><p>by 2019-5-23<br>把一个普通对象传给 Vue 实例作为它的 data 选项，Vue.js 将遍历它的属性，用 Object.defineProperty 将它们转为 getter/setter。这是 ES5 特性，不能打补丁实现，这便是为什么 Vue.js 不支持 IE8 及更低版本。</p><h3 id="35-使用微信的定位"><a href="#35-使用微信的定位" class="headerlink" title="35.使用微信的定位"></a>35.使用微信的定位</h3><p>by 2019-1-4<br>需要先初始化wx.config才能调用wx.getLocation函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var wx = window.wx // 微信变量</span><br><span class="line">// 获取微信配置</span><br><span class="line">this.$http.post(&apos;/jsConfig/getConfig&apos;, Qs.stringify(&#123;url: url&#125;)).then(response =&gt; &#123;</span><br><span class="line">  wx.config(&#123;</span><br><span class="line">    debug: false, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。</span><br><span class="line">    appId: response.data.data.appId, // 必填，企业号的唯一标识，此处填写企业号corpid</span><br><span class="line">    timestamp: response.data.data.timestamp, // 必填，生成签名的时间戳</span><br><span class="line">    nonceStr: response.data.data.nonceStr, // 必填，生成签名的随机串</span><br><span class="line">    signature: response.data.data.signature, // 必填，签名，见附录1</span><br><span class="line">    jsApiList: response.data.data.jsApiList // 必填，需要使用的JS接口列表，所有JS接口列表见附录2</span><br><span class="line">  &#125;)</span><br><span class="line">  wx.ready(function () &#123;</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line">  wx.error(function (res) &#123;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">wx.getLocation(&#123; </span><br><span class="line">  type: &apos;wgs84&apos;,</span><br><span class="line">  success: function (res) &#123;</span><br><span class="line">    self.lat = res.latitude; // 纬度，浮点数，范围为90 ~ -90</span><br><span class="line">    self.lon = res.longitude; // 经度，浮点数，范围为180 ~ -180。</span><br><span class="line">    callback()//加载列表函数</span><br><span class="line">  &#125;,</span><br><span class="line">  cancel: function (res) &#123;</span><br><span class="line">    self.$vux.toast.show(&#123;</span><br><span class="line">      text: &apos;定位失败，请选择允许获取地理位置&apos;,</span><br><span class="line">      type: &apos;cancel&apos;</span><br><span class="line">    &#125;)</span><br><span class="line">    self.lat=23.075274</span><br><span class="line">    self.lon=113.072914</span><br><span class="line">    callback()</span><br><span class="line">  &#125;,</span><br><span class="line">  fail: function (res) &#123;</span><br><span class="line">    self.lat=23.075274</span><br><span class="line">    self.lon=113.072914</span><br><span class="line">    callback()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>日常小叨：辞职了已经差不多1个月了。不知道我怎么想的还没开始投简历。一直想把上份工作收货整理整理记录下来，但是一直都很懒。总觉得我应该把这件事情做好才能去找工作。所以一直拖拉到了现在。但是这个月自己去交社保，本来以为才500多，没想到要交730多哭唧唧。太贵了。冲着这个社保我下个月都要找到工作的说。<br>这份工作日小结是在去佛山项目组的时候一只记录下来的。然后还有去珠光地铁站那边的。</p>]]></content>
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>vue.js实战饿了吗(1)</title>
      <link href="/2019/03/09/vue-js%E5%AE%9E%E6%88%98%E9%A5%BF%E4%BA%86%E5%90%97-1/"/>
      <url>/2019/03/09/vue-js%E5%AE%9E%E6%88%98%E9%A5%BF%E4%BA%86%E5%90%97-1/</url>
      <content type="html"><![CDATA[<p>之前看过一整遍慕课网的课程《vue.js实战饿了吗》，也跟着将这个app做了出来。但是时隔太久了一些点忘记了。所以再有时间的时候把他重新看一遍，并且整理出来。<br><a id="more"></a></p><h3 id="一-vue-js介绍"><a href="#一-vue-js介绍" class="headerlink" title="一.vue.js介绍"></a>一.vue.js介绍</h3><p><img src="/images/vue.js实战饿了吗(1)/1.png"><br><img src="/images/vue.js实战饿了吗(1)/2.png"><br><img src="/images/vue.js实战饿了吗(1)/3.png"><br><img src="/images/vue.js实战饿了吗(1)/6.png" width="70%"><br><img src="/images/vue.js实战饿了吗(1)/7.png" width="70%"><br><img src="/images/vue.js实战饿了吗(1)/4.png"></p><h3 id="二-vue-cli开启Vuejs项目"><a href="#二-vue-cli开启Vuejs项目" class="headerlink" title="二.vue-cli开启Vuejs项目"></a>二.vue-cli开启Vuejs项目</h3><p><img src="/images/vue.js实战饿了吗(1)/5.png"></p><p><font color="red">.gitkeep文件</font><br>git是不允许提交一个空的目录到版本库上的,可以在空的文件夹里面建立一个.gitkeep文件，然后提交去即可。<br>其实在git中 .gitkeep 就是一个占位符。可以用其他 比如 .nofile等文件作为占位符。</p><h3 id="三-项目实战-准备工作"><a href="#三-项目实战-准备工作" class="headerlink" title="三.项目实战-准备工作"></a>三.项目实战-准备工作</h3>]]></content>
      
      <categories>
          
          <category> vue </category>
          
          <category> vue.js实战饿了吗 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>MUI仿豆瓣电影APP跨平台混编框架</title>
      <link href="/2018/11/23/MUI%E4%BB%BF%E8%B1%86%E7%93%A3%E7%94%B5%E5%BD%B1APP%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%B7%B7%E7%BC%96%E6%A1%86%E6%9E%B6/"/>
      <url>/2018/11/23/MUI%E4%BB%BF%E8%B1%86%E7%93%A3%E7%94%B5%E5%BD%B1APP%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%B7%B7%E7%BC%96%E6%A1%86%E6%9E%B6/</url>
      <content type="html"><![CDATA[<p>一边学一边记录笔记。慕课网的课程《MUI仿豆瓣电影APP跨平台混编框架》。时间隔了这么久也还没学完。。。<br><a id="more"></a><br><img src="/images/MUI仿豆瓣电影APP跨平台混编框架/1.png" width="50%"><br><img src="/images/MUI仿豆瓣电影APP跨平台混编框架/2.png" width="50%"><br><img src="/images/MUI仿豆瓣电影APP跨平台混编框架/3.png" width="50%"><br><img src="/images/MUI仿豆瓣电影APP跨平台混编框架/4.png" width="80%"><br><img src="/images/MUI仿豆瓣电影APP跨平台混编框架/5.png"><br><img src="/images/MUI仿豆瓣电影APP跨平台混编框架/6.png" width="50%"><br><img src="/images/MUI仿豆瓣电影APP跨平台混编框架/7.png" width="40%"><br><img src="/images/MUI仿豆瓣电影APP跨平台混编框架/8.png" width="60%"></p><p>tap就是点击事件<br>批量绑定：有一个列表，当需要绑定每个列表项的时候就可以使用批量绑定<br><img src="/images/MUI仿豆瓣电影APP跨平台混编框架/9.png" width="60%"><br><img src="/images/MUI仿豆瓣电影APP跨平台混编框架/10.png" width="50%"></p>]]></content>
      
      <categories>
          
          <category> MUI </category>
          
          <category> MUI仿豆瓣电影APP跨平台混编框架 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>第九章.如何打包发布</title>
      <link href="/2018/11/23/%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E5%A6%82%E4%BD%95%E6%89%93%E5%8C%85%E5%8F%91%E5%B8%83/"/>
      <url>/2018/11/23/%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E5%A6%82%E4%BD%95%E6%89%93%E5%8C%85%E5%8F%91%E5%B8%83/</url>
      <content type="html"><![CDATA[<p>慕课网视频《所向披靡的响应式开发》第九章的笔记。<br><a id="more"></a><br><img src="/images/第九章-如何打包发布/1.png" width="40%"><br>在线压缩文件：<br><img src="/images/第九章-如何打包发布/2.png" width="40%"><br><img src="/images/第九章-如何打包发布/3.png" width="40%"></p>]]></content>
      
      <categories>
          
          <category> 所向披靡的响应式开发 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>第八章.如何处理兼容性及在多个设备上进行调试</title>
      <link href="/2018/11/22/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%85%BC%E5%AE%B9%E6%80%A7%E5%8F%8A%E5%9C%A8%E5%A4%9A%E4%B8%AA%E8%AE%BE%E5%A4%87%E4%B8%8A%E8%BF%9B%E8%A1%8C%E8%B0%83%E8%AF%95/"/>
      <url>/2018/11/22/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%85%BC%E5%AE%B9%E6%80%A7%E5%8F%8A%E5%9C%A8%E5%A4%9A%E4%B8%AA%E8%AE%BE%E5%A4%87%E4%B8%8A%E8%BF%9B%E8%A1%8C%E8%B0%83%E8%AF%95/</url>
      <content type="html"><![CDATA[<p>慕课网视频《所向披靡的响应式开发》第八章的笔记。<br><a id="more"></a><br>sublime快速定位到某行的快捷键 ctrl+g<br>在IE和版本号中间需要有空格<br><img src="/images/第八章.如何处理兼容性及在多个设备上进行调试/1.png" width="40%"></p><p>在仿真的IE浏览器下测试跟真实的浏览器还是有区别的。所以可以下载虚拟机来测试<br><a href="https://github.com/xidissent/ievms" target="_blank" rel="noopener">https://github.com/xidissent/ievms</a><br><img src="/images/第八章.如何处理兼容性及在多个设备上进行调试/2.png" width="40%"></p><p>安卓虚拟机的测试：<a href="http://www.genymotion.net。有时候需要翻墙" target="_blank" rel="noopener">www.genymotion.net。有时候需要翻墙</a></p><p>browserhacks.com：提供各种浏览器hack的写法</p><p>解决兼容性网站的shiv<br>ie8及其以下的版本是不支持html5标签的<br><img src="/images/第八章.如何处理兼容性及在多个设备上进行调试/3.png" width="40%"></p><p>ie6-8是不支持媒体查询的，为了让ie6-8支持min/max-width<br><img src="/images/第八章.如何处理兼容性及在多个设备上进行调试/4.png" width="40%"></p><p>modernizr是一个js库，会检测浏览器对css3，html5的支持情况，如果浏览器不支持某个属性，就会像该html元素上添加一个以no-开头的类，如果支持就会添加一个相应的类。因为是检测型的js库，所以要放在所有js引入的最前面<br><img src="/images/第八章.如何处理兼容性及在多个设备上进行调试/5.png" width="40%"></p><p><a href="http://www.browsersync.cn：可以在修改代码之后自动刷新页面，可以实现所有的设备同步滚动，同步点击" target="_blank" rel="noopener">www.browsersync.cn：可以在修改代码之后自动刷新页面，可以实现所有的设备同步滚动，同步点击</a></p>]]></content>
      
      <categories>
          
          <category> 所向披靡的响应式开发 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>第七章.Node.js简介</title>
      <link href="/2018/11/22/%E7%AC%AC%E4%B8%83%E7%AB%A0-Node-js%E7%AE%80%E4%BB%8B/"/>
      <url>/2018/11/22/%E7%AC%AC%E4%B8%83%E7%AB%A0-Node-js%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<p>慕课网视频《所向披靡的响应式开发》第七章的笔记。<br><a id="more"></a><br>Node.js是javascript的运行环境，之前的js代码都是运行在浏览器中的，浏览器负责解释和执行代码。浏览器端的js代码在执行的时候会受到各种各样的安全性的限制。会放在一个安全沙箱里面。有很多的功能我们不能用，对客户系统的操作是有限的。node可以安装到很多的系统中，可以编写系统级和服务器端的js代码，之后交给Node.js来解读。这样就可以使用系统级的API，比如文件操作，网络编程，不用受到浏览器的限制。<br>chrome V8引擎使用C++开发的一个js的解释引擎。独立于浏览器环境的。<br>chrome和V8引擎关系：V8引擎一出生就被chrome拿来使用。<br>优点：其他的js引擎都是将js代码转换成字节码，V8引擎会将js代码编译成原生的机器码，会做一系列的优化，运行速度可以媲美二进制的程序。<br>总结起来就是可以在非浏览器的环境下运行js代码，而且速度很快。<br>典型的事件驱动：js有很多的异步编程，依赖于回调函数。<br>非阻塞的IO模型是配合事件驱动来的。比如读取文件的时候，在读取文件的时候可以执行其他的事情，而不会挂起。<br><img src="/images/第七章.Node.js简介/1.png" width="60%"><br><img src="/images/第七章.Node.js简介/2.png" width="40%"><br><img src="/images/第七章.Node.js简介/3.png" width="40%"></p><p>低版本的IE浏览器再打开带有端口号的ip地址的时候需要加上http协议，不然有时候会打不开<br>http-server：Node.js的服务器</p>]]></content>
      
      <categories>
          
          <category> 所向披靡的响应式开发 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>第六章.如何实现响应式广告及响应式图片</title>
      <link href="/2018/11/20/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B9%BF%E5%91%8A%E5%8F%8A%E5%93%8D%E5%BA%94%E5%BC%8F%E5%9B%BE%E7%89%87/"/>
      <url>/2018/11/20/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B9%BF%E5%91%8A%E5%8F%8A%E5%93%8D%E5%BA%94%E5%BC%8F%E5%9B%BE%E7%89%87/</url>
      <content type="html"><![CDATA[<p>慕课网视频《所向披靡的响应式开发》第六章的笔记。<br><a id="more"></a><br><img src="/images/第六章.如何实现响应式广告及响应式图片/1.png" width="60%"><br><img src="/images/第六章.如何实现响应式广告及响应式图片/2.png" width="60%"><br>Owl Carousel图片滚动库：<a href="https://owlcarousel2.github.io/OwlCarousel2/" target="_blank" rel="noopener">https://owlcarousel2.github.io/OwlCarousel2/</a><br>文档：<a href="http://www.dowebok.com/93.html" target="_blank" rel="noopener">http://www.dowebok.com/93.html</a></p><p><img src="/images/第六章.如何实现响应式广告及响应式图片/3.png" width="60%"><br><img src="/images/第六章.如何实现响应式广告及响应式图片/4.png" width="60%"><br><img src="/images/第六章.如何实现响应式广告及响应式图片/6.png" width="40%"><br><img src="/images/第六章.如何实现响应式广告及响应式图片/5.png" width="80%"><br>上面这种方法有一种变种，将屏幕或者设备的信息写进cookie，在获取图片的时候，在服务器端决定返回哪种图片</p><p>浏览器会对当前的页面的大小来自动加载图片的大小<br>sizes默认是100vw<br><img src="/images/第六章.如何实现响应式广告及响应式图片/7.png" width="80%"><br>所有分辨率下给图片所占的比例都是50%<br><img src="/images/第六章.如何实现响应式广告及响应式图片/8.png" width="80%"><br>大于800px的时候，图片的宽度是800px。小于800px的时候图片的宽度是100%<br><img src="/images/第六章.如何实现响应式广告及响应式图片/9.png" width="80%"><br><img src="/images/第六章.如何实现响应式广告及响应式图片/10.png" width="40%"></p><p>也可以使用计算属性，在减号前后要有空格 不然计算属性失效<br><img src="/images/第六章.如何实现响应式广告及响应式图片/11.png" width="80%"></p><p>有时候希望除了缩放之外进行图片的自适应，所以要从浏览器里夺回一些控制权<br>orientation:landscape;横屏模式下的显示的还是小屏幕的图片。手机模式下的横屏。<br><img src="/images/第六章.如何实现响应式广告及响应式图片/12.png" width="80%"><br>svg的图片设置没有太大的意义。webp图片格式只有谷歌和安卓支持。同等质量下大小是jpg的2/3<br><img src="/images/第六章.如何实现响应式广告及响应式图片/13.png" width="100%"></p><p>svg是可缩放的矢量图，可以在线创建svg图片：editor.method.ac或者<a href="https://icomoon.io" target="_blank" rel="noopener">https://icomoon.io</a><br>浏览器对svg的支持比较好，但是色彩比较丰富的图片svg格式的图片不合适，所以要使用位图。使用位图的话就要用到srcset或者picture，所以要用到polyfill，针对picture的polyfill就是picturefill：scottjehl.github.io/picturefill。对不支持picture的浏览器会用js来获取src和媒体查询规则的设置，再通过js来决定输出的图片。<br>使用：在页面中引入picturefill.js即可。<br>picture的source也是不受html的大小控制的，所以em和rem的效果是一样的<br><img src="/images/第六章.如何实现响应式广告及响应式图片/14.png" width="100%"></p><p>svg的图片还是可以再次压缩的：iconizr.com<br>png的图片压缩：<a href="https://tinypng.com" target="_blank" rel="noopener">https://tinypng.com</a></p>]]></content>
      
      <categories>
          
          <category> 所向披靡的响应式开发 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>第五章.如何实现移动端的样式</title>
      <link href="/2018/11/15/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9A%84%E6%A0%B7%E5%BC%8F/"/>
      <url>/2018/11/15/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9A%84%E6%A0%B7%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>慕课网视频《所向披靡的响应式开发》第五章的笔记。<br><a id="more"></a><br>可以按住shift和上下箭头进行调试。以10为单位<br><img src="/images/第五章.如何实现移动端的样式/1.png" width="60%"><br>显示媒体查询，显示标尺<br><img src="/images/第五章.如何实现移动端的样式/2.png" width="40%"></p><p>媒体查询的级别很高，并不是html的一个子元素，不在html级别之下。所以默认的1rem=16px;是相对浏览器而言的。这样的话就没有设置成rem的必要了。可以设置成em。因为rem不是每种浏览器都支持的<br>li+li:兄弟选择器(共选择了后面3个li)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></p><p>li~li:选择li之后的所有li元素(选择了第2个li和第4个li，若是li+li，则才选择了第2个li)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;/li&gt;</span><br><span class="line">&lt;a&gt;&lt;/a&gt;</span><br><span class="line">&lt;li&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></p><p><code>a[href^=&#39;http://&#39;]</code>:href属性以http开头的a元素<br><code>img[src$=&#39;.png&#39;]</code>:src属性以.png结尾的img元素<br><code>img[src*=&#39;.png&#39;]</code>:src属性包含.png的img元素</p><p>1.链接<br>2.表单<br><img src="/images/第五章.如何实现移动端的样式/3.png"></p><p>page-break-inside:avoid;只对欧朋浏览器起作用，避免在内容中插入分页符<br>orphans:3;当元素内部发生分页的时候，必须在页面底部保留的行数<br>widows:3;当元素内部发生分页的时候，必须在页面顶部保留的行数<br>以上两个保证了标题和文字不会分页<br><img src="/images/第五章.如何实现移动端的样式/4.png"><br><img src="/images/第五章.如何实现移动端的样式/5.png"><br><img src="/images/第五章.如何实现移动端的样式/6.png"></p>]]></content>
      
      <categories>
          
          <category> 所向披靡的响应式开发 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>第四章.如何实现PC端的样式</title>
      <link href="/2018/11/13/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0PC%E7%AB%AF%E7%9A%84%E6%A0%B7%E5%BC%8F/"/>
      <url>/2018/11/13/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0PC%E7%AB%AF%E7%9A%84%E6%A0%B7%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>慕课网视频《所向披靡的响应式开发》第四章的笔记。<br><a id="more"></a><br>1.normalize.css消除浏览器之间默认样式的差异<br>2.em和rem<br>rem在iE8和以下的版本是不支持的<br><img src="/images/第四章.如何实现PC端的样式/1.png" width="80%"><br><img src="/images/第四章.如何实现PC端的样式/2.png" width="80%"><br><img src="/images/第四章.如何实现PC端的样式/3.png" width="80%"><br>兼容低版本的ie<br><img src="/images/第四章.如何实现PC端的样式/4.png" width="40%"></p><p>color：#222文本的这个黑色看起来比较舒服<br>::selection{}文本选中的样式<br>清除浮动：</p><ul><li>给浮动容器设置overflow：hidden或者auto</li><li><code>&lt;div style=&quot;clear:both;&quot;&gt;&lt;/div&gt;</code>,不好维护</li><li>给浮动容器也增加浮动，但是影响下一个元素的布局</li><li>跟添加标签是一个原理<br>zoom：1：为ie6，7设置，只有添加之后才能触发hash layout，才能清除浮动<br><img src="/images/第四章.如何实现PC端的样式/5.png" width="40%"></li><li>触发BFC （overflow,float,display:table-cell,inline-block,table-caption,position:absolute,fixed）<br>before防止浏览器顶部的空白奔溃。自己的margin-top和下面元素margin-bottom的叠加<br><img src="/images/第四章.如何实现PC端的样式/6.png" width="40%"></li></ul><p>因为浏览器对中文字号的下限是12px。所以如果设置font-size：65.5%，之后设置的font-size：1rem。但是1rem不等于10px,等于12px。3rem=36px</p><p>li+li：左右两端的导航栏目是没有边线的，不选择第一个元素<br>margin-left：-3px：去除3px的间距<br>还有其他的方法去除3px的边距</p><ul><li>li标签不闭合</li><li>font-size：0</li><li>html代码中去除换行</li><li>css4中有个white-space-collapsing</li></ul><p><img src="/images/第四章.如何实现PC端的样式/7.png" width="40%"><br><img src="/images/第四章.如何实现PC端的样式/8.png" width="40%"></p><p>通过文字的缩进来隐藏文字<br><img src="/images/第四章.如何实现PC端的样式/9.png" width="40%"><br>inset内阴影<br><img src="/images/第四章.如何实现PC端的样式/10.png" width="40%"><br>opacity：0.8：会让容器内的所有元素都变成透明度为0.8<br>background-color：rgba():就是只设置背景颜色的不透明度</p><p>calc():CSS3对长度的计算。<br>-3rem：2rem左右padding。各个块之间1.5rem的间距-&gt;1.5*2/3=1<br>.item+.item：只有后面两个item有padding-left<br><img src="/images/第四章.如何实现PC端的样式/11.png" width="60%"><br>将最新公告用伪元素插入，content中的空格是用<code>\00a0</code>表示<br><img src="/images/第四章.如何实现PC端的样式/12.png" width="60%"><br>增加灰色的滤镜<br><img src="/images/第四章.如何实现PC端的样式/13.png" width="60%"></p>]]></content>
      
      <categories>
          
          <category> 所向披靡的响应式开发 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>第三章.开始编写HTML代码</title>
      <link href="/2018/11/12/%E7%AC%AC%E4%B8%89%E7%AB%A0.%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99HTML%E4%BB%A3%E7%A0%81/"/>
      <url>/2018/11/12/%E7%AC%AC%E4%B8%89%E7%AB%A0.%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99HTML%E4%BB%A3%E7%A0%81/</url>
      <content type="html"><![CDATA[<p>慕课网视频《所向披靡的响应式开发》第三章的笔记。<br><a id="more"></a><br><code>&lt;html lang=&quot;zh-CN&quot;&gt;&lt;/html&gt;</code>:可以不使用引号。zh-CN简体中文<br><img src="/images/第三章.开始编写HTML代码/1.png" width="80%"><br>可以使用lt,gt,lte,gte<br><img src="/images/第三章.开始编写HTML代码/2.png" width="80%"><br><img src="/images/第三章.开始编写HTML代码/3.png" width="40%"><br><img src="/images/第三章.开始编写HTML代码/4.png" width="40%"><br>检测html页面的标签是否使用合理：gsnedders.html5.org/outliner<br>html5规范：section标签最好要有标题。所以检测之后可以把没有标题的section的改为div标签</p>]]></content>
      
      <categories>
          
          <category> 所向披靡的响应式开发 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>第二章.如何组织项目目录结构</title>
      <link href="/2018/11/12/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%A6%82%E4%BD%95%E7%BB%84%E7%BB%87%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/"/>
      <url>/2018/11/12/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%A6%82%E4%BD%95%E7%BB%84%E7%BB%87%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<p>慕课网视频《所向披靡的响应式开发》第二章的笔记。<br><a id="more"></a><br>1.如何组织项目目录结构<br><img src="/images/第二章.如何组织项目目录结构/1.jpg" width="80%"><br>robots.txt文件：搜索引擎访问网站查看的文件。他告诉搜索的爬虫程序在服务器上什么文件可以被查看什么文件不可以被查看。当一个搜索爬虫访问一个网站的时候会先检查该网站的根目录下面是否有robots.txt文件，如果存在就会按照文件来确定搜索的范围，若不存在就会访问网站所有的文件。一般来说网站会有管理页面或者后台页面，不会被搜索引擎抓取。<br>每一种搜索引擎会有自己独特的写法<br><img src="/images/第二章.如何组织项目目录结构/2.png" width="50%"><br>favicon.ico：图标文件，可以通过在线工具进行转换。用于网站的标注，在浏览器的地址栏或者标签显示<br>humans.txt：不是任何协议也没有代码功能。就是文本文件，用来保存网站建设者和一些其他有用的信息。<br>编写格式可以参照：<a href="http://www.humanstxt.org.cn/" target="_blank" rel="noopener">http://www.humanstxt.org.cn/</a></p><p>.editorconfig：是一套统计代码工具解决方案的文件。帮助开发者在不同的编辑器下定义和维护一致的代码风格。他告诉编辑器如何来格式化代码，代码的缩进规则等。所有支持editorconfig的编辑器他们在最后保存文件的时候都会应用editorconfig文件里面的设置。编辑器可以下载插件来支持editorconfig。<br>编写规则，第一行网址。使用#或者；来注释<br>root = true:代表这是最顶层的配置文件。如果发现root = true的话就不会继续查找editorconfig的配置文件了。<br>[*]:代表下面的规则适用于所有的文件<br>insert_final_newline = true：代表使用文件的结尾使用空白行来结尾<br>trim_traniling_whitespace = true：代表去掉换行行首的任意字符<br><img src="/images/第二章.如何组织项目目录结构/3.png" width="80%"></p><p>.gitlgnore：gaihub忽略的文件<br>*~和.DS_Store：MC系统生成的垃圾文件</p><p>LICENSE.txt；代表版权声明和协议内容</p><p><img src="/images/第二章.如何组织项目目录结构/4.png" width="80%"><br><img src="/images/第二章.如何组织项目目录结构/5.png" width="20%"><br><img src="/images/第二章.如何组织项目目录结构/6.png" width="70%"><br>表格内容左对齐，居中对齐,右对齐<br>|—|:—:|—:|<br><img src="/images/第二章.如何组织项目目录结构/7.png" width="80%"></p>]]></content>
      
      <categories>
          
          <category> 所向披靡的响应式开发 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>第一章.前期准备</title>
      <link href="/2018/11/08/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/"/>
      <url>/2018/11/08/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/</url>
      <content type="html"><![CDATA[<p>慕课网视频《所向披靡的响应式开发》第一章的笔记。<br><a id="more"></a><br>1.响应式网站设计的概念<br>网址：<a href="https://alistapart.com/article/responsive-web-design" target="_blank" rel="noopener">https://alistapart.com/article/responsive-web-design</a><br><img src="/images/第一章.前期准备/1.png" width="80%"></p><p>2.响应式网站的优点<br><img src="/images/第一章.前期准备/2.png" width="80%"><br><img src="/images/第一章.前期准备/3.png" width="50%"><br>3.媒体查询<br>在CSS2时只是区分打印机打印或者电脑显示样式<br><img src="/images/第一章.前期准备/4.png" width="80%"><br>CSS3中增加了媒体类型和函数<br><img src="/images/第一章.前期准备/5.png" width="80%"><br>@meida 代表这一句话是媒体查询<br>all 代表媒体类型。可以使用screen和print。可以不写默认为all。如果使用not和only之类的操作符，媒体类型就一定要写。<br>and (min-width:800px) 代表这是表达式<br>and是逻辑操作符。可以是not或者only或者使用逗号分隔<br><img src="/images/第一章.前期准备/6.png" width="80%"><br><img src="/images/第一章.前期准备/11.png" width="80%"><br><img src="/images/第一章.前期准备/14.png" width="80%"><br><img src="/images/第一章.前期准备/15.png" width="80%"><br><img src="/images/第一章.前期准备/16.png" width="80%"><br><img src="/images/第一章.前期准备/17.png" width="50%"><br>在老旧浏览器中会忽略掉第一个空格后面的所有文字。所以第一句话老浏览器会忽略。第二个样式会被应用。<br>如果只针对某一个媒体设备就不要忽略only<br><img src="/images/第一章.前期准备/18.png" width="80%"><br>CSS3媒体属性简介<br>最常用的是width，height，device-width和device-height<br><img src="/images/第一章.前期准备/19.png" width="80%"><br><img src="/images/第一章.前期准备/20.png" width="80%"><br><img src="/images/第一章.前期准备/21.png" width="80%"><br>设备屏幕宽度和视口宽度的区别<br>桌面浏览器只有一个视口，就是桌面浏览器的主窗口的区域，显示网页内容的区域。<br>手机端浏览器有3个视口的概念<br>布局视口：用一个虚拟的宽度960来先把网页布局出来<br>可视视口：就是手机呈现出来的宽度。用户缩放会改变可视视口的大小，不会改变布局视口的大小。开发者只用知道这个概念和存在，没办法进行设置和修改，是用户在自己进行的操作，不会是一个固定的值。<br><img src="/images/第一章.前期准备/22.png" width="80%"><br>理想视口：概念上有点类似布局视口，按照理想视口的宽度布局。宽度又是可视视口的宽度，不需要缩放就可以看到整体页面<br><img src="/images/第一章.前期准备/23.png" width="40%"><br><img src="/images/第一章.前期准备/24.png" width="80%"><br>content=“width=device-width”告诉手机我要使用理想视口来布局<br><img src="/images/第一章.前期准备/25.png" width="80%"><br><img src="/images/第一章.前期准备/26.png" width="40%"><br><img src="/images/第一章.前期准备/27.png" width="80%"><br><img src="/images/第一章.前期准备/28.png" width="80%"></p><p>4.响应式网站设计实践原则<br><img src="/images/第一章.前期准备/7.jpg" width="50%"><br><img src="/images/第一章.前期准备/8.jpg"></p><p>5.怎样分析设计图<br><img src="/images/第一章.前期准备/9.jpg"><br><img src="/images/第一章.前期准备/10.jpg"><br><img src="/images/第一章.前期准备/12.jpg"></p>]]></content>
      
      <categories>
          
          <category> 所向披靡的响应式开发 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>vue2.0+node.js+MongoDB全栈打造商城(3)</title>
      <link href="/2018/07/23/vue2-0-node-js-MongoDB%E5%85%A8%E6%A0%88%E6%89%93%E9%80%A0%E5%95%86%E5%9F%8E-3/"/>
      <url>/2018/07/23/vue2-0-node-js-MongoDB%E5%85%A8%E6%A0%88%E6%89%93%E9%80%A0%E5%95%86%E5%9F%8E-3/</url>
      <content type="html"><![CDATA[<p>学完了慕课网视频《vue2.0+node.js+MongoDB全栈打造商城》，并且也把改商城开发好了。但是时间久了也忘记了具体的细节了，所以想在看一遍并且记录下来。<br><a id="more"></a></p><h3 id="六-商品列表模块实现"><a href="#六-商品列表模块实现" class="headerlink" title="六.商品列表模块实现"></a>六.商品列表模块实现</h3><h4 id="1-商品列表基础组件拆分"><a href="#1-商品列表基础组件拆分" class="headerlink" title="1.商品列表基础组件拆分"></a>1.商品列表基础组件拆分</h4><p><img src="/images/vue2.0+node.js+MongoDB全栈打造商城-3/1.png"><br>在HTML4.0以及之前的版本中，W3C标准是不区分标签大小写的。<br>但是在以后的HTML5.0版本中，W3C明确规定，标签必须用小写格式。<br><code>&lt;slot&gt;</code>被称为内容分发。但是其实叫做插槽更为贴切<br>此目的为了使得能够在父组件中的子组件中加入拓展的功能。而在子组件则要留出位置以备后用，<code>&lt;slot&gt;</code>就是这个留出来的位置或者插槽。<br><img src="/images/vue2.0+node.js+MongoDB全栈打造商城-3/2.png"><br><img src="/images/vue2.0+node.js+MongoDB全栈打造商城-3/3.png"></p><h4 id="2-商品列表数据渲染是实现"><a href="#2-商品列表数据渲染是实现" class="headerlink" title="2.商品列表数据渲染是实现"></a>2.商品列表数据渲染是实现</h4>]]></content>
      
      <categories>
          
          <category> vue </category>
          
          <category> vue2.0+node.js+MongoDB全栈打造商城 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>vue2.0+node.js+MongoDB全栈打造商城(2)</title>
      <link href="/2018/07/22/vue2-0-node-js-MongoDB%E5%85%A8%E6%A0%88%E6%89%93%E9%80%A0%E5%95%86%E5%9F%8E-2/"/>
      <url>/2018/07/22/vue2-0-node-js-MongoDB%E5%85%A8%E6%A0%88%E6%89%93%E9%80%A0%E5%95%86%E5%9F%8E-2/</url>
      <content type="html"><![CDATA[<p>学完了慕课网视频《vue2.0+node.js+MongoDB全栈打造商城》，并且也把改商城开发好了。但是时间久了也忘记了具体的细节了，所以想在看一遍并且记录下来。<br><a id="more"></a></p><h3 id="四-Vue-resource和Axios"><a href="#四-Vue-resource和Axios" class="headerlink" title="四.Vue-resource和Axios"></a>四.Vue-resource和Axios</h3><h4 id="1-Vue-Resource基础介绍"><a href="#1-Vue-Resource基础介绍" class="headerlink" title="1.Vue-Resource基础介绍"></a>1.Vue-Resource基础介绍<!--more--></h4><p><img src="/images/vue2-0-node-js-MongoDB全栈打造商城-2/4.png"><br>安装vue-resource插件到项目依赖（–save而不是开发依赖）<br><img src="/images/vue2-0-node-js-MongoDB全栈打造商城-2/1.png"><br><img src="/images/vue2-0-node-js-MongoDB全栈打造商城-2/2.png"><br><img src="/images/vue2-0-node-js-MongoDB全栈打造商城-2/10.png"><br><img src="/images/vue2-0-node-js-MongoDB全栈打造商城-2/5.png"><br><img src="/images/vue2-0-node-js-MongoDB全栈打造商城-2/6.png"><br>使用inteceptor可以在请求前和请求后附加一些行为，比如使用inteceptor在ajax请求时显示loading界面。<br><img src="/images/vue2-0-node-js-MongoDB全栈打造商城-2/3.png"><br><img src="/images/vue2-0-node-js-MongoDB全栈打造商城-2/7.png"><br>root:根路径<br><img src="/images/vue2-0-node-js-MongoDB全栈打造商城-2/8.png"><br><img src="/images/vue2-0-node-js-MongoDB全栈打造商城-2/9.png"></p><h4 id="2-axios介绍"><a href="#2-axios介绍" class="headerlink" title="2.axios介绍"></a>2.axios介绍</h4><p>vue2.0之后，就不再对vue-resource更新，而是推荐使用axios。基于 Promise 的 HTTP 请求客户端，可同时在浏览器和 Node.js 中使用<br><img src="/images/vue2-0-node-js-MongoDB全栈打造商城-2/11.png"><br><img src="/images/vue2-0-node-js-MongoDB全栈打造商城-2/12.png"><br><img src="/images/vue2-0-node-js-MongoDB全栈打造商城-2/13.png"><br>安装其他插件的时候，可以直接在 main.js 中引入并使用 Vue.use()来注册，但是 axios并不是vue插件，所以不能 使用Vue.use()，所以只能在每个需要发送请求的组件中即时引入。<br>为了解决这个问题，我们在引入 axios 之后，通过修改<font color="red">原型链</font>，来更方便的使用。<br><code>Vue.config.productionTip = false</code> 用来阻止vue在启动时生成生产提示。<br><img src="/images/vue2-0-node-js-MongoDB全栈打造商城-2/14.png"><br><img src="/images/vue2-0-node-js-MongoDB全栈打造商城-2/18.png"><br><img src="/images/vue2-0-node-js-MongoDB全栈打造商城-2/19.png"><br><strong><font color="red">注：</font></strong>参数是对象要加引号<br>post用data定义。get用params定义<br><img src="/images/vue2-0-node-js-MongoDB全栈打造商城-2/20.png"><br><img src="/images/vue2-0-node-js-MongoDB全栈打造商城-2/15.png"><br><img src="/images/vue2-0-node-js-MongoDB全栈打造商城-2/16.png"><br><img src="/images/vue2-0-node-js-MongoDB全栈打造商城-2/17.png"><br>挂载到全局对象<br><img src="/images/vue2-0-node-js-MongoDB全栈打造商城-2/21.png"><br><img src="/images/vue2-0-node-js-MongoDB全栈打造商城-2/22.png"></p><h3 id="五-ES6常用语法"><a href="#五-ES6常用语法" class="headerlink" title="五.ES6常用语法"></a>五.ES6常用语法</h3><h4 id="1-ECMAScript6简介"><a href="#1-ECMAScript6简介" class="headerlink" title="1.ECMAScript6简介"></a>1.ECMAScript6简介</h4><p><img src="/images/vue2-0-node-js-MongoDB全栈打造商城-2/23.png"><br>import导入。export导出<br><img src="/images/vue2-0-node-js-MongoDB全栈打造商城-2/24.png"><br><img src="/images/vue2-0-node-js-MongoDB全栈打造商城-2/25.png"><br><img src="/images/vue2-0-node-js-MongoDB全栈打造商城-2/26.png"><br>1.<code>string</code> 是模板字符串，ES2015新增的符号<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var x = &apos;a&apos;, y = &apos;b&apos;;</span><br><span class="line">var z = `$&#123;x,y&#125;`; //&apos;b&apos;</span><br></pre></td></tr></table></figure></p><p>模板字符串里面${var}是变量的占位符。<br>x,y 逗号运算符是返回符号右边的值，这里面等于y。</p><p>2.值得注意的是rest参数之后不能再有其他参数（只能是最后一个参数）<br>a.可以替代apply方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Math.max.apply(null,[14,3,7])   //ES5写法</span><br><span class="line">Math.max(...[14,3,7]) //ES6写法</span><br></pre></td></tr></table></figure></p><p>b.用于合并数组:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1,2].concat(more) //ES5</span><br><span class="line">[1,2, ...more] //ES6</span><br></pre></td></tr></table></figure></p><p>c.与解构赋值结合：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let [first,...rest]=[1,2,3,4,5];</span><br><span class="line">first //1</span><br><span class="line">rest  //[2,3,4,5]</span><br></pre></td></tr></table></figure></p><p>如果将扩展运算符用于数组复制，只能放在参数最后一位，否则会报错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[...rest,last]=[1,2,3,4,5]//报错</span><br></pre></td></tr></table></figure></p><p><img src="/images/vue2-0-node-js-MongoDB全栈打造商城-2/27.png"></p><p><font color="red"><strong>扩展：</strong></font>大白话讲解Promise（一）<br><a href="http://www.cnblogs.com/lvdabao/p/es6-promise-1.html" target="_blank" rel="noopener">http://www.cnblogs.com/lvdabao/p/es6-promise-1.html</a><br><img src="/images/vue2-0-node-js-MongoDB全栈打造商城-2/28.png"><br>Promise的构造函数接收一个参数，是函数，并且传入两个参数：resolve，reject，分别表示异步操作执行<font color="red">成功</font>后的回调函数和异步操作执行<font color="red">失败</font>后的回调函数。其实这里用“成功”和“失败”来描述并不准确，按照标准来讲，resolve是将Promise的状态置为fullfiled，reject是将Promise的状态置为rejected。不过在我们开始阶段可以先这么理解，后面再细究概念。<br><img src="/images/vue2-0-node-js-MongoDB全栈打造商城-2/29.png"></p><p><font color="red">???</font><br><img src="/images/vue2-0-node-js-MongoDB全栈打造商城-2/30.png"><br><img src="/images/vue2-0-node-js-MongoDB全栈打造商城-2/31.png"><br><img src="/images/vue2-0-node-js-MongoDB全栈打造商城-2/32.png"><br><img src="/images/vue2-0-node-js-MongoDB全栈打造商城-2/33.png"><br><img src="/images/vue2-0-node-js-MongoDB全栈打造商城-2/34.png"><br>异步加载文件<br><img src="/images/vue2-0-node-js-MongoDB全栈打造商城-2/35.png"></p><h4 id="2-AMD-CMD-CommonJs和ES6对比"><a href="#2-AMD-CMD-CommonJs和ES6对比" class="headerlink" title="2.AMD,CMD,CommonJs和ES6对比"></a>2.AMD,CMD,CommonJs和ES6对比</h4><p><img src="/images/vue2-0-node-js-MongoDB全栈打造商城-2/36.png"><br>依赖前置，异步模块定义<br><img src="/images/vue2-0-node-js-MongoDB全栈打造商城-2/37.png"><br>依赖就近，同步加载<br><img src="/images/vue2-0-node-js-MongoDB全栈打造商城-2/38.png"><br>浏览器不支持，node.js后端使用<br><img src="/images/vue2-0-node-js-MongoDB全栈打造商城-2/39.png"><br><img src="/images/vue2-0-node-js-MongoDB全栈打造商城-2/40.png"></p>]]></content>
      
      <categories>
          
          <category> vue </category>
          
          <category> vue2.0+node.js+MongoDB全栈打造商城 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>待更新</title>
      <link href="/2018/07/12/%E5%BE%85%E6%9B%B4%E6%96%B0/"/>
      <url>/2018/07/12/%E5%BE%85%E6%9B%B4%E6%96%B0/</url>
      <content type="html"><![CDATA[<p>7.11：scrolWidth,滚动（易拉罐效果），overflow<br>7.12：对象数组的属性,:src图片不显示<br>7.17:滚动，组件，提取js代码</p><p>7.23:后台模板<br>    前端跨域：谷歌浏览器<br>    后台：jsonp</p><p>7.26：全局变量sid可能会不安全，在每个函数里面各自取<br>在一个函数里面的变量如何传到另一个函数</p>]]></content>
      
      <categories>
          
          <category> 工作笔记待更新 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>MUI框架的使用(1)</title>
      <link href="/2018/07/08/mui%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8-1/"/>
      <url>/2018/07/08/mui%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8-1/</url>
      <content type="html"><![CDATA[<p>时隔太久了我也忘记这是什么视频了。。。<br><a id="more"></a><br>MUI-最接近原生APP体验的高性能前端框架</p><h3 id="第一章-课程介绍"><a href="#第一章-课程介绍" class="headerlink" title="第一章:课程介绍"></a>第一章:课程介绍</h3><p><img src="/images/mui框架的使用-1/1.png"><br><img src="/images/mui框架的使用-1/2.png"></p><h3 id="第二章-MUI基础知识概述"><a href="#第二章-MUI基础知识概述" class="headerlink" title="第二章:MUI基础知识概述"></a>第二章:MUI基础知识概述</h3><p><img src="/images/mui框架的使用-1/3.png"><br><img src="/images/mui框架的使用-1/4.png"><br><img src="/images/mui框架的使用-1/5.png"><br><img src="/images/mui框架的使用-1/6.png"><br><img src="/images/mui框架的使用-1/7.png"><br><img src="/images/mui框架的使用-1/8.png"></p><h3 id="第三章-项目概述及框架搭建"><a href="#第三章-项目概述及框架搭建" class="headerlink" title="第三章:项目概述及框架搭建"></a>第三章:项目概述及框架搭建</h3><h4 id="1-制作tab页面"><a href="#1-制作tab页面" class="headerlink" title="1.制作tab页面"></a>1.制作tab页面</h4><p><img src="/images/mui框架的使用-1/9.png"><br>让HBuilder检测到夜神模拟器：在菜单栏里设置工具–&gt;选项–&gt;HBuild–&gt;第三方安卓模拟器端口：62001<br>框架生成的默认模式：<br><img src="/images/mui框架的使用-1/10.png"><br>默认的总共有5个tab，需要更改为3个tab<br>1.先在manifest.json文件里更改text，width，icon等属性，并删除不需要的代码。<br>2.修改icon。在css的mui.css里查找所需的icon的代码，复制到manifest.json里的icon属性里。增加u<br>例如：\e466-&gt;\ue466<br>3.修改js的util.js。将83行的8改为6<br>4.删除index.html的47到147代码，并修改剩下的代码</p><h4 id="2-调整模板"><a href="#2-调整模板" class="headerlink" title="2.调整模板"></a>2.调整模板</h4><p><img src="/images/mui框架的使用-1/11.png"><br><img src="/images/mui框架的使用-1/12.png"><br><img src="/images/mui框架的使用-1/13.png"><br>index是首页文件，可以把new-webview.html删除掉。<br>文件重命名：在html文件里把文件名更改，之后到util.js里面更改subpages设置<br>清空页面内容：把预设的html代码和css代码和js代码都清掉<br>修改tab底色：在manifest.json页面修改subNViews的backgroundColor的颜色，删除launchwebview的”background”: “#fff”<br>修改内容底色，在每个HTML页面中修改body的background<br><img src="/images/mui框架的使用-1/14.png"><br>修改路径之后要自己手动修改，subnview–mui对tab的原生封装</p><h3 id="第4章-电影列表功能实战"><a href="#第4章-电影列表功能实战" class="headerlink" title="第4章:电影列表功能实战"></a>第4章:电影列表功能实战</h3><h4 id="1-搜索框"><a href="#1-搜索框" class="headerlink" title="1.搜索框"></a>1.搜索框</h4><p><img src="/images/mui框架的使用-1/15.png"><br><img src="/images/mui框架的使用-1/16.png"></p><p><font color="red">注：</font>.mui-content类的默认背景色是灰色的。<br>tap点击事件<br>选择器mui（‘.wrap-search’）[0]<br>绑定事件：addEventListen(‘tap’,function(){})</p><h4 id="2-热映列表布局"><a href="#2-热映列表布局" class="headerlink" title="2.热映列表布局"></a>2.热映列表布局</h4><p><img src="/images/mui框架的使用-1/17.png"><br><img src="/images/mui框架的使用-1/18.png"><br><img src="/images/mui框架的使用-1/19.png"><br><img src="/images/mui框架的使用-1/20.png"><br>编写style.css文件。<br>在.mui-scroll-wrapper上添加top:50px的样式，可以离顶部50px的距离（不用设置position，区域滚动组件默认为absolute定位，全屏显示）<br>给img元素添加mui-pull-left类，使其左浮动<br>mui-ellipsis类，使文本单行显示<br><img src="/images/mui框架的使用-1/21.png"><br>手动初始化scroll：mui(‘.mui-scroll-wrapper’).scroll({})</p><h4 id="3-获取热映列表接口数据"><a href="#3-获取热映列表接口数据" class="headerlink" title="3.获取热映列表接口数据"></a>3.获取热映列表接口数据</h4><p><img src="/images/mui框架的使用-1/22.png"><br><img src="/images/mui框架的使用-1/23.png"><br>mui.getJSON()(url[,data][,success])<br>豆瓣接口为：<a href="http://api.douban.com/v2/movie/in_theaters" target="_blank" rel="noopener">http://api.douban.com/v2/movie/in_theaters</a><br>编写数据转换函数convert（）<br>电影风格（将数组转换成用逗号拼接的字符串）：item.genres.toString().replace(/,/g,’ / ‘)<br>在多个演员中间加入’/’:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var directors = &apos;&apos;;</span><br><span class="line">for(var i=0;i&lt;item.directors.length;i++)&#123;</span><br><span class="line">directors += item.directors[i].name;</span><br><span class="line">if(i != item.directors.length - 1)&#123;</span><br><span class="line">directors += &apos; / &apos;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="4-使用Vue进行数据绑定"><a href="#4-使用Vue进行数据绑定" class="headerlink" title="4.使用Vue进行数据绑定"></a>4.使用Vue进行数据绑定</h4><p><img src="/images/mui框架的使用-1/24.png"><br><img src="/images/mui框架的使用-1/25.png"><br><img src="/images/mui框架的使用-1/26.png"><br>引入Vue.min.js文件<br>使用Vue：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var data_movies = new Vue(&#123;  //注：Vue首字母大写</span><br><span class="line">el:&apos;#movies&apos;,</span><br><span class="line">data:&#123;</span><br><span class="line">movies:[]</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h4 id="5-下拉刷新上拉加载"><a href="#5-下拉刷新上拉加载" class="headerlink" title="5.下拉刷新上拉加载"></a>5.下拉刷新上拉加载</h4><p><img src="/images/mui框架的使用-1/27.png"><br><img src="/images/mui框架的使用-1/28.png"><br><img src="/images/mui框架的使用-1/29.png"><br><img src="/images/mui框架的使用-1/30.png"><br>bug两个进度条，DOM自带的一个和scroll控件的一个<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mui(&apos;.mui-scroll-wrapper&apos;).scroll(&#123;</span><br><span class="line">indicators:false</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><img src="/images/mui框架的使用-1/31.png"></p><p>mui中iOS平台的下拉刷新（Android平台的下拉刷新使用的是双webview+原生滚动方案）、popover、可拖动式选项卡均使用了scroll组件。 为方便大家使用，mui还额外为scroll插件封装了部分方法。</p><h4 id="6-预加载电影详情页"><a href="#6-预加载电影详情页" class="headerlink" title="6.预加载电影详情页"></a>6.预加载电影详情页</h4><p><img src="/images/mui框架的使用-1/32.png"><br><img src="/images/mui框架的使用-1/33.png"><br>新建电影详情的html页面，选择含有mui的html模板。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//预加载的电影详情页面</span><br><span class="line">var detailPage = mui.preload(&#123;</span><br><span class="line">    id:&apos;movie-detail&apos;,//默认使用当前页面的url作为id</span><br><span class="line">url:&apos;./html/movie-detail.html&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><img src="/images/mui框架的使用-1/34.png"></p><h3 id="第5章-电影详情功能实战"><a href="#第5章-电影详情功能实战" class="headerlink" title="第5章:电影详情功能实战"></a>第5章:电影详情功能实战</h3><h4 id="1-电影详情页面跳转和数据传递"><a href="#1-电影详情页面跳转和数据传递" class="headerlink" title="1. 电影详情页面跳转和数据传递"></a>1. 电影详情页面跳转和数据传递</h4><p>在tab顶部增加横线：在manifest.json文件里面添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;tag&quot;: &quot;rect&quot;,</span><br><span class="line">&quot;id&quot;: &quot;tabBorder&quot;,</span><br><span class="line">&quot;text&quot;: &quot;\ue502&quot;,</span><br><span class="line">&quot;position&quot;: &#123;</span><br><span class="line">&quot;top&quot;: &quot;0&quot;,</span><br><span class="line">&quot;left&quot;: &quot;0&quot;,</span><br><span class="line">&quot;width&quot;: &quot;100%&quot;,</span><br><span class="line">&quot;height&quot;: &quot;1px&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;rectStyles&quot;: &#123;</span><br><span class="line">&quot;color&quot;:&quot;#ccc&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/images/mui框架的使用-1/35.png"><br><img src="/images/mui框架的使用-1/36.png"><br><img src="/images/mui框架的使用-1/37.png"><br><img src="/images/mui框架的使用-1/38.png"><br><img src="/images/mui框架的使用-1/39.png"><br>若没有使用预加载就是用什么？传参</p><p><strong><font color="red">待解决的问题，滚动和打开新页面</font></strong></p>]]></content>
      
      <categories>
          
          <category> MUI </category>
          
          <category> 仿豆瓣电影 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>响应式的页面实现</title>
      <link href="/2018/07/06/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%9A%84%E9%A1%B5%E9%9D%A2%E5%AE%9E%E7%8E%B0/"/>
      <url>/2018/07/06/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%9A%84%E9%A1%B5%E9%9D%A2%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<h3 id="响应式布局概念"><a href="#响应式布局概念" class="headerlink" title="响应式布局概念"></a>响应式布局概念</h3><p>Responsive design，意在实现不同屏幕分辨率的终端上浏览网页的不同展示方式。通过响应式设计能使网站在手机和平板电脑上有更好的浏览阅读体验。<a id="more"></a></p><h4 id="响应式设计的步骤"><a href="#响应式设计的步骤" class="headerlink" title="响应式设计的步骤"></a>响应式设计的步骤</h4><ol><li>设置 Meta 标签</li></ol><p>大多数移动浏览器将HTML页面放大为宽的视图（viewport）以符合屏幕分辨率。你可以使用视图的meta标签来进行重置。下面的视图标签告诉浏览器，使用设备的宽度作为视图宽度并禁止初始的缩放。在<head>标签里加入这个meta标签。<br><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no&quot;&gt;</code><br><code>user-scalable = no</code> 属性能够解决 iPad 切换横屏之后触摸才能回到具体尺寸的问题。</head></p><ol start="2"><li>通过媒介查询来设置样式 Media Queries</li></ol><p>Media Queries 是响应式设计的核心。</p><p>它根据条件告诉浏览器如何为指定视图宽度渲染页面。假如一个终端的分辨率小于 980px，那么可以这样写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@media screen and (max-width: 980px) &#123;</span><br><span class="line">  #head &#123; … &#125;</span><br><span class="line">  #content &#123; … &#125;</span><br><span class="line">  #footer &#123; … &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里的样式就会覆盖上面已经定义好的样式。</p><ol start="4"><li>设置多种试图宽度</li></ol><p>假如我们要设定兼容 iPad 和 iphone 的视图，那么可以这样设置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/** iPad **/</span><br><span class="line">@media only screen and (min-width: 768px) and (max-width: 1024px) &#123;&#125;</span><br><span class="line">/** iPhone **/</span><br><span class="line">@media only screen and (min-width: 320px) and (max-width: 767px) &#123;&#125;</span><br></pre></td></tr></table></figure></p><p>恩，差不多就这样的一个原理。</p><p>一些注意的</p><ol><li>宽度需要使用百分比</li></ol><p>例如这样：</p><p><code>head { width: 100% }</code><br><code>content { width: 50%; }</code></p><ol start="2"><li>处理图片缩放的方法</li></ol><p>简单的解决方法可以使用百分比，但这样不友好，会放大或者缩小图片。那么可以尝试给图片指定的最大宽度为百分比。假如图片超过了，就缩小。假如图片小了，就原尺寸输出。<br><code>img { width: auto; max-width: 100%; }</code><br>用::before和::after伪元素 +content 属性来动态显示一些内容或者做其它很酷的事情，在 css3 中，任何元素都可以使用 content 属性了，这个方法就是结合 css3 的 attr 属性和 HTML 自定义属性的功能： HTML 结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;image.jpg&quot;</span><br><span class="line">  data-src-600px=&quot;image-600px.jpg&quot;</span><br><span class="line">  data-src-800px=&quot;image-800px.jpg&quot;</span><br><span class="line">  alt=&quot;&quot;&gt;</span><br></pre></td></tr></table></figure></p><p>CSS 控制：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@media (min-device-width:600px) &#123;</span><br><span class="line">    img[data-src-600px] &#123;</span><br><span class="line">        content: attr(data-src-600px, url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@media (min-device-width:800px) &#123;</span><br><span class="line">    img[data-src-800px] &#123;</span><br><span class="line">        content: attr(data-src-800px, url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="3"><li>其他属性</li></ol><p>例如 pre ，iframe，video 等，都需要和img一样控制好宽度。对于table，建议不要增加 padding 属性，低分辨率下使用内容居中：</p><p><code>table th, table td { padding: 0 0; text-align: center; }</code></p><p>以上内容和代码来自：掌心，感谢，欢迎查看我之前做过的响应式设计：查看演示</p><p>定义不同的css文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;……&quot; media=&quot;screen and (max-width:768px)&quot;&gt;</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;……&quot; media=&quot;screen and (min-width:769px)&quot;&gt;</span><br></pre></td></tr></table></figure></p><p>或者只定义定义一个css文件<br><img src="/images/响应式页面的实现/1.png"></p>]]></content>
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>提升</title>
      <link href="/2018/07/06/%E6%8F%90%E5%8D%87/"/>
      <url>/2018/07/06/%E6%8F%90%E5%8D%87/</url>
      <content type="html"><![CDATA[<p>js中三种定义变量的方式const， var， let。其中只有var 可以变量提升。<a id="more"></a><br><img src="/images/提升/1.png" width="200"><br>结果：Underfine<br>在test函数里变量提升<br><img src="/images/提升/2.png" width="200"><br>结果：3<br>提升了，在一个作用域里<br><img src="/images/提升/3.png" width="200"><br>结果：Undefined<br>赋的值留在原地<br><img src="/images/提升/4.png" width="200"><br>结果：3</p>]]></content>
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>对jsonp的理解</title>
      <link href="/2018/07/06/%E5%AF%B9jsonp%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2018/07/06/%E5%AF%B9jsonp%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>对jsonp的理解<br><a id="more"></a><br><img src="/images/对jsonp理解/1.png" width="500px"><br><img src="/images/对jsonp理解/2.png" width="500px"><br><img src="/images/对jsonp理解/3.png" width="500px"><br>C#文件中没有同源限制，只针对脚本<br>可获取别的网页的脚本程序，不能获取内容<br>Dom元素的src属性是支持跨域访问的<br>例如script 和img 元素中的src属性<br>jsonp就是利用了src支持跨域获取资源<code>&lt;script src=”……”&gt;&lt;/script&gt;</code></p><p>获取到的资源是服务器执行的（写死的自己不能按照自己的需求来改）<br><img src="/images/对jsonp理解/4.png" width="700px">获取到了doSomething字符串<br>JavaScript的链接，必须在function的下面。<br><img src="/images/对jsonp理解/5.png" width="700px"><br><img src="/images/对jsonp理解/6.png" width="700px"><br>Jsonp原理<br>利用的是script标签的src属性支持跨域访问<br>Jsonp实现<br>Script标签后面写上需要请求的页面，发送了一个方法的名字到服务器<br>服务器接收到名字之后拼接一个方法的使用，在方法的参数中传入了需要给浏览器的数据<br>返回给浏览器，浏览器把它当成js解析<br>没有跨域问题了<br>从服务器获取到了数据</p><p>在线jsonp接口测试：<a href="http://www.xiaoyaoji.cn/doc/6x4lJJA2" target="_blank" rel="noopener">http://www.xiaoyaoji.cn/doc/6x4lJJA2</a><br><a href="http://blog.csdn.net/zhangweibin123/article/details/51426206?locationNum=4&amp;fps=1" target="_blank" rel="noopener">http://blog.csdn.net/zhangweibin123/article/details/51426206?locationNum=4&amp;fps=1</a></p>]]></content>
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>web语义化</title>
      <link href="/2018/07/03/web%E8%AF%AD%E4%B9%89%E5%8C%96/"/>
      <url>/2018/07/03/web%E8%AF%AD%E4%B9%89%E5%8C%96/</url>
      <content type="html"><![CDATA[<p>什么是web语义化,有什么好处<a id="more"></a></p><p>web语义化是指通过HTML标记表示页面包含的信息，包含了HTML标签的语义化和css命名的语义化。<br>HTML标签的语义化是指：通过使用包含语义的标签（如h1-h6）恰当地表示文档结构<br>css命名的语义化是指：为html标签添加有意义的class，id补充未表达的语义</p><p>为什么需要语义化：</p><pre><code>去掉样式后页面呈现清晰的结构盲人使用读屏器更好地阅读搜索引擎更好地理解页面，有利于收录便团队项目的可持续运作及维护</code></pre>]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>网站性能优化</title>
      <link href="/2018/07/03/%E7%BD%91%E7%AB%99%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
      <url>/2018/07/03/%E7%BD%91%E7%AB%99%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<p>前端性能优化—-yahoo前端性能团队总结的35条黄金定律</p><h3 id="content方面"><a href="#content方面" class="headerlink" title="content方面"></a>content方面</h3><p>减少HTTP请求：文件合并、css sprites<a id="more"></a><br>减少DNS查询：DNS查询完成之前浏览器不能从这个主机下载任何任何文件。方法：DNS缓存、将资源分布到恰当数量的主机名，平衡并行下载和DNS查询<br>避免重定向：多余的中间访问<br>使Ajax可缓存<br>非必须组件延迟加载<br>未来所需组件预加载<br>减少DOM元素数量<br>将资源放到不同的域下：浏览器同时从一个域下载资源的数目有限，增加域可以提高并行下载量<br>减少iframe数量<br>不要404</p><hr><h3 id="Server方面"><a href="#Server方面" class="headerlink" title="Server方面"></a>Server方面</h3><p>使用CDN<br>添加Expires或者Cache-Control响应头<br>对组件使用Gzip压缩<br>配置ETag<br>Flush Buffer Early<br>Ajax使用GET进行请求<br>避免空src的img标签</p><hr><h3 id="Cookie方面"><a href="#Cookie方面" class="headerlink" title="Cookie方面"></a>Cookie方面</h3><p>减小cookie大小<br>引入资源的域名不要包含cookie</p><hr><h3 id="css方面"><a href="#css方面" class="headerlink" title="css方面"></a>css方面</h3><p>将样式表放到页面顶部<br>不使用CSS表达式<br>不使用@import<br>不使用IE的Filter</p><hr><h3 id="Javascript方面"><a href="#Javascript方面" class="headerlink" title="Javascript方面"></a>Javascript方面</h3><p>将脚本放到页面底部<br>将javascript和css从外部引入<br>压缩javascript和css<br>删除不需要的脚本<br>减少DOM访问<br>合理设计事件监听器</p><hr><h3 id="图片方面"><a href="#图片方面" class="headerlink" title="图片方面"></a>图片方面</h3><p>优化图片：根据实际颜色需要选择色深、压缩<br>优化css精灵<br>不要在HTML中拉伸图片<br>保证favicon.ico小并且可缓存</p><hr><h3 id="移动方面"><a href="#移动方面" class="headerlink" title="移动方面"></a>移动方面</h3><p>保证组件小于25k<br>Pack Components into a Multipart Document</p><hr><p><strong>日常小叨</strong>：详情见<a href="https://www.cnblogs.com/puyongsong/p/5968935.html" target="_blank" rel="noopener">https://www.cnblogs.com/puyongsong/p/5968935.html</a> 其实这一部分在极客学院的就业班里面就有接触过，但是不知道为什么觉得这个名词很高大上，所以我一直都说不知道，原来我一直对他有误解，这就是性能优化呀~~</p>]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>img标签的title和alt有什么区别</title>
      <link href="/2018/07/03/img%E6%A0%87%E7%AD%BE%E7%9A%84title%E5%92%8Calt%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/"/>
      <url>/2018/07/03/img%E6%A0%87%E7%AD%BE%E7%9A%84title%E5%92%8Calt%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<h3 id="title"><a href="#title" class="headerlink" title="title"></a>title</h3><p>title是全局属性（可用于任何 HTML 元素）之一，用于为元素提供附加的advisory information。通常当鼠标滑动到元素上的时候显示。<a id="more"></a></p><h3 id="img：规定图像的替代文本。"><a href="#img：规定图像的替代文本。" class="headerlink" title="img：规定图像的替代文本。"></a>img：规定图像的替代文本。</h3><p>alt是&lt;img&gt;的特有属性，是图片内容的等价描述，用于图片无法加载时显示、读屏器阅读图片。可提图片高可访问性，除了纯装饰图片外都必须设置有意义的值，<font color="red">搜索引擎会重点分析</font>。</p>]]></content>
      
      <categories>
          
          <category> html </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>事件绑定</title>
      <link href="/2018/07/03/%E5%85%BC%E5%AE%B9%E7%9A%84%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E5%99%A8/"/>
      <url>/2018/07/03/%E5%85%BC%E5%AE%B9%E7%9A%84%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E5%99%A8/</url>
      <content type="html"><![CDATA[<p>在JavaScript中，有三种常用的绑定事件的方法：</p><ul><li>在DOM元素中直接绑定；</li><li>在JavaScript代码中绑定；</li><li>绑定事件监听函数。<a id="more"></a></li></ul><hr><h2 id="在DOM中直接绑定事件"><a href="#在DOM中直接绑定事件" class="headerlink" title="在DOM中直接绑定事件"></a>在DOM中直接绑定事件</h2><p>我们可以在DOM元素上绑定onclick、onmouseover等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;button&quot; value=&quot;click me&quot; onclick=&quot;hello()&quot;&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">function hello()&#123;</span><br><span class="line">alert(&quot;hello world!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><hr><h2 id="在javaScript代码中绑定事件"><a href="#在javaScript代码中绑定事件" class="headerlink" title="在javaScript代码中绑定事件"></a>在javaScript代码中绑定事件</h2><p>在JavaScript代码中（即 script 标签内）绑定事件可以使JavaScript代码与HTML标签分离，文档结构清晰，便于管理和开发。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;button&quot; value=&quot;click me&quot; id=&quot;btn&quot;&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">document.getElementById(&quot;btn&quot;).onclick = function()&#123;</span><br><span class="line">alert(&quot;hello world!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><p>在不同的浏览器中运行一至。<br>处理时间时，this关键字引用的是当前元素。</p><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><p>只支持事件冒泡。<br>一个元素一次只能绑定一个事件处理函数，新的事件处理函数会覆盖就得事件处理函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;button&quot; value=&quot;click me&quot; id=&quot;btn3&quot;&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var btn3 = document.getElementById(&quot;btn3&quot;);</span><br><span class="line">btn3.onclick = function()&#123;</span><br><span class="line">alert(&quot;hello 1&quot;); //不执行</span><br><span class="line">&#125;</span><br><span class="line">btn3.onclick = function()&#123;</span><br><span class="line">alert(&quot;hello 2&quot;); //执行</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><font color="red">常规的事件绑定只执行最后绑定的事件。</font><hr><h2 id="使用事件监听绑定事件"><a href="#使用事件监听绑定事件" class="headerlink" title="使用事件监听绑定事件"></a>使用事件监听绑定事件</h2><p>绑定事件的另一种方法是用 addEventListener() 或 attachEvent() 来绑定事件监听函数。</p><h3 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h3><p>关于事件监听，W3C规范中定义了3个事件阶段，依次是捕获阶段、目标阶段、冒泡阶段。<br>起初Netscape制定了JavaScript的一套事件驱动机制（即事件捕获）。随即IE也推出了自己的一套事件驱动机制（即事件冒泡）。最后W3C规范了两种事件机制，分为捕获阶段、目标阶段、冒泡阶段。<font color="red">IE8以前IE一直坚持自己的事件机制（前端人员一直头痛的兼容性问题），IE9以后IE也支持了W3C规范</font>。</p><h3 id="W3C规范"><a href="#W3C规范" class="headerlink" title="W3C规范"></a>W3C规范</h3><p>语法：<br>element.addEventListener(event, function, useCapture)<br>event : （必需）事件名，支持所有 DOM事件。例如：‘click’(不带‘on’)<br>function：（必需）指定要事件触发时执行的函数。<br>useCapture：（可选）指定事件是否在捕获或冒泡阶段执行。true：捕获。false：冒泡。默认false。</p><p><font color="red">注：IE8以下不支持。</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;button&quot; value=&quot;click me&quot; id=&quot;btn1&quot;&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">document.getElementById(&quot;btn1&quot;).addEventListener(&quot;click&quot;,hello);</span><br><span class="line">function hello()&#123;</span><br><span class="line">alert(&quot;hello world!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><h3 id="IE标准"><a href="#IE标准" class="headerlink" title="IE标准"></a>IE标准</h3><p>语法：<br>element.attachEvent(event, function)<br>event：（必需）事件类型。<font color="red">需加’on‘，例如：onclick。</font><br>function：（必需）指定要事件触发时执行的函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;button&quot; value=&quot;click me&quot; id=&quot;btn2&quot;&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">document.getElementById(&quot;btn2&quot;).attachEvent(&quot;onclick&quot;,hello);</span><br><span class="line">function hello()&#123;</span><br><span class="line">alert(&quot;hello world!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><h3 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h3><p>仅支持冒泡，不支持捕获。<br>this指向window对象，而不是当前元素。</p><h2 id="事件监听的优点"><a href="#事件监听的优点" class="headerlink" title="事件监听的优点"></a>事件监听的优点</h2><p>1、可以绑定多个事件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;button&quot; value=&quot;click me&quot; id=&quot;btn4&quot;&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var btn4 = document.getElementById(&quot;btn4&quot;);</span><br><span class="line">btn4.addEventListener(&quot;click&quot;,hello1);</span><br><span class="line">btn4.addEventListener(&quot;click&quot;,hello2);</span><br><span class="line">function hello1()&#123;</span><br><span class="line">alert(&quot;hello 1&quot;);</span><br><span class="line">&#125;</span><br><span class="line">function hello2()&#123;</span><br><span class="line">alert(&quot;hello 2&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>事件监听两个事件都执行了。<br>2、可以解除相应的绑定<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;button&quot; value=&quot;click me&quot; id=&quot;btn5&quot;&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var btn5 = document.getElementById(&quot;btn5&quot;);</span><br><span class="line">btn5.addEventListener(&quot;click&quot;,hello1);//执行了</span><br><span class="line">btn5.addEventListener(&quot;click&quot;,hello2);//不执行</span><br><span class="line">btn5.removeEventListener(&quot;click&quot;,hello2);</span><br><span class="line">function hello1()&#123;</span><br><span class="line">alert(&quot;hello 1&quot;);</span><br><span class="line">&#125;</span><br><span class="line">function hello2()&#123;</span><br><span class="line">alert(&quot;hello 2&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><h2 id="封装事件监听"><a href="#封装事件监听" class="headerlink" title="封装事件监听"></a>封装事件监听</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 事件监听器</span><br><span class="line">var EventHandlerUtil=&#123;</span><br><span class="line">addHandler:function(element,type,handler)&#123;</span><br><span class="line">if(element.addEventListener)&#123;</span><br><span class="line">element.addEventListener(type,handler,false);</span><br><span class="line">&#125;else if(element.attachEvent)&#123;</span><br><span class="line">element.attachEvent(&apos;on&apos;+type,handler);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">element[&apos;on&apos;+type]=handler;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">removeHandler:function(element,type,handler)&#123;</span><br><span class="line">if(element.removeEventListener)&#123;</span><br><span class="line">element.removeEventListener(type,handler,flase);</span><br><span class="line">&#125;else if(element.detachEvent)&#123;</span><br><span class="line">element.detachEvent(&apos;on&apos;+type,handler);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">element[&apos;on&apos;+type]=null;//不支持移除事件</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>日常小叨</strong>：这是从计算器的js中的出来的结论。使用事件监听兼容了ie浏览器的事件绑定。</p>]]></content>
      
      <categories>
          
          <category> javascript </category>
          
          <category> 计算器 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>css优先级</title>
      <link href="/2018/07/03/css%E4%BC%98%E5%85%88%E7%BA%A7/"/>
      <url>/2018/07/03/css%E4%BC%98%E5%85%88%E7%BA%A7/</url>
      <content type="html"><![CDATA[<p>我们都知道：ID选择器的优先级&gt;class选择器的优先级&gt;元素选择器的优先级<a id="more"></a></p><p><font color="blue">行间样式的优先级比ID选择器优先级高,行间样式的特殊性是1,0,0,0。</font><br>ID选择器的特殊性值，加0,1,0,0。<br>类选择器、属性选择器或<font color="blue">伪类</font>，加0,0,1,0。<br>元素和<font color="blue">伪元素</font>，加0,0,0,1。<br>通配选择器<font color="blue">*</font>对特殊性没有贡献，即0,0,0,0。<br>最后比较特殊的一个标志!important（权重），它没有特殊性值，但它的优先级是最高的，为了方便记忆，可以认为它的特殊性值为1,0,0,0,0。</p><p>下面是容易混淆的地方：<br>1.css样式优先级还和继承有关，继承的优先级不如本身应用的优先级高。<br>子级的选择器优先级比父级的选择器优先级高，或者说继承的优先级程度比自身的优先级低！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;red&quot;&gt;</span><br><span class="line">  &lt;p&gt;p&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.red&#123;</span><br><span class="line">color:red;</span><br><span class="line">&#125;</span><br><span class="line">p&#123;</span><br><span class="line">color:yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：段落p的颜色为黄色。</p><p>2.前面有讲到通配选择器*的特殊性值是0,0,0,0，而元素通过父元素继承过来的样式是没有特殊性值的，所以，<font color="blue">通配选择器定义的规则优先级高于元素继承过来的规则的优先级</font>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;p&gt;我是红色&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*&#123;</span><br><span class="line">color: red;</span><br><span class="line">&#125;</span><br><span class="line">div&#123;</span><br><span class="line">color: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：段落p的颜色为红色。</p><p>3.css规则会按顺序排序，后声明的规则优先级高。</p>]]></content>
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>图片之间的间距问题</title>
      <link href="/2018/07/03/%E5%9B%BE%E7%89%87%E4%B9%8B%E9%97%B4%E7%9A%84%E9%97%B4%E8%B7%9D%E9%97%AE%E9%A2%98/"/>
      <url>/2018/07/03/%E5%9B%BE%E7%89%87%E4%B9%8B%E9%97%B4%E7%9A%84%E9%97%B4%E8%B7%9D%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>多个img图片并排显示，中间总是有间隔。间距分为水平方向上的和垂直方向上的间距。<a id="more"></a><br><img src="/images/图片之间的间距问题/1.png" alt="图片之间的间距问题"></p><h2 id="水平方向上的间距"><a href="#水平方向上的间距" class="headerlink" title="水平方向上的间距"></a>水平方向上的间距</h2><p>因为是img标签的显示是inline-block的原因，你换行在父级元素看来，是有一个空格的字符的，所以存在8个像素，这个因浏览器不同，像素也不一样。根本原因在于父级元素把空格当做一个字符处理。</p><h3 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h3><p>1.使用float属性为img布局<br>2.源码之间不留空隙<br>3.设置字符间距letter-spacing:-800px;<br>letter-spacing的值无论是负多少都不会产生重叠(大于8就可以了)。<br><em>扩展</em>：<br>letter-spacing属性增加或减少字符间的空白（字符间距）。定义了在文本字符框之间插入多少空间。由于字符字形通常比其字符框要窄，指定长度值时，会调整字母之间通常的间隔。因此，normal 就相当于值为 0。</p><hr><h2 id="垂直方向上的间距"><a href="#垂直方向上的间距" class="headerlink" title="垂直方向上的间距"></a>垂直方向上的间距</h2><p>默认基线是baseline，因为图片底部是相对于基线对齐的，所以图片下面还留出一些空间<br><img src="/images/图片之间的间距问题/2.jpg" alt="图片之间的间距问题"></p><h3 id="解决方法：-1"><a href="#解决方法：-1" class="headerlink" title="解决方法："></a>解决方法：</h3><p>1.将基线设置为 vertical-align:bottom;<br>2.将父元素的行高设置为 line-height: 0;</p><hr><h2 id="同时解决水平和垂直方向上的间距"><a href="#同时解决水平和垂直方向上的间距" class="headerlink" title="同时解决水平和垂直方向上的间距"></a>同时解决水平和垂直方向上的间距</h2><p>将父元素的font-size设置为0 （解决display：inline-block中间有8px空白的主要方法）。</p>]]></content>
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>jQuery的选择器</title>
      <link href="/2018/07/02/jQuery%E7%9A%84%E9%80%89%E6%8B%A9%E5%99%A8/"/>
      <url>/2018/07/02/jQuery%E7%9A%84%E9%80%89%E6%8B%A9%E5%99%A8/</url>
      <content type="html"><![CDATA[<p>(1)、基本选择器：#id,.class,element,*;</p><p>(2)、层次选择器：parent &gt; child，prev + next ，prev ~ siblings<a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;label + input&quot;) 匹配所有紧接在 label 元素后的 input 元素</span><br><span class="line">$(&quot;form ~ input&quot;) 匹配 form 元素之后的所有 input 元素</span><br></pre></td></tr></table></figure></p><p>(3)、基本过滤器选择器：:first，:last ，:not ，:even ，:odd ，:eq ，:gt ，:lt<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;ul li:gt(3)&quot;)列出 index 大于 3 的元素</span><br></pre></td></tr></table></figure></p><p>(4)、内容过滤器选择器： :contains ，:empty<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;:contains(&apos;W3School&apos;)&quot;)包含指定字符串的所有元素</span><br><span class="line">$(&quot;:empty&quot;)无子（元素）节点的所有元素</span><br></pre></td></tr></table></figure></p><p>(5)、可见性过滤器选择器：:hidden ，:visible</p><p>(6)、属性过滤器选择器：[attribute] ，[attribute=value] ，[attribute!=value] ，[attribute^=value] ，[attribute$=value] ，[attribute*=value]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;input[name^=&apos;news&apos;]&quot;) 查找所有 name 以 &apos;news&apos; 开始的 input 元素</span><br><span class="line">$(&quot;input[name$=&apos;letter&apos;]&quot;) 查找所有 name 以 &apos;letter&apos; 结尾的 input 元素</span><br><span class="line">$(&quot;input[name*=&apos;man&apos;]&quot;) 查找所有 name 包含 &apos;man&apos; 的 input 元素</span><br></pre></td></tr></table></figure></p><p>(7)、子元素过滤器选择器：:nth-child ，:first-child ，:last-child ，:only-child</p><p>(8)、表单选择器： :input ，:text ，:password ，:radio ，:checkbox ，:submit 等；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;:submit&quot;)   匹配所有提交按钮</span><br></pre></td></tr></table></figure></p><p>(9)、表单过滤器选择器：:enabled ，:disabled ，:checked ，:selected</p><hr><p><strong>日常小叨</strong>：这一部分的内容其实平时用到的就几个而已，剩下的很快就会忘记，所以先记在这里，等忘记的时候就可以随时翻翻。</p>]]></content>
      
      <categories>
          
          <category> jQuery </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>typeof和instanceof</title>
      <link href="/2018/07/02/typeof%E5%92%8Cinstanceof/"/>
      <url>/2018/07/02/typeof%E5%92%8Cinstanceof/</url>
      <content type="html"><![CDATA[<p>javascript的7种数据类型:字符串、数字、布尔、数组、对象、Null、Undefined<br><strong>相同点：</strong>JavaScript 中 typeof 和 instanceof 常用来判断一个变量是否为空，或者是什么类型的。<a id="more"></a></p><hr><p><strong>typeof的定义和用法：</strong>返回值是一个字符串，用来说明变量的数据类型。是一个一元运算，放在一个运算数之前。<br>一、对于数字类型的操作数而言， typeof 返回的值是 number。比如说：typeof(1)，返回的值就是number。<br>上面是举的常规数字，对于<font color="red">非常规的数字类型</font>而言，其结果返回的也是number。比如typeof(NaN)，NaN在JavaScript中代表的是特殊非数字值，但是它本身是一个数字类型。在JavaScript中，特殊的数字类型还有几种：<br>Infinity 表示无穷大特殊值<br>NaN　　　　　　　　　　　　特殊的非数字值<br>Number.MAX_VALUE　　　　　可表示的最大数字<br>Number.MIN_VALUE　　　　　可表示的最小数字（与零最接近）<br>Number.NaN　　　　　 　　　特殊的非数字值<br>Number.POSITIVE_INFINITY　表示正无穷大的特殊值<br>Number.NEGATIVE_INFINITY  表 示负无穷大的特殊值<br>以上特殊类型，在用typeof进行运算后，其结果都将是number。<br>二、对于字符串类型， typeof 返回的值是 string。比如typeof(“123”)返回的值是string。<br>三、对于布尔类型， typeof 返回的值是 boolean 。比如typeof(true)返回的值是boolean。<br>四、对于对象、数组、null 返回的值是 object 。比如typeof(window)，typeof(document)，typeof(null)返回的值都是object。<br>五、 对于函数类型，返回的值是 function。比如：typeof(eval)，typeof(Date)返回的值都是function。<br>六、如 果运算数是没有定义的（比如说不存在的变量、函数或者undefined），将返回undefined。比如：typeof(sss)、typeof(undefined)都返回undefined。<br><strong>细节：</strong><br>(1)、typeof 一般只能返回如下几个结果：number,boolean,string,function,object,undefined。<br>(2)、typeof 来获取一个变量是否存在，如 if(typeof a!=”undefined”){alert(“ok”)}，而不要去使用 if(a) 因为如果 a 不存在（未声明）则会出错。<br>(3)、对于 Array,Null 等特殊对象使用 typeof 一律返回 object，这正是 typeof 的局限性。</p><hr><p><strong>Instanceof定义和用法：</strong>用来判断一个构造函数的prototype属性所指向的对象是否存在另外一个要检测对象的原型链上。instanceof 用于判断一个变量是否属于某个对象的实例。<br>实例演示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a instanceof b?alert(&quot;true&quot;):alert(&quot;false&quot;); //a是b的实例？真:假</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = new Array(); </span><br><span class="line">alert(a instanceof Array);  // true</span><br><span class="line">alert(a instanceof Object)  // true</span><br></pre></td></tr></table></figure><p>如上，会返回 true，同时 alert(a instanceof Object) 也会返回 true;这是因为 Array 是 object 的子类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function test()&#123;&#125;;</span><br><span class="line">var a = new test();</span><br><span class="line">alert(a instanceof test)   // true</span><br></pre></td></tr></table></figure></p><p><strong>细节：</strong><br>(1)、如下，得到的结果为‘N’,这里的 instanceof 测试的 object 是指 js 语法中的 object，不是指 dom 模型对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (window instanceof Object)&#123; alert(&apos;Y&apos;)&#125; else &#123;  alert(&apos;N&apos;);&#125;  // &apos;N&apos;</span><br></pre></td></tr></table></figure></p><hr><p><strong>日常小叨</strong>：这是两个很小的知识点，但是可能是日常中没有用，所以老是忘记。这下就不怕了，忘了就来翻翻看。</p>]]></content>
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>DOM节点关系属性</title>
      <link href="/2018/07/02/DOM%E8%8A%82%E7%82%B9%E5%85%B3%E7%B3%BB%E5%B1%9E%E6%80%A7/"/>
      <url>/2018/07/02/DOM%E8%8A%82%E7%82%B9%E5%85%B3%E7%B3%BB%E5%B1%9E%E6%80%A7/</url>
      <content type="html"><![CDATA[<h1 id="父级属性"><a href="#父级属性" class="headerlink" title="父级属性"></a>父级属性</h1><h2 id="parentNode"><a href="#parentNode" class="headerlink" title="parentNode"></a>parentNode</h2><p>每个节点都有一个parentNode属性，该属性指向文档树中的父节点。对于一个节点来说，它的父节点只可能是三种类型：element节点、document节点和documentfragment节点。如果不存在，则返回null.<a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;myDiv&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">console.log(myDiv.parentNode);//body</span><br><span class="line">console.log(document.body.parentNode);//html</span><br><span class="line">console.log(document.documentElement.parentNode);//document</span><br><span class="line">console.log(document.parentNode);//null</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><h2 id="parentElement"><a href="#parentElement" class="headerlink" title="parentElement"></a>parentElement</h2><p>与parentNode属性不同的是，parentElement返回的是父元素节点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;myDiv&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">console.log(myDiv.parentElement);//body</span><br><span class="line">console.log(document.body.parentElement);//html</span><br><span class="line">console.log(document.documentElement.parentElement);//null</span><br><span class="line">console.log(document.parentElement);//null</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><hr><h1 id="子级属性"><a href="#子级属性" class="headerlink" title="子级属性"></a>子级属性</h1><h2 id="childNodes"><a href="#childNodes" class="headerlink" title="childNodes"></a>childNodes</h2><p>childNodes是一个只读的类数组对象NodeList对象，它保存着该节点的<font color="blue">第一层子节点</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=&quot;myUl&quot;&gt;</span><br><span class="line">&lt;li&gt;</span><br><span class="line">&lt;div&gt;&lt;/div&gt;</span><br><span class="line">&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var myUl = document.getElementById(&apos;myUl&apos;);</span><br><span class="line">console.log(myUl.childNodes);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>结果<br><img src="/images/DOM节点关系属性/1.png"><br>text节点是因为html中li前后有空格。</p><h2 id="children"><a href="#children" class="headerlink" title="children"></a>children</h2><p>children是一个只读的类数组对象HTMLCollection对象，但它保存的是该节点的<font color="blue">第一层<font color="red">元素</font>子节点</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;myDiv&quot;&gt;123&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var myDiv = document.getElementById(&apos;myDiv&apos;);</span><br><span class="line">//childNodes包含所有类型的节点，所以输出[text]</span><br><span class="line">console.log(myDiv.childNodes);</span><br><span class="line">//children只包含元素节点，所以输出[]</span><br><span class="line">console.log(myDiv.children);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><h2 id="childElementCount"><a href="#childElementCount" class="headerlink" title="childElementCount"></a>childElementCount</h2><p>返回<font color="red">子元素</font>节点的个数，相当于children.length<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=&quot;myUl&quot;&gt;</span><br><span class="line">    &lt;li&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var myUl = document.getElementById(&apos;myUl&apos;);</span><br><span class="line">console.log(myUl.childNodes.length);//5，IE8-浏览器返回2，因为不包括空文本节点</span><br><span class="line">console.log(myUl.children.length);//2</span><br><span class="line">console.log(myUl.childElementCount);//2，IE8-浏览器返回undefined</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><h2 id="firstChild"><a href="#firstChild" class="headerlink" title="firstChild"></a>firstChild</h2><p>第一个子节点</p><h2 id="lastChild"><a href="#lastChild" class="headerlink" title="lastChild"></a>lastChild</h2><p>最后一个子节点</p><h2 id="firstElementChild"><a href="#firstElementChild" class="headerlink" title="firstElementChild"></a>firstElementChild</h2><p>第一个元素子节点</p><h2 id="lastElementChild"><a href="#lastElementChild" class="headerlink" title="lastElementChild"></a>lastElementChild</h2><p>最后一个元素子节点　<br>上面四个属性，IE8-浏览器和标准浏览器的表现并不一致。<font color="red">IE8-浏览器不考虑空白文本节点，且不支持firstElementChild和lastElementChild</font><br><em>ul标签和li标签之间有两个空白文本节点，所以按照标准来说，ul的子节点包括[空白文本节点、li元素节点、空白文本节点]。但在IE8-浏览器中，ul的子节点只包括[li元素节点]</em></p><hr><h1 id="同级属性"><a href="#同级属性" class="headerlink" title="同级属性"></a>同级属性</h1><h2 id="nextSibling"><a href="#nextSibling" class="headerlink" title="nextSibling"></a>nextSibling</h2><p>后一个节点</p><h2 id="previousSibling"><a href="#previousSibling" class="headerlink" title="previousSibling"></a>previousSibling</h2><p>前一个节点</p><h2 id="nextElementSibling"><a href="#nextElementSibling" class="headerlink" title="nextElementSibling"></a>nextElementSibling</h2><p>后一个元素节点</p><h2 id="previousElementSibling"><a href="#previousElementSibling" class="headerlink" title="previousElementSibling"></a>previousElementSibling</h2><p>前一个元素节点<br>与子级属性类似，上面四个属性，IE8-浏览器和标准浏览器的表现并不一致。IE8-浏览器不考虑空白文本节点，且不支持nextElementSibling和previousElementSibling<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;1&lt;/li&gt;</span><br><span class="line">    &lt;li id=&quot;myLi&quot;&gt;2&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;3&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var myLi = document.getElementById(&apos;myLi&apos;);</span><br><span class="line">console.log(myLi.nextSibling);//空白节点，IE8-浏览器返回&lt;li&gt;3&lt;/li&gt;</span><br><span class="line">console.log(myLi.nextElementSibling);//&lt;li&gt;3&lt;/li&gt;，IE8-浏览器返回undefined</span><br><span class="line">console.log(myLi.previousSibling);//空白节点，IE8-浏览器返回&lt;li&gt;1&lt;/li&gt;</span><br><span class="line">console.log(myLi.previousElementSibling);//&lt;li&gt;1&lt;/li&gt;，IE8-浏览器返回undefined</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><hr><p><strong>日常啰嗦</strong>：感觉这一部分的东西太多了，先总结个一部分。</p>]]></content>
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>关于DOM节点</title>
      <link href="/2018/07/02/%E5%85%B3%E4%BA%8EDOM%E8%8A%82%E7%82%B9/"/>
      <url>/2018/07/02/%E5%85%B3%E4%BA%8EDOM%E8%8A%82%E7%82%B9/</url>
      <content type="html"><![CDATA[<h1 id="DOM-节点"><a href="#DOM-节点" class="headerlink" title="DOM 节点"></a>DOM 节点</h1><p>根据 W3C 的 HTML DOM 标准，HTML 文档中的所有内容都是节点：<a id="more"></a></p><ul><li>整个文档是一个文档节点</li><li>每个 HTML 元素是元素节点</li><li>HTML 元素内的文本是文本节点</li><li>每个 HTML 属性是属性节点</li><li>注释是注释节点</li></ul><p>通过 HTML DOM，树中的所有节点均可通过 JavaScript 进行访问。所有 HTML 元素（节点）均可被修改，也可以创建或删除节点。</p><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">createDocumentFragment() //创建一个DOM片段</span><br><span class="line">createElement() //创建一个元素节点</span><br><span class="line">createTextNode() //创建一个文本节点</span><br></pre></td></tr></table></figure><p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var element = document.createElement(&quot;div&quot;);</span><br><span class="line">var textNode = document.createTextNode(&quot;Hello world!&quot;);</span><br><span class="line">element.appendChild(textNode);</span><br></pre></td></tr></table></figure></p><h2 id="添加、删除、替换、插入"><a href="#添加、删除、替换、插入" class="headerlink" title="添加、删除、替换、插入"></a>添加、删除、替换、插入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">appendChild() //插入新的子节点（元素）</span><br><span class="line">removeChild() //删除子节点（元素）</span><br><span class="line">replaceChild() //替换</span><br><span class="line">insertBefore() //插入</span><br></pre></td></tr></table></figure><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getElementsByTagName() //返回带有指定标签名的所有元素。</span><br><span class="line">getElementsByName() //返回相同类名的所有 HTML 元素</span><br><span class="line">getElementById() //方法返回带有指定 ID 的元素，唯一性</span><br></pre></td></tr></table></figure><p><font color="red">混合使用</font>（不像jquery有.和#的概念）<br>返回包含文档中所有 &lt;p&gt; 元素的列表，并且这些 &lt;p&gt; 元素应该是 id=”main” 的元素的后代（子、孙等等）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.getElementById(&quot;main&quot;).getElementsByTagName(&quot;p&quot;);</span><br></pre></td></tr></table></figure></p><hr><p><strong>日常啰嗦</strong>：感觉总结的不够完美，日后再来填坑。</p>]]></content>
      
      <categories>
          
          <category> javascript </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>a :hover 和a:hover 区别</title>
      <link href="/2018/07/02/a-hover-%E5%92%8Ca-hover-%E5%8C%BA%E5%88%AB/"/>
      <url>/2018/07/02/a-hover-%E5%92%8Ca-hover-%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<p>HTML代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;&quot;&gt;a标签内  &lt;span&gt;a标签的子标签内&lt;/span&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure></p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">article a :hover &#123;</span><br><span class="line">  color:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面表示 article 内所有a 标签的所有<font color="blue">子标签</font>在hover时是红色。<br><img src="/images/a-hover-和a-hover-区别/1.png" alt="a-hover-和a-hover-区别"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">article a:hover &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面表示，article内的所有a标签的在hover时是红色。<br><img src="/images/a-hover-和a-hover-区别/2.png" alt="a-hover-和a-hover-区别"></p><h3 id="关键在于："><a href="#关键在于：" class="headerlink" title="关键在于："></a>关键在于：</h3><p>有空格的是后代选择器</p><hr><p><strong>日常啰嗦</strong>：初见时有点想不明白，其实只要抓住最主要的核心，后代选择器就可以了。</p>]]></content>
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>sass语法</title>
      <link href="/2018/07/02/sass%E8%AF%AD%E6%B3%95/"/>
      <url>/2018/07/02/sass%E8%AF%AD%E6%B3%95/</url>
      <content type="html"><![CDATA[<h1 id="1-变量"><a href="#1-变量" class="headerlink" title="1. 变量"></a><font color="red">1. 变量</font></h1><p>sass通过$声明变量，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$headline-ff:Arial;</span><br><span class="line">$main-sec-ff:Tahoma;</span><br><span class="line">h1&#123;</span><br><span class="line">font-family: $headline-ff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><hr><h1 id="2-import"><a href="#2-import" class="headerlink" title="2. @import"></a><font color="red">2. @import</font></h1><p>利用sass的@import能力，创建变量文件，并引入宿主文件：<br>宿主文件screen.scss代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@import &quot;variables&quot; </span><br><span class="line">h1&#123;</span><br><span class="line">   font-family: $headline-ff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>@import时前置下划线 和 后缀.scss或者.sass可以省略，所以统一目录下 有了_variables文件就不能再有variables文件<br>变量文件_variables.scss代码：（利用compass watch 时，如果创建的scss文件名前加入了下划线_,则不会被编译对应的css文件）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$headline-ff:Arial;</span><br><span class="line">$main-sec-ff:Tahoma;</span><br></pre></td></tr></table></figure></p><p>经过编译后的screen.css代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">h1 &#123;</span><br><span class="line">  font-family: Arial;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><font color="red">原生css中@import与scss中@import的区别：</font><br>原生css@import的缺点：<br>1、需要放到代码最前端才生效<br>2、当浏览器读到这条@import指令时才会加载对应的@import的文件。性能差<br>scss中@import特点：<br>1、可以放到scss文件的任意位置，scss在编译后会将 宿主文件和 变量文件 合并到一个css文件<br>2、宿主文件中可以任意引用变量文件中的 变量和mixin函数。<br>3、可以一次@import多个文件，利用逗号分隔:<br>@import “_variables.scss”,”compass/reset”;</p><hr><h1 id="3-注释："><a href="#3-注释：" class="headerlink" title="3. 注释："></a><font color="red">3. 注释：</font></h1><p>1、支持// 和/<strong>/<br>2、在编译后的css文件中，以//注释的内容不会被输出，以/</strong>/注释的内容会被输出。<br>3、编译后的css文件中会有自动生成的注释信息，方便我们定位相应的.scss文件，方便样式调试。</p><hr><h1 id="4-嵌套语法："><a href="#4-嵌套语法：" class="headerlink" title="4. 嵌套语法："></a><font color="red">4. 嵌套语法：</font></h1><p>选择器嵌套：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$headline-ff:Arial;</span><br><span class="line">$main-sec-ff:Tahoma;</span><br><span class="line">div&#123;</span><br><span class="line">font-family: $main-sec-ff;</span><br><span class="line">h1&#123;</span><br><span class="line">font-family: $headline-ff;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译后的css文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">  font-family: Tahoma;</span><br><span class="line">&#125;</span><br><span class="line">div h1 &#123;</span><br><span class="line">  font-family: Arial;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>属性嵌套：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">font:&#123;  //不要丢掉冒号&quot;:&quot;</span><br><span class="line">family: Tahoma;</span><br><span class="line">size: 16px;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译后的css文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">  font-family: Tahoma;</span><br><span class="line">  font-size: 16px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>区别下面两种写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a&#123;</span><br><span class="line">:hover&#123;</span><br><span class="line">color: #c50000</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">a&#123;</span><br><span class="line">&amp;:hover&#123;   //”&amp;“为父类选择器。</span><br><span class="line">color: #c50000</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译后的css文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a :hover &#123;</span><br><span class="line">  color: #c50000;</span><br><span class="line">&#125;</span><br><span class="line">a:hover &#123;</span><br><span class="line">  color: #c50000;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>两者区别见<a href="https://xieshuangting.github.io/2018/07/02/a-hover-和a-hover-区别/" target="_blank" rel="noopener">https://xieshuangting.github.io/2018/07/02/a-hover-和a-hover-区别/</a></p><hr>]]></content>
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>less语法</title>
      <link href="/2018/07/01/less%E8%AF%AD%E6%B3%95/"/>
      <url>/2018/07/01/less%E8%AF%AD%E6%B3%95/</url>
      <content type="html"><![CDATA[<h1 id="1-变量"><a href="#1-变量" class="headerlink" title="1. 变量"></a><font color="red">1. 变量</font></h1><p>可以将属性的值赋值给一个变量，变量为完全的 “常量” ，所以只能定义一次<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@nice-blue: #5B83AD;</span><br><span class="line">@light-blue: @nice-blue + #111;</span><br><span class="line">#header &#123; color: @light-blue; &#125;</span><br><span class="line">结果 #header &#123; color: #6c94be; &#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>也可以用变量名定义为变量<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@fnord: &quot;I am fnord.&quot;;</span><br><span class="line">@var: &apos;fnord&apos;;</span><br><span class="line">content: &lt;font color=&quot;blue&quot;&gt;@@var&lt;/font&gt;;</span><br><span class="line">结果 content: &quot;I am fnord.&quot;;</span><br></pre></td></tr></table></figure></p><h1 id="2-混合"><a href="#2-混合" class="headerlink" title="2. 混合"></a><font color="red">2. 混合</font></h1><p>混合可以将一个定义好的class A轻松的引入到另一个class B中，从而简单实现class B继承class A中的所有属性。我们还可以带参数地调用，就像使用函数一样。<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.rounded-corners (@radius: 5px) &#123;</span><br><span class="line">border-radius: @radius;</span><br><span class="line">-webkit-border-radius: @radius;</span><br><span class="line">-moz-border-radius: @radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#header &#123;</span><br><span class="line">.rounded-corners;</span><br><span class="line">&#125;</span><br><span class="line">#footer &#123;</span><br><span class="line">.rounded-corners(10px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#header &#123;</span><br><span class="line">border-radius: 5px;</span><br><span class="line">-webkit-border-radius: 5px;</span><br><span class="line">-moz-border-radius: 5px;</span><br><span class="line">&#125;</span><br><span class="line">#footer &#123;</span><br><span class="line">border-radius: 10px;</span><br><span class="line">-webkit-border-radius: 10px;</span><br><span class="line">-moz-border-radius: 10px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>@arguments包含了所有传递进来的参数。不必单独处理每一个参数。<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.box-shadow (@x: 0, @y: 0, @blur: 1px, @color: #000) &#123;</span><br><span class="line">box-shadow: @arguments;</span><br><span class="line">-moz-box-shadow: @arguments;</span><br><span class="line">-webkit-box-shadow: @arguments;</span><br><span class="line">&#125;</span><br><span class="line">.box-shadow(2px, 5px);</span><br></pre></td></tr></table></figure></p><p>结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">box-shadow: 2px 5px 1px #000;</span><br><span class="line">-moz-box-shadow: 2px 5px 1px #000;</span><br><span class="line">-webkit-box-shadow: 2px 5px 1px #000;</span><br></pre></td></tr></table></figure></p><h1 id="3-模式匹配"><a href="#3-模式匹配" class="headerlink" title="3. 模式匹配"></a><font color="red">3. 模式匹配</font></h1><p>根据传入的参数来改变混合的默认呈现<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//让.mixin根据不同的@switch值而表现各异</span><br><span class="line">.mixin (dark, @color) &#123;</span><br><span class="line">color: darken(@color, 10%);</span><br><span class="line">&#125;</span><br><span class="line">.mixin (light, @color) &#123;</span><br><span class="line">color: lighten(@color, 10%);</span><br><span class="line">&#125;</span><br><span class="line">.mixin (@_, @color) &#123;</span><br><span class="line">display: block;</span><br><span class="line">&#125;</span><br><span class="line">//运行</span><br><span class="line">@switch: light;</span><br><span class="line">.class &#123;</span><br><span class="line">.mixin(@switch, #888);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.class &#123;</span><br><span class="line">color: #a2a2a2;</span><br><span class="line">display: block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>mixin就会得到传入颜色的浅色。如果@switch设为dark，就会得到深色。<br>具体实现如下：<br>第一个混合定义并未被匹配，因为它只接受dark做为首参<br>第二个混合定义被成功匹配，因为它只接受light<br>第三个混合定义被成功匹配，因为它接受任意值<br>只有被匹配的混合才会被使用。变量可以匹配任意的传入值，而变量以外的固定值就仅仅匹配与其相等的传入值。</p><h1 id="4-命名空间"><a href="#4-命名空间" class="headerlink" title="4. 命名空间"></a><font color="red">4. 命名空间</font></h1><p>为了更好组织CSS或者单纯是为了更好的封装，将一些变量或者混合模块打包起来<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#bundle &#123;</span><br><span class="line">  .button () &#123;</span><br><span class="line">    display: block;</span><br><span class="line">    border: 1px solid black;</span><br><span class="line">    background-color: grey;</span><br><span class="line">    &amp;:hover &#123; background-color: white &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  .tab &#123; ... &#125;</span><br><span class="line">  .citation &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#header a &#123;</span><br><span class="line">  color: orange;</span><br><span class="line">  &lt;font color=&quot;red&quot;&gt;#bundle &gt; .button;&lt;/font&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="5-作用域"><a href="#5-作用域" class="headerlink" title="5. 作用域"></a><font color="red">5. 作用域</font></h1><p>less中的作用域跟其他编程语言非常类似，首先会从本地查找变量或者混合模块，如果没找到的话会去父级作用域中查找，直到找到为止<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@var: red;</span><br><span class="line">#page &#123;</span><br><span class="line">  @var: white;</span><br><span class="line">  #header &#123;</span><br><span class="line">    color: @var; // white</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">#footer &#123;</span><br><span class="line">  color: @var; // red  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="6-注释"><a href="#6-注释" class="headerlink" title="6. 注释"></a><font color="red">6. 注释</font></h1><p>CSS形式的注释在less中是依然保留，less同样也支持双斜线的注释, 但是编译成 CSS 的时候<font color="blue">自动过滤掉</font></p><h1 id="7-引用-import"><a href="#7-引用-import" class="headerlink" title="7. 引用@import"></a><font color="red">7. 引用@import</font></h1><ul><li><p>可以在less文件中通过下面的形势引入 .less 文件, .less 后缀可带可不带<br>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@import &quot;lib.less&quot;;</span><br><span class="line">@import &quot;lib&quot;;</span><br></pre></td></tr></table></figure></li><li><p>如果想导入一个CSS文件而且不想less对它进行处理，只需要使用.css后缀就可以，这样less就会跳过它不去处理它</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@import &quot;lib.css&quot;;</span><br></pre></td></tr></table></figure></li></ul><h1 id="8-字符串插值"><a href="#8-字符串插值" class="headerlink" title="8. 字符串插值"></a><font color="red">8. 字符串插值</font></h1><p>即将@后面的变量使用{}括起来，然后整体使用””包裹即可。<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@base-url: &quot;http://assets.fnord.com&quot;;</span><br><span class="line">background-image: url(&quot;@&#123;base-url&#125;/images/bg.png&quot;);</span><br></pre></td></tr></table></figure></p><h1 id="9-避免编译"><a href="#9-避免编译" class="headerlink" title="9. 避免编译~"></a><font color="red">9. 避免编译~</font></h1><p>有时候我们需要输出一些不正确的CSS语法或者使用一些 less不认识的专有语法。<br>要输出这样的值我们可以在字符串前加上一个 ~，并将要避免编译的值用 “”包含起来。<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.class &#123;</span><br><span class="line">  filter: ~&quot;ms:alwaysHasItsOwnSyntax.For.Stuff()&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.class &#123;</span><br><span class="line">  filter: ms:alwaysHasItsOwnSyntax.For.Stuff();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="10-JavaScript-表达式"><a href="#10-JavaScript-表达式" class="headerlink" title="10. JavaScript 表达式"></a><font color="red">10. JavaScript 表达式</font></h1><ul><li><p>JavaScript 表达式也可以在.less 文件中使用，可以通过<font color="red">反引号</font>的方式使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@var: `&quot;hello&quot;.toUpperCase() + &apos;!&apos;`;    //@var: &quot;HELLO!&quot;;</span><br></pre></td></tr></table></figure></li><li><p>也可以访问JavaScript环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@height: `document.body.clientHeight`;</span><br></pre></td></tr></table></figure></li></ul><hr><p><strong>日常啰嗦</strong>：之前理解了那个mixin又忘记了，哭唧唧。现在重拾一下。。不知道为什么有时候的分割线显示不出来。应该是文章中间出现了<code>&lt;font&gt;&lt;/font&gt;</code>标签而没有换行引起的。</p>]]></content>
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>less的使用</title>
      <link href="/2018/07/01/less%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/07/01/less%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>less中文网：<a href="http://www.bootcss.com/p/lesscss/" target="_blank" rel="noopener">http://www.bootcss.com/p/lesscss/</a><a id="more"></a></p><h1 id="1-less的介绍"><a href="#1-less的介绍" class="headerlink" title="1. less的介绍"></a><font color="red">1. less的介绍</font></h1><p>Less 是一种 <font color="blue">动态 样式</font> 语言,一门 <font color="blue">CSS 预处理语言</font>，它扩展了 CSS 语言，增加了变量、Mixin、函数等特性，使 CSS 更易维护和扩展。LESS 既可以在 客户端 上运行 (支持IE 6+, Webkit, Firefox)，也可以借助Node.js或者Rhino在服务端运行。<br>基于javascript，极简。</p><hr><h1 id="2-在浏览器使用方法"><a href="#2-在浏览器使用方法" class="headerlink" title="2. 在浏览器使用方法"></a><font color="red">2. 在浏览器使用方法</font></h1><p>1.下载less.js文件到本地。<br>2.在页面中引入自己的.less文件。<br><img src="/images/less的使用/1.png" alt="less的使用"><br>3.引入下载的less.js文件。<br><img src="/images/less的使用/2.png" alt="less的使用"><br>注意2、3步骤顺序，自己的文件要先引入。</p><hr><h1 id="3-服务器端使用"><a href="#3-服务器端使用" class="headerlink" title="3. 服务器端使用"></a><font color="red">3. 服务器端使用</font></h1><p>1.全局安装less<br>$ npm install -g less<br>2.命令行使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ lessc  test.less &gt; style.css</span><br></pre></td></tr></table></figure></p><p>解析test.less文件为style.css文件<br>3.如何你想将编译后的 CSS 压缩，那么加一个 -x 参数就可以了.</p><hr><p><strong>日常啰嗦</strong>：首次了解到less是在极客学院里的第十一章：掌握CSS在工程中的变化-LESS&amp;SASS(高级进阶)。很强大，将js语法融入css里面。</p>]]></content>
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>sass的使用</title>
      <link href="/2018/07/01/sass%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/07/01/sass%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>sass中文官网：<a href="https://www.sasscss.com/" target="_blank" rel="noopener">https://www.sasscss.com/</a></p><h1 id="1-sass的介绍"><a href="#1-sass的介绍" class="headerlink" title="1. sass的介绍"></a><font color="red">1. sass的介绍</font></h1><p>sass 是 css 的预处理器（css preprocessor）<br>它能够帮我们更快更高效的编写更好维护的css。自带很多原生 css 没有的功能，如变量（现在 css 中已经实现）、条件语句等.<a id="more"></a><br>与less的区别：<br>sass基于nuby&nbsp;&nbsp;有很多扩展  大型项目略胜 开发底层样式(类似bootstrap）<br>less基于javascript 极简&nbsp;&nbsp;用于项目内部</p><hr><h1 id="2-文件后缀"><a href="#2-文件后缀" class="headerlink" title="2. 文件后缀"></a><font color="red">2. 文件后缀</font></h1><p><font color="blue">sass 有两种后缀名文件：</font></p><p><font color="blue">后缀名: .sass</font>不使用大括号和分号<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">body</span><br><span class="line">  background: #eee</span><br><span class="line">  font-size:12px</span><br><span class="line">p</span><br><span class="line">  background: #0982c1</span><br></pre></td></tr></table></figure></p><p><font color="blue">后缀名: .scss</font>和我们平时写的 css 文件格式差不多，使用大括号和分号。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">  background: #eee;</span><br><span class="line">  font-size:12px;</span><br><span class="line">&#125;</span><br><span class="line">p&#123;</span><br><span class="line">  background: #0982c1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>建议使用后缀名为 scss 的文件，以避免 sass 后缀名的严格格式要求报错。</p><hr><h1 id="3-编译"><a href="#3-编译" class="headerlink" title="3. 编译"></a><font color="red">3. 编译</font></h1><p>直接生成在命令行上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sass index.scss</span><br></pre></td></tr></table></figure></p><p>编译到 css 文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sass test.scss test.css</span><br></pre></td></tr></table></figure></p><p>.scss文件的注释没有编译到.css文件里</p><hr><p><strong>日常啰嗦</strong>：因为SASS是 Ruby 语言写的，但是两者的语法没有关系。所以要先安装ruby，之后在ruby的控制面板里输入gem install sass来安装sass。</p>]]></content>
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>元素居中</title>
      <link href="/2018/06/30/%E5%85%83%E7%B4%A0%E5%B1%85%E4%B8%AD/"/>
      <url>/2018/06/30/%E5%85%83%E7%B4%A0%E5%B1%85%E4%B8%AD/</url>
      <content type="html"><![CDATA[<p>演示地址：<a href="https://xieshuangting.github.io/calculate" target="_blank" rel="noopener">https://xieshuangting.github.io/calculate</a><a id="more"></a><br><img src="/images/背景色百分之百填充/1.png" alt="背景色百分之百填充"></p><hr><p><font color="red">1. 水平居中</font></p><p><font color="blue">行内元素</font>: 设置其父元素的text-align:center，</p><p><font color="blue">块级元素</font>:</p><ul><li>定宽：margin:0 auto;</li><li>不定宽：<ul><li>外部块级元素text-align + 内部块级元素inline-block<br><img src="/images/元素居中/1.png" alt="元素居中"></li><li></li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> css </category>
          
          <category> 计算器 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>作用域链</title>
      <link href="/2018/06/29/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/"/>
      <url>/2018/06/29/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>粘性定位position:sticky</title>
      <link href="/2018/06/29/%E7%B2%98%E6%80%A7%E5%9B%BA%E5%AE%9Aposition-sticky/"/>
      <url>/2018/06/29/%E7%B2%98%E6%80%A7%E5%9B%BA%E5%AE%9Aposition-sticky/</url>
      <content type="html"><![CDATA[<p><font color="red">粘性定位</font>是相对定位和固定定位的混合。元素在跨越特定阈值前为相对定位，之后为固定定位。<a id="more"></a></p><p>#one { position: sticky; top: 10px; }<br>在 viewport 视口滚动到元素 top 距离小于 10px 之前，元素为相对定位。之后，元素将固定在与顶部距离 10px 的位置，直到 viewport 视口回滚到阈值以下。<br>使用它，我们不再用监听scroll事件，即可实现导航栏滚动绝对定位的效果。</p><p><font color="red">生效条件</font><br>1.需要注意的是，使用该属性有几个必要条件，否则会失效：<br>2.父元素不能overflow:hidden或者overflow:auto属性。<br>3.必须指定top、bottom、left、right4个值之一，否则只会处于相对定位<br>4.父元素的高度不能低于sticky元素的高度<br>5.sticky元素仅在其父元素内生效</p><p><font color="red">兼容</font><br>position: -webkit-sticky;<br>position: sticky;</p><hr><p><strong>日常啰嗦</strong>：本文转载自这名字真不对<a href="https://www.jianshu.com/p/b72f504121f5" target="_blank" rel="noopener">https://www.jianshu.com/p/b72f504121f5</a><br>这个属性好像以前做什么东西时有看过，但是想不起来是什么了，这垃圾脑子。不过今天在前端面试题里看到这个属性，马上就百度了下。这个属性很强大呀，无奈就是浏览器的支持不好。</p>]]></content>
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>IE6不支持position:fixed问题</title>
      <link href="/2018/06/29/IE6%E4%B8%8D%E6%94%AF%E6%8C%81position-fixed%E9%97%AE%E9%A2%98/"/>
      <url>/2018/06/29/IE6%E4%B8%8D%E6%94%AF%E6%8C%81position-fixed%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<!-- <font color='red'>问题：</font>IE7已经支持position:fixed了，而IE6却不支持，解决这个问题的办法如下：现在有一个元素的id是element，它需要实现fixed效果，我们既想要它在正常的浏览器下使用，也想要它在IE 6下正常工作，那么可以使用CSS hack：复制代码#element {position: fixed;top: 450px; /* 其他浏览器下定位，在这里可设置坐标*/_position: absolute; /*IE6 用absolute模拟fixed*//*IE6 动态设置top位置*/_top: expression(eval(document.documentElement.scrollTop) +  450); }复制代码　　这样就可以实现这个元素距离顶部450像素固定，你还可以添加下面的代码实现去除页面抖动的效果：*html body{background-image:url(about:blank);background-attachment:fixed;}　　在前文中，通过_top设置CSS样式，那么怎么修改expression的样式呢：var domThis=$(this)[0];domThis.style.setExpression('top', 'eval((document.documentElement).scrollTop + ' +  50 + ')');　　通过这种方式，就可以达到修改的目的了。 --><!-- 这个兼容性问题通常是采用JS+绝对定位方式处理使元素固定在浏览器的顶部：#top{_position:absolute;_bottom:auto;_top:expression(eval(document.documentElement.scrollTop));}使元素固定在浏览器的底部：#top{_position:absolute;_bottom:auto;_top:expression(eval(document.documentElement.scrollTop+document.documentElement.clientHeight-this.offsetHeight-(parseInt(this.currentStyle.marginTop,10)||0)-(parseInt(this.currentStyle.marginBottom,10)||0)));}这两段代码只能实现在最底部跟最顶部，你可以使用 _margin-top:10px; 或者 _margin-bottom:10px; 修改其中的数值控制元素的位置。position:fixed; 闪动问题现在，问题还没有完全解决。在用了上面的办法后，你会发现：被固定定位的元素在滚动滚动条的时候会闪动。解决闪动问题的办法是在 CSS 文件中加入：*html{background-image:url(about:blank);background-attachment:fixed; -->]]></content>
      
      <categories>
          
          <category> 兼容性 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>背景色百分之百填充</title>
      <link href="/2018/06/29/%E8%83%8C%E6%99%AF%E8%89%B2%E7%99%BE%E5%88%86%E4%B9%8B%E7%99%BE%E5%A1%AB%E5%85%85/"/>
      <url>/2018/06/29/%E8%83%8C%E6%99%AF%E8%89%B2%E7%99%BE%E5%88%86%E4%B9%8B%E7%99%BE%E5%A1%AB%E5%85%85/</url>
      <content type="html"><![CDATA[<p>演示地址：<a href="https://xieshuangting.github.io/calculate" target="_blank" rel="noopener">https://xieshuangting.github.io/calculate</a><a id="more"></a><br><img src="/images/背景色百分之百填充/1.png" alt="背景色百分之百填充"></p><hr><p><font color="red">关键height：100%</font><br><img src="/images/背景色百分之百填充/2.png" alt="背景色百分之百填充"></p><p><font color="blue">%</font>: 基于包含它的块级对象的百分比高度。<br>100%这个属性值可以理解为一个<font color="blue">计算属性</font>！它是需要有一个<font color="blue">基准值</font>！而这个基准值就是其父级元素的高度值！<br>浏览器一般默认解释为内容的高度，而不是100%。div的100%是从其上一级div的宽高继承来的，有一点很关键，就是要设置div100%显示，必须设置<font color="blue">其上一级div</font>的宽度或高度，否则无效。<br><img src="/images/背景色百分之百填充/3.png" alt="背景色百分之百填充"></p><p><font color="red">注:</font>因为body默认会有8px的margin值！所以会抖动。解决抖动的代码如下：<br>body{<br>    margin: 0;<br>}</p><p><font color="blue"><strong>扩展</strong></font>：另一种实现方法：改变position属性</p><p>#box{<br>    position: absolute;<br>    //position: fixed; //或者利用这样的方法<br>    height: 100%;<br>    width: 100%;<br>    background: red;<br>}<br>这样的写法，省略了个body,html添加属性值。仅仅给#box添加就行！原理是将#box脱离文档流，height的值就可以响应屏幕的高度了！<br>还有就是width:100%记得写上，否则宽度无用</p><hr><p><strong>日常啰嗦</strong>：<font color="blue">部分内容转载自szy1000的专栏<a href="https://blog.csdn.net/u011456552/article/details/75628958" target="_blank" rel="noopener">https://blog.csdn.net/u011456552/article/details/75628958</a></font> &nbsp; 一直以来都知道要设置背景的话要把html和body的height设置为100%，但是不知道为什么，这篇文很好的为我解了惑。</p>]]></content>
      
      <categories>
          
          <category> css </category>
          
          <category> 计算器 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>position</title>
      <link href="/2018/06/29/position/"/>
      <url>/2018/06/29/position/</url>
      <content type="html"><![CDATA[<h1 id="position-属性规定元素的定位类型。"><a href="#position-属性规定元素的定位类型。" class="headerlink" title="position 属性规定元素的定位类型。"></a>position 属性规定元素的定位类型。</h1><p><font color="red">inherit</font>:规定应该从父元素继承 position 属性的值。<a id="more"></a></p><p><font color="red">absolute </font>:元素设置成absolute后会脱离文档流，并且不占有原本的空间，后面的元素会顶替上去，而且不论元素是行内元素还是块级元素，都会生成一个<font color="blue">块级框</font>，也就是例如行内元素span设置了absolute后就可以设置height和width属性了。</p><p><font color="red">fixed </font>:（IE6不支持）生成绝对定位的元素，通常相对于<font color="blue">浏览器窗口或 frame 进行定位。</font></p><p><font color="red">relative</font> :翻译成中文称相对定位，设置了这个属性后，元素会根据top，left，bottom，right进行偏移，关键点是它原本的空间仍然保留。</p><p><font color="red">static </font>:position属性的默认值，默认情况下，块级元素和行内元素按照各自的特性进行显示</p><p><font color="red">sticky</font> :生成粘性定位的元素，容器的位置根据正常文档流计算得出。(详情见<a href="https://xieshuangting.github.io/2018/06/29/粘性固定position-sticky/#more" target="_blank" rel="noopener">https://xieshuangting.github.io/2018/06/29/粘性固定position-sticky/#more</a>)</p><hr><p><strong>日常啰嗦</strong>:这篇文最大的收获就是absolute之后的元素变成了块级元素，可以设置width和height。还有知道了sticky这个属性。</p>]]></content>
      
      <categories>
          
          <category> css </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>grunt</title>
      <link href="/2018/06/29/grunt%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/06/29/grunt%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>grunt中文官网：<a href="http://www.gruntjs.net/" target="_blank" rel="noopener">http://www.gruntjs.net/</a><br><a id="more"></a></p><hr><p><font color="red">1. grunt介绍</font><br>一句话：自动化。对于需要反复重复的任务，例如压缩（minification）、编译、单元测试、linting等，自动化工具可以减轻你的劳动，简化你的工作。当你在 Gruntfile 文件正确配置好了任务，任务运行器就会自动帮你或你的小组完成大部分无聊的工作。<br>Grunt执行的每个任务都是各种插件配置的集合，这些配置都是彼此独立，按序执行的。</p><p>安装grunt工作<br>1.在当前目录下配置好package.json—-npm init<br>2.安装grunt—–npm install grunt –save-dev<br>3.创建Gruntfile.Js文件(在里面配置需求的task）</p>]]></content>
      
      <categories>
          
          <category> 自动化构建工具 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>gulp常用插件</title>
      <link href="/2018/06/29/gulp%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/"/>
      <url>/2018/06/29/gulp%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/</url>
      <content type="html"><![CDATA[<p>gulp常用插件<br><a id="more"></a><br><img src="/images/gulp常用插件/1.jpg" alt="gulp常用插件"><br>转化代码是为了兼容性</p><p><font color="blue">gulp-react</font>转换jsx代码</p><p><font color="blue">gulp-babel</font>转换es6代码</p><p><font color="blue">gulp-less</font>转换less代码</p><p><font color="blue">gulp-sass</font>转换sass代码</p><p>插件安装npm install –save-dev gulp-uglify</p><hr><p><font color="red">1. gulp-uglify（JS压缩）</font><br>gulp-uglify用来压缩js文件，使用的是uglify引擎。<br><img src="/images/gulp常用插件/2.png" alt="gulp常用插件"><br>小技巧，第二个参数’！js/*.min.js’是用来过滤掉后缀为min.js，！感叹号为排除模式。</p><hr><p><font color="red">2. gulp-minify-css（CSS压缩）</font><br><img src="/images/gulp常用插件/3.png" alt="gulp常用插件"></p><hr><p><font color="red">3. gulp-minify-html（html压缩）</font><br><img src="/images/gulp常用插件/4.png" alt="gulp常用插件"></p><hr><p><font color="red">4. gulp-concat（文件合并）</font><br>合并CSS与JS文件，减少http请求。<br><img src="/images/gulp常用插件/5.png" alt="gulp常用插件"></p><hr><p><font color="red">5. gulp-less（编译Less）</font><br><img src="/images/gulp常用插件/6.png" alt="gulp常用插件"></p><hr><p><font color="red">6. gulp-sass（编译Sass）</font><br><img src="/images/gulp常用插件/7.png" alt="gulp常用插件"></p><hr><p><strong>日常啰嗦</strong>：文章内容转载自Rin阳<a href="https://www.jianshu.com/p/98db023b5b89" target="_blank" rel="noopener">https://www.jianshu.com/p/98db023b5b89</a> 这些应该是工作中主要用到的插件。</p>]]></content>
      
      <categories>
          
          <category> 自动化构建工具 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>reset.css和normalize.css的区别</title>
      <link href="/2018/06/29/reset-css%E5%92%8Cnormalize-css%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2018/06/29/reset-css%E5%92%8Cnormalize-css%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<p><font color="red">reset.css</font><br>是将所有的浏览器的自带样式重置掉，这样更易于保持各浏览器渲染的一致性<br><img src="/images/reset和normalize的区别/2.png" alt="reset.css和normalize.css的区别"><a id="more"></a></p><p><font color="red">normalize.css</font><br>根据官网的定义： normalize.css是一个现代的，为HTML5准备的reset.css的替代品。它可以使元素的渲染在多个浏览器下都能保持一致并且符合规范。它所瞄准的，也都是些需要<font color="blue">规范化</font>的样式。<br><img src="/images/reset和normalize的区别/1.png" alt="reset.css和normalize.css的区别"></p>]]></content>
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>浏览器兼容性</title>
      <link href="/2018/06/29/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7/"/>
      <url>/2018/06/29/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7/</url>
      <content type="html"><![CDATA[<h1 id="1-浏览器兼容性？？"><a href="#1-浏览器兼容性？？" class="headerlink" title="1. 浏览器兼容性？？"></a><font color="red">1. 浏览器兼容性？？</font></h1><p>由于市场上浏览器种类众多，而不同浏览器其内核亦不尽相同，所以各个浏览器对网页的解析就有一定出入，这也是导致浏览器兼容问题出现的主要原因，我们的网页需要在主流浏览器上正常运行，就需要做好浏览器兼容。<a id="more"></a></p><font color="blue">四大内核</font><br>使用<font color="blue">Trident</font>内核的浏览器：IE；<br>使用<font color="blue">Gecko</font>内核的浏览器：Netcape6及以上版本、FireFox；<br>使用<font color="blue">Presto</font>内核的浏览器：Opera7及以上版本；<br>使用<font color="blue">Webkit</font>内核的浏览器：Safari、Chrome。<br>而我现在所说的兼容性问题，主要是说IE与几个主流浏览器如firefox，google等。而对IE浏览器来说，IE7又是个跨度，因为之前的版本更新甚慢，bug甚多。从IE8开始，IE浏览器渐渐遵循标准，到IE9后由于大家都一致认为标准很重要，可以说在兼容性上比较好了，但是在中国来说，由于xp的占有率问题，使用IE7以下的用户仍然很多，所以我们不得不考虑低版本浏览器的兼容。<br>对浏览器兼容问题，一般分:<font color="red">HTML，Javascript兼容，CSS兼容</font>。 其中html相关问题比较容易处理，无非是高版本浏览器用了低版本浏览器无法识别的元素，导致其不能解析，所以平时注意一点就是。特别是HTML5增加了许多新标签，低版本浏览器有点影响时代进步啊。<br><br>—-<br># <font color="red">2. css兼容性</font><br>## <font color="blue">问题一：不同浏览器的标签默认的外补丁(margin)和内补丁(padding)不同</font><br>问题症状：随便写几个标签，不加样式控制的情况下，各自的margin和padding差异较大。<br>解决方案：css里 *{margin:0;padding:0;}<br><br>## <font color="blue">问题二：图片默认有间距</font><br>问题症状：几个img标签放在一起的时候，有些浏览器会有默认的间距，加上问题一中提到的通配符也不起作用。<br>详情见<a href="http://localhost:4000/2018/07/03/图片之间的间距问题/" target="_blank" rel="noopener">http://localhost:4000/2018/07/03/图片之间的间距问题/</a><br><br>## <font color="blue">问题二：图片默认有间距</font><hr><p><strong>日常小叨</strong>：当初有人问我关于浏览器兼容性的时候我一脸懵，我确定我之前有接触过，但是就是说不出口。而且也很怀疑自己所知道的是不是符合答案的。所以现在我想把他做一个归纳汇总。</p>]]></content>
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>package.json文件介绍</title>
      <link href="/2018/06/28/package-json%E6%96%87%E4%BB%B6%E4%BB%8B%E7%BB%8D/"/>
      <url>/2018/06/28/package-json%E6%96%87%E4%BB%B6%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<p><font color="red">1. package.json介绍</font><br>package.json在Node项目中用于描述项目的一些基本信息，以及依赖的配置，一般每一个Node项目的根目录下都有一个package.json文件。<a id="more"></a></p><p><font color="blue">package.json文件的创建</font><br>在项目的根目录中我们可以通过$ npm init来初始化一个package.json文件，其内容是一个Json对象。<br>$ npm install 命令根据这个配置文件，自动下载所需的模块，也就是配置项目所需的运行和开发环境。</p><p><font color="blue">为什么要保存配置信息至package.json？</font><br>因为node插件包相对来说非常庞大，所以不加入版本管理，将配置信息写入package.json并将其加入版本管理，其他开发者对应下载即可（命令提示符执行npm install，则会根据package.json下载所有需要的包，npm install –production只下载dependencies节点的包）。</p><p><font color="blue">注：</font>json文件不能添加注释</p><hr><p><font color="red">2. scripts字段</font><br><img src="/images/package.json文件介绍/1.png" alt="package.json文件介绍"><br>scripts指定了运行脚本命令的npm命令行缩写，比如start指定了运行npm run start时，所要执行的命令。<br>以上的设置指定了npm run dev、npm run start、npm run build时，所要执行的命令。</p><hr><p><font color="red">2. dependencies字段，devDependencies字段</font><br><img src="/images/package.json文件介绍/2.png" alt="package.json文件介绍"><br>dependencies字段指定了项目运行所依赖的模块。<br>devDependencies指定项目开发所需要的模块。<br>它们都指向一个对象。该对象的各个成员，分别由模块名和对应的版本要求组成，表示依赖的模块及其版本范围。</p><p><font color="blue">安装模块</font><br>如果一个模块不在package.json文件之中，可以单独安装这个模块，并使用相应的参数，将其写入package.json文件之中。例单独安装express模块：<br>$ npm install express –save　　　　–save参数表示将该模块写入dependencies属性<br>$ npm install express –save-dev　　　　–save-dev表示将该模块写入devDependencies属性</p><hr><p><font color="red">3. browserslist字段</font><br><img src="/images/package.json文件介绍/3.png" alt="package.json文件介绍"><br>browserslist指定该模板供浏览器使用的版本，项目的浏览器兼容情况。Browserify这样的浏览器打包工具，通过它就知道该打包那个文件。</p><hr><p><font color="red">4. engines字段</font><br><img src="/images/package.json文件介绍/4.png" alt="package.json文件介绍"><br>engines字段指明了该模块运行的平台<br>比如 Node 的某个版本或者浏览器，指定适用的npm版本。</p><hr><p><strong>日常啰嗦</strong>：反思：一直以来学的东西太多了，然而每个学的又不深，所以时间一久导致全部都忘记了。感觉写在博客里还是有好处的，有一种成就感，虽然没有访客，但是有一种与时代接轨的感觉。很多感受交杂在一起促使我继续写文（虽然有时是复制粘贴的，但是也比单纯的网上浏览在脑海中留下的印象深很多，有一种把别人的东西变成自己成果的感觉 ？？窃取的快乐？？）。之前是单纯地记在电脑的笔记本上，但是他没有一个很好的目录浏览功能，写完之后也没有成就感，所以写了几篇之后就荒废了。然后就是写在纸质的本子上，记在本子上印象是挺深的，但是还是难以检索，难以分类。而且用手记太费时间了（不像写文可以复制粘贴，可以撤回之类的），毕竟自己太渣，别人写的东西都是自己所不懂的知识点，所以有很多东西要记。手写的工作量太大也导致记录这一工作荒废了。现在开始写博，希望可以坚持下去，或者发现这一弊处的话可以找到更好的方法。</p>]]></content>
      
      <categories>
          
          <category> node </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>gulp的使用</title>
      <link href="/2018/06/27/gulp%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/06/27/gulp%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>gulp中文官网：<a href="https://www.gulpjs.com.cn/" target="_blank" rel="noopener">https://www.gulpjs.com.cn/</a></p><hr><font color="red">1. gulp介绍</font><br>gulp是前端开发过程中对代码进行构建的工具，是自动化项目的构建利器；她不仅能对网站资源进行优化，而且在开发过程中很多重复的任务能够使用正确的工具自动完成。<a id="more"></a><br><br>gulp是<font color="blue">基于Nodejs</font>的自动任务运行器， 她能自动化地完成 javascript/coffee/sass/less/html/image/css 等文件的的测试、检查、合并、压缩、格式化、浏览器自动刷新、部署文件生成，并<font color="blue">监听</font>文件在改动后重复指定的这些步骤。在实现上，她借鉴了Unix操作系统的<font color="blue">管道</font>（pipe）思想，前一级的输出，直接变成后一级的输入，使得在操作上非常简单。<br><br>gulp 和 grunt 非常类似，但相比于 grunt 的频繁 IO 操作，gulp 的<font color="blue">流操作</font>，能更快地更便捷地完成构建工作。<br><br>——–<br><font color="red">2. gulp的使用步骤</font><br>首先当然是安装nodejs，通过nodejs的npm全局安装和项目安装gulp（$ npm install gulp -g），其次在项目里安装所需要的gulp插件（$ npm install gulp –save-dev,$ npm install gulp-less –save-dev），然后新建gulp的配置文件gulpfile.js并写好配置信息（定义gulp任务），最后通过命令提示符运行gulp任务即可。<br><font color="blue">安装nodejs -&gt; 全局安装gulp -&gt; 项目安装gulp以及gulp插件 -&gt; 配置gulpfile.js -&gt; 运行任务</font><p>细心的你可能会发现，我们全局安装了gulp，项目也安装了gulp，全局安装gulp是为了执行gulp任务，本地安装gulp则是为了调用gulp插件的功能。</p><hr><p><font color="red">3. 新建gulpfile.js文件</font></p><p><font color="blue">说明</font>：gulpfile.js是gulp项目的配置文件，是位于项目根目录的普通js文件（其实将gulpfile.js放入其他文件夹下亦可）。<br><img src="/images/gulp的使用/1.png" alt="gulp的使用"></p><hr><p><font color="red">4. 运行gulp</font><br>$ gulp 任务名称<br>例如编译less：$ gulp testLess（任务名称）<br>当执行$ gulp default或$ gulp 将会调用default任务里的所有任务[‘testLess’,’elseTask’]。</p><hr><p><strong>日常啰嗦</strong>：在极客学院的培训课上有一章节叫做‘任务10 掌握前端工业化框架(高级进阶)’，里面介绍了grunt，gulp，bower，yeoman，FIS,FIS3这些打包工具，还是当时学的时候有点懂，久了就忘记了，还是需要把有必要的工具总结下，以便得到巩固。</p>]]></content>
      
      <categories>
          
          <category> 自动化构建工具 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>webpack</title>
      <link href="/2018/06/27/webpack/"/>
      <url>/2018/06/27/webpack/</url>
      <content type="html"><![CDATA[<p>Webpack是一个前端资源加载/打包工具。它将根据<font color="red">模块的依赖关系</font>进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源。<br><a id="more"></a><br>它主要的用途是通过<font color="red">CommonJS</font>的语法把所有浏览器端需要发布的静态资源做相应的准备，比如<font color="red">资源的合并和打包</font>。<br>Webpack 可以将多种静态资源 js、css、less 转换成一个静态文件，减少了页面的请求。会给每个模块分配一个唯一的 id 并通过这个 id 索引和访问模块。 </p><p>WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其转换和打包为合适的格式供浏览器使用。 </p><p><font color="red">WebPack和Grunt以及Gulp相比有什么特性 </font><br>其实Webpack和另外两个并没有太多的可比性<br>Gulp/Grunt是一种能够优化前端的开发流程的工具<br>而WebPack是一种模块化的解决方案，不过Webpack的优点使得Webpack在很多场景下可以替代Gulp/Grunt类的工具。 </p><p>Grunt和Gulp的工作方式是：在一个配置文件中，指明对某些文件进行类似编译，组合，压缩等任务的具体步骤，工具之后可以自动替你完成这些任务。</p><hr><p><strong>日常啰嗦</strong>：学了很多打包工具的皮毛，然后又很理直气壮地全部忘光了，导致一个都不熟。整理一下，希望有个大致的印象对各个工具的功能。<br>这是在vue项目里面使用的打包工具，执行vue run build就会生成dist文件</p>]]></content>
      
      <categories>
          
          <category> 打包工具 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>vue-cli 搭建项目</title>
      <link href="/2018/06/27/vue-cli%20%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/"/>
      <url>/2018/06/27/vue-cli%20%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/</url>
      <content type="html"><![CDATA[<font color="#42b983">1. 创建一个基于 webpack 模板的新项目</font><br>$ vue init webpack 目录名<br><img src="/images/vue-cli 搭建项目/2.png" alt="vue-cli 搭建项目"><a id="more"></a><br>配置的模板，一般使用standards，高阶选手使用最后一个，什么都没有，需要自己配置。<br>eslint是一个代码语法规范检查的工具，不同意就不会把检查语法规范的功能加进webpack编译的流程里。<br>unit tests单元测试，一般不加，因为不会。<br><br>——–<br><font color="#42b983">2. 安装依赖(进入项目文件夹)</font><br>$ npm install<br><br>—-<br><font color="#42b983">3. 开始运行项目（开发模式）</font><br>$ npm run dev<br>默认运行端口8080<br><br>—–<br><font color="#42b983">4. 打包代码</font><br>$ npm run build<br>该命令可以打包你的代码的，不会报任何异常或错误，但是你会看到你的命令行打包完成有这样一句提示：<br><img src="/images/vue-cli 搭建项目/5.png" alt="vue-cli 搭建项目"><br>用浏览器打开了你刚build生成的dist目录下的index.html文件！<br>然而，你惊奇地发现网页一片空白，丝毫没有一点点痕迹。<br>打开了控制台，看到console下一片404的各种找不到资源。<br><img src="/images/vue-cli 搭建项目/6.png" alt="vue-cli 搭建项目"><br>为什么会这样呢？还得从第一幅图的build后的提示说起，提示的中文翻译是（提示：构建文件务必放在一个HTTP服务器。直接打开index.html文件将不工作）<br>所以你看到控制台里的一堆404！<br><font color="red">解决方案</font><br>仔细看一下路径，绝对路径，c盘下哪有static文件夹，那就要将打包的路径改为<font color="red">相对路径</font>。这个根据build命令一路跟踪，到项目目录下的config文件夹里的index.js文件中的build对象，将<font color="red">assetsPublicPath</font>中的“/”，改为“<font color="red">./</font>”即可，就在前面加个点就可以了，并在build\build.js将这两句的提示信息删掉或注释掉，再打包直接用浏览器直接运行就好了。<br><img src="/images/vue-cli 搭建项目/7.png" alt="vue-cli 搭建项目"><br><font color="red">*注：项目上线时，只需要将 dist 文件夹放到服务器就行了。</font><hr><p><strong>日常啰嗦</strong>：后面一部分vue run build转载自小小猫钓小小鱼<a href="https://www.cnblogs.com/h2zZhou/p/7614599.html。觉得他写的挺好的，把我的疑惑解决了一部分，开来写文还是有很大好处的，理清了我的思路。不过我还是有一个很大的疑惑，为什么我" target="_blank" rel="noopener">https://www.cnblogs.com/h2zZhou/p/7614599.html。觉得他写的挺好的，把我的疑惑解决了一部分，开来写文还是有很大好处的，理清了我的思路。不过我还是有一个很大的疑惑，为什么我</a><font color="red">在服务器设置访问路径为根目录（例如xx.xx.xx.xx/）vue项目就可以运行，设置访问路径为二级目录就访问不了（例如xx.xx.xx.xx/goodsmall），已经更改了assetsPublicPath路径</font>。希望我以后可以来填坑。</p>]]></content>
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>vue目录结构</title>
      <link href="/2018/06/27/vue%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/"/>
      <url>/2018/06/27/vue%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<ol><li>主目录结构<br><img src="/images/vue目录结构/1.png" alt="vue目录结构"><a id="more"></a></li></ol><p><font color="red">build:</font>    项目构建(webpack)相关代码<br><img src="/images/vue目录结构/3.png" alt="vue目录结构"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="blue">build.js:</font>生产环境构建脚本<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="blue">utils.js:</font>构建相关工具方法<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="blue">webpack.base.conf.js:</font>wabpack基础配置<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="blue">webpack.dev.conf.js:</font>wabpack开发环境配置<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="blue">webpack.prod.conf.js:</font>wabpack生产环境配置</p><p><font color="red">config:</font> 配置目录，包括端口号等.可以使用默认的。<br><img src="/images/vue目录结构/4.png" alt="vue目录结构"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="blue">dev.env.js:</font>开发环境变量<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="blue">index.js:</font>项目配置文件<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="blue">prod.env.js:</font>生产环境变量</p><p><font color="red">node_modules:</font> npm 加载的项目依赖模块</p><p><font color="red">src:</font> 这里是我们要开发的目录，基本上要做的事情都在这个目录里。里面包含了几个目录及文件：<br><img src="/images/vue目录结构/2.png" alt="vue目录结构"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="blue">assets:</font>资源目录，放置一些图片，如logo等。这里的资源会被wabpack构建<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="blue">components:</font> 公共组件目录。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="blue">routes:</font>前端路由。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="blue">App.vue:</font> 根组件，项目入口文件，我们也可以直接将组件写这里，而不使用 components 目录。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="blue">main.js:</font> 入口js文件。</p><p><font color="red">static:</font> 静态资源目录，如图片、字体等。不会被wabpack构建</p><p><font color="red">.xxxx文件:</font>    这些是一些配置文件，包括语法配置，git配置等。</p><p><font color="red">index.html:</font> 首页入口文件，你可以添加一些 meta 信息或统计代码啥的。</p><p><font color="red">package.json:</font> 项目配置文件</p><p><font color="red">README.md:</font>    项目的说明文档，markdown格式</p><hr><p><strong>日常啰嗦</strong>：这个也是在网上多家比较总结出来。恩从基础打起。进一步了解了webpack构建。</p>]]></content>
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>github删除本地.git</title>
      <link href="/2018/06/27/github%E5%88%A0%E9%99%A4%E6%9C%AC%E5%9C%B0-git/"/>
      <url>/2018/06/27/github%E5%88%A0%E9%99%A4%E6%9C%AC%E5%9C%B0-git/</url>
      <content type="html"><![CDATA[<font color="red">文件夹和文件一起删除</font><p>$ rd /s /q 文件夹名<br>如：$ rd /s /q .git 这样就将本地文件由git仓库变成普通文件</p><a id="more"></a><hr><p><font color="red"><strong>扩展</strong></font>dos命令删除文件夹和文件</p><ol><li>删除文件夹<br>$ rd 文件夹名。这种删除方法必须要该文件夹是空文件夹，不然删除不了。</li><li>删除文件<br>$ del 文件名。该命令只能删除文件，不能删除文件夹。</li></ol><p><font color="red"><strong>扩展</strong></font><br>del–delete删除文件。<br>rd–remove directionary删除目录。</p><p><font color="red"><strong>扩展</strong></font><br>/s 表示删除该目录下所有遍历的子目录和文件<br>/q 删除目录时不提示确认，直接删除</p><hr><p><strong>日常啰嗦</strong>：用一次百度一次也是够了，这次就一次性把相关的内容都百度出来了，希望可以记得更牢靠。</p>]]></content>
      
      <categories>
          
          <category> github </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>hexo删除文章</title>
      <link href="/2018/06/27/hexo%E5%88%A0%E9%99%A4%E6%96%87%E7%AB%A0/"/>
      <url>/2018/06/27/hexo%E5%88%A0%E9%99%A4%E6%96%87%E7%AB%A0/</url>
      <content type="html"><![CDATA[<p>先删除本地文件，然后通过生成（hexo g）和部署（hexo d）命令进而将远程仓库中的文件也一并删除。<br><a id="more"></a><br>具体来说，以最开始默认形成的helloworld.md这篇文章为例。<br>首先进入到source / _post 文件夹中，找到helloworld.md文件，在本地直接执行删除。然后依次执行hexo g，hexo d，再去主页查看你就会发现你的博客上面已经空空如也了，这就是如何删除文章的方法。</p><p><strong>日常啰嗦</strong>：是不是很简单，get√</p>]]></content>
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>hexo目录结构</title>
      <link href="/2018/06/27/hexo%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/"/>
      <url>/2018/06/27/hexo%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<ol><li>主目录结构<br><img src="/images/hexo目录结构/1.png" alt="hexo目录结构"><a id="more"></a></li></ol><p><font color="#ec6149">public：</font>生成的网站文件，发布的站点文件。</p><p><font color="#ec6149">scaffolds：</font>scaffolds是“脚手架、骨架”的意思，当你新建一篇文章(hexo new ‘title’)的时候，hexo是根据这个目录下的文件进行构建的。</p><p><font color="#ec6149">source：</font>这个目录很重要，新建的文章都是在保存在这个目录下的。</p><p><font color="#ec6149">themes：</font>网站主题目录，hexo有非常好的主题拓展，支持的主题也很丰富。该目录下，每一个子目录就是一个主题。</p><p><font color="#ec6149">_config.yml：</font>全局配置文件，网站的很多信息都在这里配置，诸如网站名称，副标题，描述，作者，语言，主题，部署等等参数。</p><p><font color="#ec6149">package.json：</font>hexo框架的参数和所依赖插件。</p><hr><ol start="2"><li>source目录结构<br><img src="/images/hexo目录结构/2.png" alt="hexo目录结构"></li></ol><p><font color="#ec6149">_posts：</font>需要新建的博文都放在 _posts目录下。 _posts目录下是一个个 markdown 文件。md文件会被编译成html文件，放到public文件夹下。<br><img src="/images/hexo目录结构/3.png" alt="hexo目录结构"></p><p><font color="#ec6149">tag：</font>标签文件夹。</p><p><font color="#ec6149">category：</font>分类文件夹。</p><hr><p><strong>日常小叨</strong>：本文是在网上多家比较复制粘贴过来的。</p>]]></content>
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>hexo写文命令</title>
      <link href="/2018/06/27/hexo%E5%86%99%E6%96%87%E5%91%BD%E4%BB%A4/"/>
      <url>/2018/06/27/hexo%E5%86%99%E6%96%87%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<p>每次部署的步骤，可按以下三步来进行。<br>$ hexo clean<br>$ hexo generate<br>$ hexo deploy<br><a id="more"></a></p><hr><p><font color="red">1. new 新建文章的指令</font><br>$ hexo new [layout] &lt;title><br>如果title包含空格的话，请使用引号括起来。<br>layout为可选项，默认使用_config.yml中的default_layout。<br><img src="/images/hexo写文命令/1.png" alt="hexo写文命令"></p><hr><p><font color="red">2. generate 生成静态页面至public目录</font><br>$ hexo generate<br>可选参数：<br>-d ,–deploy 文件生成后立即部署网站<br>-w , –watch 监视文件变动<br>该指令可以简写为hexo g</p><hr><p><font color="red">3. deploy发布到网站，将.deploy_git目录部署到GitHub</font><br>$ hexo deploy<br>这里就是发布到_config.yml中deploy中设置的网址上。<br>参数<br>-g , –generate 部署前生成静态文件<br>该命令可以简写hexo d</p><hr><p><font color="red">4. publish发表草稿</font><br>$ hexo publish [layout] <filename></filename></p><hr><p><font color="red">5. server启动服务器</font><br>$ hexo server<br>默认情况下，访问网址为：<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a></p><p>选项    描述<br>-p, –port    重设端口<br>-s, –static    只使用静态文件<br>-l, –log    启动日记记录，使用覆盖记录格式</p><hr><p><font color="red">6. clean清除缓存文件 (db.json) 和已生成的静态文件 (public)</font><br>$ hexo clean<br>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p><hr><p><strong>日常啰嗦</strong>：我这猪脑子就应该吧这些东西都记一遍，这才能把他变成自己的，俗话说得好：好记性不如烂手指头。</p>]]></content>
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>hexo写文必备常识</title>
      <link href="/2018/06/27/hexo%E5%86%99%E6%96%87%E5%BF%85%E5%A4%87%E5%B8%B8%E8%AF%86/"/>
      <url>/2018/06/27/hexo%E5%86%99%E6%96%87%E5%BF%85%E5%A4%87%E5%B8%B8%E8%AF%86/</url>
      <content type="html"><![CDATA[<ol><li>修改文章的字体和颜色</li></ol><p><font color="red">我是红色哟</font><br><img src="/images/hexo写文必备常识/1.jpg" alt="hexo写文必备常识"></p><a id="more"></a><hr><ol start="2"><li>在首页上出现‘阅读全文’按钮</li></ol><p><img src="/images/hexo写文必备常识/2.png" alt="hexo写文必备常识"></p><hr><ol start="3"><li>在文章内引入图片</li></ol><p>在source目录下新建一个存放图片的文件夹images（自定义）<br>将图片存放在images里面，引用时图片路径为/images/XXX.jpg</p><p>我是将每一篇文章的图片都区分开，存放在不同的目录下，所以图片引用路径为<br><img src="/images/hexo写文必备常识/3.jpg" alt="hexo写文必备常识"></p><hr><ol start="4"><li>Front-matter的冒号后面应添加一个空白格</li></ol><p>Front-matter 是文件最上方以 — 分隔的区域，用于指定个别文件的变量<br><img src="/images/hexo写文必备常识/5.png" alt="hexo写文必备常识"></p><p>若是冒号后面没有添加空白格，则会显示如下错误：<br><img src="/images/hexo写文必备常识/4.png" alt="hexo写文必备常识"></p><hr><ol start="5"><li>在文章内添加空格</li></ol><p>a. 在中文输入法下使用全角：shift＋空格键切换至全角模式，之后再按空格键，那么空格键就会生效。<br><img src="/images/hexo写文必备常识/6.png" alt="hexo写文必备常识"></p><hr><p><strong>日常啰嗦</strong>：每次写文都有点底气不足，野心很大，奈何技术上跟不上，或者是上次学了用了的命令这次又忘光，上网百度又费时间。所以现在就准备把一些常用的写文必备命令写下来，我看你这样还忘不忘，就算忘了我也不怕，现在我有宝典在手哈哈。</p>]]></content>
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>hexo开博小坑</title>
      <link href="/2018/06/27/hexo%E5%BC%80%E5%8D%9A%E5%B0%8F%E5%9D%91/"/>
      <url>/2018/06/27/hexo%E5%BC%80%E5%8D%9A%E5%B0%8F%E5%9D%91/</url>
      <content type="html"><![CDATA[<ol><li>在本地安装完hexo，设置_config.yml之后，将hexo同步到github时，一直报错，报错信息如下：<br><img src="/images/hexo安装小坑/hexo安装小坑1.png" alt="hexo安装小坑"><a id="more"></a>百度了好久为什么会这样，后来发现是自己眼瞎，百度出来的文章明明写着<br><img src="/images/hexo安装小坑/hexo安装小坑3.jpg" alt="hexo安装小坑"><br>所以配置的_config.yml文件应该是<br><img src="/images/hexo安装小坑/hexo安装小坑2.png" alt="hexo安装小坑"></li></ol><p><font color="red"><strong>扩展</strong>：</font>至于为什么需要在冒号后加空白符呢？这是因为yaml文件的语法的规定<br>每个冒号后面一定要有一个空格（以冒号结尾不需要空格，表示文件路径的模版可以不需要空格），这里指的是键值对，例如：mykey: my_value</p><hr><p>2.创建仓库时需要注意的地方:仓库名字一定要是 你的账户名字.github.io<br>不知道为什么账号名字不能为大写（所以为了开博，我废弃了之前的XIEshuangTING账号）（以后再来填坑）</p><hr><p><strong>日常啰嗦</strong>：为了顺应潮流，想开博的心思已经不能再耽搁了。本来想在阿里云服务器上搭建博客的，奈何自己不太懂服务器的知识（怪自己上课没认真听讲，不过我觉得学校讲的知识应该也是不足以支撑实践的，不要拆穿我，这是给自己的安慰=.=），捣鼓了几天，还是没捣鼓出来，我这暴脾气一下子就上来了，我一定要征服你。所以又捣鼓了几天，果然理想和现实是有差距的，这差距真特么地烦人，所以我就华丽丽地放弃了哈哈。那这样不行我们就下降标准吧，所以就有了这个hexo+github的博客。</p>]]></content>
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>vue2.0+node.js+MongoDB全栈打造商城(1)</title>
      <link href="/2018/06/24/vue2-0-node-js-MongoDB%E5%85%A8%E6%A0%88%E6%89%93%E9%80%A0%E5%95%86%E5%9F%8E/"/>
      <url>/2018/06/24/vue2-0-node-js-MongoDB%E5%85%A8%E6%A0%88%E6%89%93%E9%80%A0%E5%95%86%E5%9F%8E/</url>
      <content type="html"><![CDATA[<p>学完了慕课网视频《vue2.0+node.js+MongoDB全栈打造商城》，并且也把改商城开发好了。但是时间久了也忘记了具体的细节了，所以想在看一遍并且记录下来。<br><a id="more"></a></p><h3 id="一-课程介绍"><a href="#一-课程介绍" class="headerlink" title="一.课程介绍"></a>一.课程介绍</h3><h4 id="1-导学"><a href="#1-导学" class="headerlink" title="1.导学"></a>1.导学</h4><p><img src="/images/全栈打造商城-1/2.png"><br><img src="/images/全栈打造商城-1/3.png"><br><img src="/images/全栈打造商城-1/4.png"><br><img src="/images/全栈打造商城-1/5.png"></p><h4 id="2-前端框架的回顾"><a href="#2-前端框架的回顾" class="headerlink" title="2.前端框架的回顾"></a>2.前端框架的回顾</h4><p><img src="/images/全栈打造商城-1/1.png"><br><img src="/images/全栈打造商城-1/6.png"><br><img src="/images/全栈打造商城-1/7.png"></p><h4 id="3-vue概括以及核心思想"><a href="#3-vue概括以及核心思想" class="headerlink" title="3.vue概括以及核心思想"></a>3.vue概括以及核心思想</h4><p><img src="/images/全栈打造商城-1/8.png"><br><img src="/images/全栈打造商城-1/9.png"><br><img src="/images/全栈打造商城-1/10.png"><br><img src="/images/全栈打造商城-1/11.png"><br><img src="/images/全栈打造商城-1/12.png"><br><img src="/images/全栈打造商城-1/13.png"><br><img src="/images/全栈打造商城-1/14.png"></p><h4 id="4-vue优点对比"><a href="#4-vue优点对比" class="headerlink" title="4.vue优点对比"></a>4.vue优点对比</h4><p><img src="/images/全栈打造商城-1/15.png"><br><img src="/images/全栈打造商城-1/16.png"><br><img src="/images/全栈打造商城-1/17.png"><br>状态管理工具:vuex</p><h3 id="二-vue基础"><a href="#二-vue基础" class="headerlink" title="二.vue基础"></a>二.vue基础</h3><h4 id="1-vue环境搭建"><a href="#1-vue环境搭建" class="headerlink" title="1.vue环境搭建"></a>1.vue环境搭建</h4><p><img src="/images/全栈打造商城-1/18.png"><br>项目名称小写（大写不通过）</p><h4 id="2-vue配置"><a href="#2-vue配置" class="headerlink" title="2.vue配置"></a>2.vue配置</h4><p>vue的目录结构</p><h4 id="3-vue的基础语法"><a href="#3-vue的基础语法" class="headerlink" title="3.vue的基础语法"></a>3.vue的基础语法</h4><p><img src="/images/全栈打造商城-1/19.png"><br><img src="/images/全栈打造商城-1/20.png"><br>对象语法:v-bind:class 指令也可以与普通的 class 属性共存。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;static&quot;</span><br><span class="line">     v-bind:class=&quot;&#123; active: isActive, &apos;text-danger&apos;: hasError &#125;&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>数组语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:class=&quot;[activeClass, errorClass]&quot;&gt;&lt;/div&gt;</span><br><span class="line">data: &#123;</span><br><span class="line">  activeClass: &apos;active&apos;,</span><br><span class="line">  errorClass: &apos;text-danger&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>style绑定-对象语法：内联样式<br><img src="/images/全栈打造商城-1/21.png"><br>v-cloak属性和 CSS 规则如 <font color="red">[v-cloak] { display: none }</font>一起用<br>v-cloak属性的 html 标签在页面初始化时会被隐藏。<br>在 vuejs instance ready 之后，v-cloak 属性会被自动去除，也就是对应的标签会变为可见。<br>为什么我用的 v-cloak 无效？<br>在实际项目中，我们常通过 @import 来加载 css 文件<br>例如：@import “style.css”<br>而 <font color="red">@import 是在页面 DOM 完全载入后才会进行加载</font>，如果我们将 [v-cloak] 写在 @import 加载的 css 文件中，就会导致页面仍旧闪烁。<br>为了避免这种情况，我们可以将 [v-cloak] 写在 link 引入的 css 中，或者写一个内联 css 样式，这样就得到了解决。<br><img src="/images/全栈打造商城-1/22.png"><br><img src="/images/全栈打造商城-1/23.png"><br>可以使用script引入node_modules的资源<br><img src="/images/全栈打造商城-1/24.png"></p><h3 id="三：Vue-router"><a href="#三：Vue-router" class="headerlink" title="三：Vue-router"></a>三：Vue-router</h3><h4 id="1-路由基础介绍"><a href="#1-路由基础介绍" class="headerlink" title="1.路由基础介绍"></a>1.路由基础介绍</h4><p><img src="/images/全栈打造商城-1/25.png"><br><img src="/images/全栈打造商城-1/26.png"><br><img src="/images/全栈打造商城-1/27.png"><br>在 HTML5 history 模式下，router-link 会拦截点击事件，让浏览器不在重新加载页面。<br>router-link 标签渲染成了 a 标签，to 属性变成了a 标签的 href 属性，这时就明白了点击跳转的意思。router-view 标签渲染成了我们定义的组件，其实它就是一个占位符，它在什么地方，匹配路径的组件就在什么地方，所以 router-link 和router-view 标签一一对应，成对出现。</p><p><font color="blue">router-link跳转标签，相当于a<br>router-view组件渲染</font></p><p><font color="red"><strong>扩展：</strong></font><br>1.你要懂的单页面应用和多页面应用 <a href="https://juejin.im/post/5a0ea4ec6fb9a0450407725c" target="_blank" rel="noopener">https://juejin.im/post/5a0ea4ec6fb9a0450407725c</a><br>2.vue-router 基本使用 <a href="https://www.cnblogs.com/SamWeb/p/6610733.html" target="_blank" rel="noopener">https://www.cnblogs.com/SamWeb/p/6610733.html</a><br><img src="/images/全栈打造商城-1/28.png"></p><h4 id="2-动态路由匹配"><a href="#2-动态路由匹配" class="headerlink" title="2.动态路由匹配"></a>2.动态路由匹配</h4><p>应用：详情页面，根据商品的id来加载页面<br><img src="/images/全栈打造商城-1/29.png"><br>在src中新建router文件，就会自动生成index.js文件<br><img src="/images/全栈打造商城-1/30.png"><br>在src中新建views文件，再新建GoodsList组件（views文件放置页面，component放置可以复用的组件）<br>$route对history的封装<br><img src="/images/全栈打造商城-1/31.png"><br><img src="/images/全栈打造商城-1/32.png"><br>vue-router 默认 hash 模式 —— 使用 URL 的 hash 来模拟一个完整的 URL，于是当 URL 改变时，页面不会重新加载。因为对于正常的页面来说，更换url一定是会导致页面的更换的， 而只有更换url中的查询字符串和hash值得时候才不会重新加载页面。 这里也就是这个道理。<br>所以，如果不想要，可以使用路由的history模式！！！ 这种模式充分利用了history.pushState API来完成URL的跳转而不需要重新加载页面。</p><p><font color="red"><strong>扩展：</strong></font><br>如何去除vue项目中的 # — History模式<br><a href="https://www.cnblogs.com/zhuzhenwei918/p/6892066.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhuzhenwei918/p/6892066.html</a></p><h4 id="3-嵌套路由"><a href="#3-嵌套路由" class="headerlink" title="3.嵌套路由"></a>3.嵌套路由</h4><p>应用：（比如个人主页中的个人信息）同个页面不同菜单的切换<br>二级路由的路径，不用加‘/’<br><img src="/images/全栈打造商城-1/33.png"><br>应用的时候使用绝对地址<br><img src="/images/全栈打造商城-1/34.png"></p><h4 id="4-编程式路由"><a href="#4-编程式路由" class="headerlink" title="4.编程式路由"></a>4.编程式路由</h4><p><img src="/images/全栈打造商城-1/35.png"><br><img src="/images/全栈打造商城-1/36.png"><br><img src="/images/全栈打造商城-1/37.png"><br>jump(){}  是es6的写法，原来的写法jump：function(){}<br><img src="/images/全栈打造商城-1/38.png"><br>$route.params.goodId组件跟组件之间路由切换的时候参数的传递(路由的参数)<br><img src="/images/全栈打造商城-1/39.png"><br>$route.query.goodId动态路由页面之间<br><img src="/images/全栈打造商城-1/40.png"></p><h4 id="5-命名路由和命名视图"><a href="#5-命名路由和命名视图" class="headerlink" title="5.命名路由和命名视图"></a>5.命名路由和命名视图</h4><p><img src="/images/全栈打造商城-1/41.png"><br><img src="/images/全栈打造商城-1/42.png"><br><img src="/images/全栈打造商城-1/43.png"><br><img src="/images/全栈打造商城-1/44.png"><br><img src="/images/全栈打造商城-1/46.png"><br><img src="/images/全栈打造商城-1/45.png"><br>命名视图（一般不使用）<br><img src="/images/全栈打造商城-1/47.png"><br><img src="/images/全栈打造商城-1/48.png"></p>]]></content>
      
      <categories>
          
          <category> vue </category>
          
          <category> vue2.0+node.js+MongoDB全栈打造商城 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>记github的使用</title>
      <link href="/2018/06/12/%E8%AE%B0github%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/06/12/%E8%AE%B0github%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h1 id="git-的配置信息"><a href="#git-的配置信息" class="headerlink" title="git 的配置信息"></a>git 的配置信息</h1><p>获取并设置存储库或全局选项 git config </p><p>config 配置三个级别：<br>system级别 global（用户级别） 和local（当前仓库）<br>local&gt;global&gt;system </p><a id="more"></a><p>想了解 Git 的各式工具该怎么用，可以阅读它们的使用帮助，方法有三：<br>git XXX –help / git help XXX / man git-XXX<br>例如：git config –help</p><p><strong>git配置的增删改查</strong><br>增：git config –global user.name XXX<br>git config –global <strong>–add</strong> user.name XXX<br>改：git config –global user.mane XXX2<br>删：git config –global <strong>–unset</strong> user.name<br>查：git config <strong>–get</strong> user.name<br>git config user.name</p><p>检查已有的配置信息git config –global –list </p><p><strong>为git子命令配置别名</strong>：git config –global alias.co cheskout</p><h1 id="git-的基本工作流程"><a href="#git-的基本工作流程" class="headerlink" title="git 的基本工作流程"></a>git 的基本工作流程</h1><p>git使用40个16进制字符的HASH来唯一标识对象</p><p><strong>对象分为4种</strong><br>blob:用来存储文件内容， 或者说表示一个文件。例如：文本文件，二进制文件，链接文件<br>tree:目录<br>commit:历史提交<br>tag:标签，commit的别名。指向固定的历史提交<br>关系：tag-&gt;commit-&gt;tree(可包含其他的tree对象)-&gt;blob<br>git只关心文件的内容，若两份文件的内容相同，则会指向同一个blob对象，文件名或者其他信息会存储在tree对象里</p><p><strong>创建仓库</strong><br><strong>git仓库分两种：</strong><br>一种为裸仓库，不带工作区，通常用于服务器中和其他用户方便协作（没有.git的目录）<br>$ git init –bare XXX<br>一种是本地仓库，会自动创建.git目录<br>$ git init 仓库名字<br>已经有的环境把他纳入git的管理 进入这个文件夹，在这里执行git init命令<br>获得git仓库 需要一个远程仓库的地址<br>$ git clone &lt;版本库的网址&gt;<br>该命令会在本地主机生成一个目录，与远程主机的版本库同名。如果要指定不同的目录名，可以将目录名作为git clone命令的第二个参数。<br>$ git clone &lt;版本库的网址&gt; &lt;本地目录名&gt;</p><p><strong>git仓库有3个工作区域 </strong><br>工作区–日常编辑代码的地方，维护着树形结构<br>暂存区–需要提交的工作状态，维护着虚拟的树型结构，代表了下一次提交内容的整体<br>历史仓库–commit指向的树形结构</p><p><strong>添加操作</strong><br>$ git add <em>path</em> 将修改添加到暂存区,也就是将要提交的文件的信息添加到索引库中。<em>path</em>可以是文件也可以是目录。<br>$ git add . 或者 $ git add -A 将所有修改添加到暂存区<br>$ git states 查看工作区和暂存区的区别</p><p><strong>删除操作</strong><br>$ git rm a 同时把工作区和暂存区里面的a引用删掉<br>$ git rm –cached a 只删除暂存区里的文件</p><p>未被Git跟踪的状态为<em>unstage</em>状态（存放在暂存区的文件）<br>已经被Git跟踪的状态为<em>stage</em>状态，因此包括<em>staging</em>状态状态和<em>staged</em>状态<br><em>untrack files</em>是指尚未被git所管理的文件；<br><em>changed but not updated</em>是指文件被git管理，并且发生了改变，但改动还没被git管理；<br>这两种状态，都可以看成是改动还没被git管理的状态，我们这里称非stage状态。<br><em>changes to be commited</em>是指进入stage状态的文件，stage是commit和未管理之间的一个状态，也有别名叫index状态，也就是git已经管理了这些改动，但是还没完成提交。<br>.gitignore中的文件，不会出现在以上三个状态中。</p><p><strong>撤销操作</strong><br>$ git checkout file 命令用于切换分支或恢复工作树文件<br>$ git reset HEAD file  回退文件，将文件从暂存区回退到工作区<br>$ git reset HEAD^ ：回退版本，一个^表示一个版本，可以多个，另外也可以使用$ git reset HEAD～n这种形式</p><p><strong>移动操作</strong><br>$ git mv oldname newnae 工作区中重命名文件，移动文件<br>git实际上并没有重命名移动的说法，是一系列操作的组合<br>在工作区中，把你需要的文件重命名和移动，在暂存区里把原有的文件删除了，在把新的文件添加进暂存区</p><p><strong>.gitignore文件</strong><br>*.[oa] 匹配以o或者a结尾的文件<br>*~ 匹配有~的文件<br>*.pyc 匹配所有以pyc为扩展名的文件<br>!test.pyc test.pyc文件不被忽略<br>\!test.pyc 若原来文件名是以！开头的需要转义符号<br>foo/ 匹配foo文件夹（foo文件不被匹配）<br>**/res **/意味着匹配0个或者多个目录，顶层文件的res会被匹配到，其他目录下的子目录的res也会被匹配到</p><p>在工作区的顶层目录下或者你需要的位置下创建.gitignore文件<br>工作区里面一些不希望被添加到暂存区和历史上的文件不被添加进去</p><p><strong>添加到历史仓库</strong><br>git commit -m “xxx”</p>]]></content>
      
      <categories>
          
          <category> github </category>
          
      </categories>
      
      
    </entry>
    
  
  
</search>
